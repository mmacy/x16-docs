{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#commander-x16-reference-manual","title":"Commander X16 Reference Manual","text":"<p>This is an unofficial MkDocs-based rendering of the official Commander X16 reference manual.</p> <p>Being a reference manual it is light on some details with some expected fundamental knowledge. If you are brand new to the X16, consider consulting the User Guide first.</p>"},{"location":"#chapters","title":"Chapters","text":"<ul> <li>Chapter 1: Overview</li> <li>Chapter 2: Getting Started</li> <li>Chapter 3: Editor</li> <li>Chapter 4: BASIC</li> <li>Chapter 5: KERNAL</li> <li>Chapter 6: Math Library</li> <li>Chapter 7: Machine Language Monitor</li> <li>Chapter 8: Memory Map</li> <li>Chapter 9: VERA Programmer's Reference</li> <li>Chapter 10: VERA FX Reference</li> <li>Chapter 11: Sound Programming</li> <li>Chapter 12: I/O Programming</li> <li>Chapter 13: Working with CMDR-DOS</li> <li>Chapter 14: Hardware Pinouts</li> <li>Chapter 15: Upgrade Guide</li> <li>Appendix A: Sound</li> <li>Appendix B: VERA Firmware Recovery</li> <li>Appendix C: The 65C02 Processor</li> <li>Appendix D: Official Expansion Cards</li> <li>Appendix E: Diagnostic Bank</li> <li>Appendix F: The 65C816 Processor</li> </ul>"},{"location":"#external-links","title":"External Links","text":"<ul> <li>Official Website</li> <li>Documentation Source</li> <li>User Guide Source</li> </ul>"},{"location":"X16%20Reference%20-%2001%20-%20Overview/","title":"1: Overview","text":"<p>The Commander X16 is a modern home computer in the philosophy of Commodore computers like the VIC-20 and the C64.</p> <p>Features:</p> <ul> <li>8-bit 65C02S CPU at 8 MHz (*)</li> <li>512 KB banked RAM (upgradeable to 2 MB on the X16 Developer Edition)</li> <li>512 KB ROM</li> <li>Expansion Cards (Gen 1) &amp; Cartridges (Gen 1 and Gen 2)</li> <li>Up to 3.5MB of RAM/ROM</li> <li>5 32-byte Memory-Mapped IO slots</li> <li>VERA video controller</li> <li>Up to 640x480 resolution</li> <li>256 colors from a palette of 4096</li> <li>128 sprites</li> <li>VGA, NTSC and RGB output</li> <li>three sound generators</li> <li>Yamaha YM2151: 8 channels, FM synthesis</li> <li>VERA PSG: 16 channels, 4 waveforms</li> <li>VERA PCM: Up to 48 kHz, 16 bit, stereo</li> <li>Connectivity:</li> <li>PS/2 keyboard and mouse</li> <li>4 NES/SNES controllers</li> <li>SD card</li> <li>Commodore Serial Bus (\"IEC\")</li> <li>Many Free GPIOs (\"user port\")</li> </ul> <p>As a modern sibling of the line of Commodore home computers, the Commander X16 is reasonably compatible with computers of that line.</p> <ul> <li>Pure BASIC programs are fully backwards compatible with the VIC-20 and the C64.</li> <li>POKEs for video and audio are not compatible with any Commodore computer. (There are no VIC or SID chips, for example.)</li> <li>Pure machine language programs ($FF81+ KERNAL API) are compatible with Commodore computers.</li> </ul>"},{"location":"X16%20Reference%20-%2001%20-%20Overview/#future-65c816-support","title":"Future 65C816 Support","text":"<p>A future upgrade path for the X16 may involve the 65C816. It is almost fully compatible with the 65C02 except for 4 instructions (<code>BBRx</code>, <code>BBSx</code>, <code>RMBx</code>, and <code>SMBx</code>). It is advisable not to use these instructions when writing programs for the X16.</p>"},{"location":"X16%20Reference%20-%2002%20-%20Getting%20Started/","title":"2: Getting Started","text":"<p>This is a brief guide to your first few minutes on the Commander X16. For a complete New User experience, please refer to the Commander X16 User Guide.</p>"},{"location":"X16%20Reference%20-%2002%20-%20Getting%20Started/#finding-and-starting-programs","title":"Finding and starting programs","text":"<p>When starting your Commander X16, you'll notice that it's not like other computers. There is no GUI, and command line commands like <code>DIR</code> or <code>LS</code> don't get you anywhere. Here are some quick tips to getting started:</p> <p>The Commander X16 uses a full screen interface known as \"Editor\". This was unique when it was introduced on the PET in 1977, when most computers still treated the screen as if it was a teletype display. The full screen Editor lets you use the arrow keys to move around the screen and edit or re-enter input from previous interactions.</p> <p>The first thing you will want to do is view a list of files on your SD card. Type the below command and press the Return key (or Enter key) to see a list of files:</p>"},{"location":"X16%20Reference%20-%2002%20-%20Getting%20Started/#dos","title":"DOS","text":"<p><code>DOS \"$\"</code></p> <p>You can also type <code>@$</code> and press Return. All of the commands you type must be followed by the Return or Enter key, to actually execute the command.</p> <p>Let's try some variations on this command:</p> <p><code>DOS \"$=D\"</code> lists just the subdirectories in the current directory.</p> <p>To get the DOS command a little faster, try pressing F8, then typing <code>$=D</code>. You can even leave off the last quote; DOS doesn't care.</p> <p>So now that you have a list of directories, try mnoving to one:</p> <p><code>DOS \"CD:BASIC\"</code></p> <p>Press F7 or type <code>DOS\"$</code> again to list the files in this directory. A file with .PRG at the end is a \"Program\" file and can be loaded with the LOAD command. The shortcut for LOAD\" is the F3 key. Try it now:</p>"},{"location":"X16%20Reference%20-%2002%20-%20Getting%20Started/#load","title":"LOAD","text":"<p><code>LOAD \"MAD.PRG\"</code></p> <p>You can see that the program list loaded by typing <code>LIST</code> and pressing Enter.</p>"},{"location":"X16%20Reference%20-%2002%20-%20Getting%20Started/#run","title":"RUN","text":"<p>Now type <code>RUN</code> and Enter. This will start the loaded program.</p>"},{"location":"X16%20Reference%20-%2002%20-%20Getting%20Started/#stop","title":"STOP","text":"<p>STOP isn't a command: it's a key. Press it to stop the running program.</p> <p>If you are using the official Commander X16 keyboard, the key is labeled <code>RUN STOP</code> and is up near the upper right corner of the keyboard.</p> <p>If you are using a PC keyboard, it's probably labeled <code>Pause</code> or <code>Pause Brk</code>.</p> <p>Holding Control and pressing C (also written as <code>Control+C</code> or <code>^C</code>) will also stop the running program.</p> <p>There are a few ways to get back to the text screen, but the quickest is to hold Control, Alt, and press the Del key. (Or just press the RESET button.)</p>"},{"location":"X16%20Reference%20-%2002%20-%20Getting%20Started/#using-the-keyboard","title":"Using The Keyboard","text":"<p>The Commander X16's keyboard is a little different than a standard PC: there are three distinct modes of operation, and the keyboard can create graphic symbols known as PETSCII characters. There are also some special keys used for controlling the computer.</p>"},{"location":"X16%20Reference%20-%2002%20-%20Getting%20Started/#petscii-characters","title":"PETSCII Characters","text":"<p>When the system first boots up, the X16 will be in PETSCII Upper Case/Graphic mode. Pressing a letter key without the shift key will generate an upper case letter. Unlike a PC or Mac, this mode does not have any lower case text, so everything you type is UPPER CASE.</p> <p>Now, notice the extra symbols on your keycaps? There are two sets of extra symbols: the ones on the lower-right can be accessed by holding SHIFT and a letter. Go ahead: try pressing Shift and S. You should see a small heart symbol on your screen. We know you'll love the Commander X16 as much as we do. Press Alt and a letter, and you'll get the symmbol on the lower-left corner of the screen. Try pressing Alt and the ` key next to the nummber 1. You should get a large + symbol. One of the Plusses of PETSCII is using these line drawing symbols to draw shapes on the screen.</p> <p>You can also change colors by pressing Control and a number. Go ahead: Press Control+1 and type a few letters. Notice they come out in black. Now try Alt+1. Notice the cursor changes to orange, and notice the next thing you type comes out orange.</p> <p>You can also use Control+9 to turn on Reverse Print and Control+0 to turn it off.</p> <p>There are some unexpected changes to the PC keyboard layout, as follows:</p> <ul> <li>The Grave key (`) prints a left arrow (\u2190) symbol.</li> <li>Shift+Grave prints the Pi symbol (\u03c0). This is actually the constant \"pi\". Try it by typing <code>PRINT \u03c0</code> and RETURN.</li> <li>Shift+6 prints an up arrow (\u2191)</li> <li>The \\ key prints the British Pound (\u00a3).</li> <li>The pipe (|) is replaced with a triangle corner symbol.</li> <li>{ and } are replaced with two box drawing symbols.</li> <li>Underline (Shift+-) is replaced with a | symbol.</li> </ul> <p>Note that programming languages that need {, }, and _ will alter the character set to show those symbols on the appropriate keys when needed. Or you can use ISO mode when editing C code in EDIT.</p>"},{"location":"X16%20Reference%20-%2002%20-%20Getting%20Started/#lower-case-mode","title":"Lower Case Mode","text":"<p>WORKING IN PETSCII MIGHT MAKE PEOPLE THINK YOU'RE YELLING ALL THE TIME. Fortunately, there's an upper/lower case mode, too: Hold the Alt key and tap Shift to activate lower case. Notice that the upper case letters shift to lower case, and the shifted graphic symbols (such as the heart) shift to upper case letters. The tradeoff of upper/lower case mode is that half of the graphic symbols are unavailable, but you you get lower case letters.</p> <p>Now try typing a command. <code>print \"Hello World\"</code> and press RETURN. Notice that you need to type <code>print</code> in lower case. If you did it right, you should see \"Hello World\" appear on the next line.</p> <p>Now tap Alt+Shift again. The text will change to |ELLO oORLD. Again, this is the tradeoff: you can have the Shifted graphic symbols or lower case, but not both.</p>"},{"location":"X16%20Reference%20-%2002%20-%20Getting%20Started/#iso-mode","title":"ISO Mode","text":"<p>Finally, the computer has ISO mode. The ISO mode character set operates more like a PC, with upper case text, lower case text, and an assortment of accented and other letters. In addition, ISO mode has the \\, ~, {, and } symbols, which are not available in PETSCII modes. ISO mode is useful when you need PC compatibility or want the letters with accents. Elsewhere in this guide, we have a full manual on using the Right Alt key to compose accented symbols, like \u00e9 or \u014d. Getting back to PETSCII mode from ISO mode is a little more complicated. Press Control+Alt+RESTORE (or Control+Alt+PrintScreen) to warm start BASIC and switch back to PETSCII mode.</p>"},{"location":"X16%20Reference%20-%2002%20-%20Getting%20Started/#edit-text-modes","title":"EDIT text modes","text":"<p>The built-in EDIT utility includes a character set mode switch: Press Control+E to cycle through Upper/Graphic, Upper/Lower, and ISO mode.</p>"},{"location":"X16%20Reference%20-%2002%20-%20Getting%20Started/#special-keys","title":"Special Keys","text":""},{"location":"X16%20Reference%20-%2002%20-%20Getting%20Started/#run-stop","title":"RUN STOP","text":"<p>This key actually has two separate functions: \"RUN\" and \"STOP\". Holding Shift+RUN will load the first program on your SD card and automatically run it. If you are using the SD card that came with your Commander X16, this will print some information on getting started with your computer.</p> <p>If you are running a BASIC program, pressing STOP will stop the program.</p>"},{"location":"X16%20Reference%20-%2002%20-%20Getting%20Started/#restore","title":"RESTORE","text":"<p>As mentioned above, RESTORE can be used with Control+Alt to perform a warm start of BASIC. Less drastic than a cold boot, this stops a running program and returns you to the <code>READY.</code> prompt. If you had a BASIC program loaded, you can still re-start it with RUN or view it with LIST.</p>"},{"location":"X16%20Reference%20-%2002%20-%20Getting%20Started/#controlalt_delete","title":"Control+Alt_Delete","text":"<p>Yes, the Commander X16 has the famous \"3 fingered salute.\" This performs a cold boot of the computer, including a full power cycle. You will be returned to the boot screen, and if you have an AUTOEXEC.X16, it will execute on startup.</p>"},{"location":"X16%20Reference%20-%2002%20-%20Getting%20Started/#4080-display","title":"40/80 DISPLAY","text":"<p>This switches the computer between 80x60 text mode and 40x30 text mode. 40x30 is more useful on CRT screens, so you may want to boot up into 40x30 mode. You can set these modes with BASIC by typing</p> <p><code>SCREEN 1</code> or <code>SCREEN 3</code>.</p> <p>Protip: you can force your computer to start in 40-column mode by modifying your AUTOBOOT.X16 file:</p> <pre><code>LOAD \"AUTOBOOT.X16\"\n0 SCREEN 3\nSAVE \"@:AUTOBOOT.X16\"\nBOOT\n</code></pre> <p>Don't worry, if you don't like this change, you can change it back:</p> <pre><code>LOAD \"AUTOBOOT.X16\"\nSCREEN 1\nSAVE \"@:AUTOBOOT.X16\"\nBOOT\n</code></pre>"},{"location":"X16%20Reference%20-%2002%20-%20Getting%20Started/#f-keys","title":"F-KEYS","text":"<p>The F-keys, also known as the \"Function Keys\" are pre-loaded with special shortcuts:</p> <p>F1 <code>LIST</code> Displays your currently loaded BASIC program.</p> <p>F2 <code>SAVE\"@:</code> is a quick shortcut for saving a program. The @: allows you to overwrite an existing file with the same name.</p> <p>F3 <code>LOAD \"</code> helps you load a program. Protip: if you use @$ to get a directory listing, you can then use the arrow keys to move up to a line with a filename. Press F3 and press RETURN to load a file.</p> <p>F4 and RETURN swaps between 40 and 80 column screen modes.</p> <p>F5 <code>RUN</code> runs the currently loaded program</p> <p>F6 <code>MONITOR</code> Runs the machine monitor. The monitor allows you to directly edit memory, view assembly language dumps, and even write short assembly language programs at your keyboard.</p> <p>F7 <code>DOS\"$</code> Lists the current directory</p> <p>F8 <code>DOS\"</code> allows you to enter a disk command, such as CD:. More info can be found in chapter 13.</p>"},{"location":"X16%20Reference%20-%2002%20-%20Getting%20Started/#what-is-pc-ra-ro-ac-xr-yr-sp-nvbdizc","title":"WHAT IS <code>PC  RA RO AC XR YR SP NV#BDIZC</code>?","text":"<p>There are times when the computer will drop to the MONITOR prompt. That looks like this:</p> <pre><code>C*\n   PC  RA RO AC XR YR SP NV#BDIZC\n.;E3BB 01 04 00 65 2B F6 ........\n.\u2588\n</code></pre> <p>This is the MONITOR screen. You can get there in BASIC by typing <code>MON</code>.</p> <p>Type <code>X</code> and Enter to exit back to BASIC. If you just get bounced to MONITOR again, then you'll need to Control+Alt+Restore or Control+Alt+Delete to restore to a working state.</p> <p>MONITOR is covered in Chapter 7.</p>"},{"location":"X16%20Reference%20-%2003%20-%20Editor/","title":"3: Editor","text":"<p>The X16 has a built-in screen editor that is backwards-compatible with the C64, but has many new features.</p>"},{"location":"X16%20Reference%20-%2003%20-%20Editor/#modes","title":"Modes","text":"<p>The editor's default mode is 80x60 text mode. The following text mode resolutions are supported:</p> Mode Description $00 80x60 text $01 80x30 text $02 40x60 text $03 40x30 text $04 40x15 text $05 20x30 text $06 20x15 text $07 22x23 text $08 64x50 text $09 64x25 text $0A 32x50 text $0B 32x25 text $80 320x240@256c40x30 text <p>Mode $80 contains two layers: a text layer on top of a graphics screen. In this mode, text color 0 is translucent instead of black.</p> <p>To switch modes, use the BASIC statement <code>SCREEN</code> or the KERNAL API <code>screen_mode</code>. In the BASIC editor, the F4 key toggles between modes 0 (80x60) and 3 (40x30).</p>"},{"location":"X16%20Reference%20-%2003%20-%20Editor/#iso-mode","title":"ISO Mode","text":"<p>In addition to PETSCII, the X16 also supports the ISO-8859-15 character encoding. In ISO-8859-15 mode (\"ISO mode\"):</p> <ul> <li>The character set is switched from Commodore-style (with PETSCII drawing characters) to a new ASCII/ISO-8859-15 compatible set, which covers most Western European writing systems.</li> <li>The encoding (<code>CHR$()</code> in BASIC and <code>BSOUT</code> in machine language) now complies with ASCII and ISO-8859-15.</li> <li>The keyboard driver will return ASCII/ISO-8859-15 codes.</li> </ul> <p>This is the encoding:</p> x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 xA xB xC xD xE xF 0x 1x 2x ! \" # $ % &amp; ' ( ) * + , - . / 3x 0 1 2 3 4 5 6 7 8 9 : ; &lt; = &gt; ? 4x @ A B C D E F G H I J K L M N O 5x P Q R S T U V W X Y Z [ \\ ] ^ _ 6x ` a b c d e f g h i j k l m n o 7x p q r s t u v w x y z { | } ~ 8x 9x Ax \u00a1 \u00a2 \u00a3 \u20ac \u00a5 \u0160 \u00a7 \u0161 \u00a9 \u00aa \u00ab \u00ac \ud83e\udd8b \u00ae \u00af Bx \u00b0 \u00b1 \u00b2 \u00b3 \u017d \u00b5 \u00b6 \u00b7 \u017e \u00b9 \u00ba \u00bb \u0152 \u0153 \u0178 \u00bf Cx \u00c0 \u00c1 \u00c2 \u00c3 \u00c4 \u00c5 \u00c6 \u00c7 \u00c8 \u00c9 \u00ca \u00cb \u00cc \u00cd \u00ce \u00cf Dx \u00d0 \u00d1 \u00d2 \u00d3 \u00d4 \u00d5 \u00d6 \u00d7 \u00d8 \u00d9 \u00da \u00db \u00dc \u00dd \u00de \u00df Ex \u00e0 \u00e1 \u00e2 \u00e3 \u00e4 \u00e5 \u00e6 \u00e7 \u00e8 \u00e9 \u00ea \u00eb \u00ec \u00ed \u00ee \u00ef Fx \u00f0 \u00f1 \u00f2 \u00f3 \u00f4 \u00f5 \u00f6 \u00f7 \u00f8 \u00f9 \u00fa \u00fb \u00fc \u00fd \u00fe \u00ff <ul> <li>The non-printable areas $00-$1F and $80-$9F in the character set are filled with inverted variants of the codes $40-$5F and $60-$7F, respectively.</li> <li>The code $AD is a non-printable soft hyphen in ISO-8859-15. The ROM character set contains the Commander X16 logo at this location.</li> </ul> <p>ISO mode can be enabled and disabled using two new control codes:</p> <ul> <li><code>CHR$($0F)</code>: enable ISO mode</li> <li><code>CHR$($8F)</code>: enable PETSCII mode (default)</li> </ul> <p>You can also enable ISO mode in direct mode by pressing Ctrl+<code>O</code>.</p> <p>Important: In ISO mode, BASIC keywords need to be written in upper case, that is, they have to be entered with the Shift key down, and abbreviating keywords is no longer possible.</p>"},{"location":"X16%20Reference%20-%2003%20-%20Editor/#background-color","title":"Background Color","text":"<p>In regular BASIC text mode, the video controller supports 16 foreground colors and 16 background colors for each character on the screen.</p> <p>The new \"swap fg/bg color\" code is useful to change the background color of the cursor, like this:</p> <pre><code>PRINT CHR$(1);   : REM SWAP FG/BG\nPRINT CHR$($1C); : REM SET FG COLOR TO RED\nPRINT CHR$(1);   : REM SWAP FG/BG\n</code></pre> <p>The new BASIC instruction <code>COLOR</code> makes this easier, but the trick above can also be used from machine code programs.</p> <p>To set the background color of the complete screen, it just has to be cleared after setting the color:</p> <pre><code>PRINT CHR$(147);\n</code></pre>"},{"location":"X16%20Reference%20-%2003%20-%20Editor/#scrolling","title":"Scrolling","text":"<p>The C64 editor could only scroll the screen up (when overflowing the last line or printing or entering DOWN on the last line). The X16 editor scrolls both ways: When the cursor is on the first line and UP is printed or entered, the screen contents scroll down by a line.</p>"},{"location":"X16%20Reference%20-%2003%20-%20Editor/#new-control-characters","title":"New Control Characters","text":"<p>This is the set of all supported PETSCII control characters. Entries in bold indicate new codes compared to the C64:</p> <p>If there are two meanings listed, the first indicates input (a keypress) and the second indicates output.</p> Code Code $00 NULL VERBATIM MODE $80 $01 SWAP COLORS COLOR: ORANGE $81 $02 PAGE DOWN PAGE UP $82 $03 STOP RUN $83 $04 END HELP $84 $05 COLOR: WHITE F1 $85 $06 MENU F3 $86 $07 BELL F5 $87 $08 DISALLOW CHARSET SW (SHIFT+ALT) F7 $88 $09 TAB / ALLOW CHARSET SW F2 $89 $0A LF F4 $8A $0B - F6 $8B $0C - F8 $8C $0D RETURN SHIFTED RETURN $8D $0E CHARSET: LOWER/UPPER CHARSET: UPPER/PETSCII $8E $0F CHARSET: ISO ON CHARSET: ISO OFF $8F $10 F9 COLOR: BLACK $90 $11 CURSOR: DOWN CURSOR: UP $91 $12 REVERSE ON REVERSE OFF $92 $13 HOME CLEAR $93 $14 DEL (PS/2 BACKSPACE) INSERT $94 $15 F10 COLOR: BROWN $95 $16 F11 COLOR: LIGHT RED $96 $17 F12 COLOR: DARK GRAY $97 $18 SHIFT+TAB COLOR: MIDDLE GRAY $98 $19 FWD DEL (PS/2 DEL) COLOR: LIGHT GREEN $99 $1A - COLOR: LIGHT BLUE $9A $1B ESC COLOR: LIGHT GRAY $9B $1C COLOR: RED COLOR: PURPLE $9C $1D CURSOR: RIGHT CURSOR: LEFT $9D $1E COLOR: GREEN COLOR: YELLOW $9E $1F COLOR: BLUE COLOR: CYAN $9F <p>Notes:</p> <ul> <li>$01: SWAP COLORS swaps the foreground and background colors in text mode</li> <li>$07/$09/$0A/$18/$1B: have been added for ASCII compatibility. [$0A/$18/$1B do not have any effect on output. Outputs of $08/$09 have their traditional C64 effect]</li> <li>$80: VERBATIM MODE prints the next character (only!) as a glyph without interpretation. This is similar to quote mode, but also includes codes CR ($0D) and DEL ($14).</li> <li>F9-F12: these codes match the C65 additions</li> <li>$84: This code is generated when pressing SHIFT+END.</li> <li>Additionally, the codes $04/$06/$0B/$0C are interpreted when printing in graphics mode using <code>GRAPH_put_char</code>.</li> </ul>"},{"location":"X16%20Reference%20-%2003%20-%20Editor/#keyboard-layouts","title":"Keyboard Layouts","text":"<p>The editor supports multiple keyboard layouts.</p>"},{"location":"X16%20Reference%20-%2003%20-%20Editor/#default-layout","title":"Default Layout","text":"<p>On boot, the US layout (<code>ABC/X16</code>) is active:</p> <ul> <li>In PETSCII mode, it matches the US layout where possible, and can reach all PETSCII symbols.</li> <li>In ISO mode, it matches the Macintosh US keyboard and can reach all ISO-8859-15 characters. Some characters are reachable through key combinations:</li> </ul> Key Result Alt+<code>1</code> \u00a1 Alt+<code>3</code> \u00a3 Alt+<code>4</code> \u00a2 Alt+<code>5</code> \u00a7 Alt+<code>7</code> \u00b6 Alt+<code>9</code> \u00aa Alt+<code>0</code> \u00ba Alt+<code>q</code> \u0153 Alt+<code>r</code> \u00ae Alt+<code>t</code> \u00de Alt+<code>y</code> \u00a5 Alt+<code>o</code> \u00f8 Alt+<code>\\</code> \u00ab Alt+<code>s</code> \u00df Alt+<code>d</code> \u00f0 Alt+<code>g</code> \u00a9 Alt+<code>l</code> \u00ac Alt+<code>'</code> \u00e6 Alt+<code>m</code> \u00b5 Alt+<code>/</code> \u00f7 Shift+Alt+<code>2</code> \u20ac Shift+Alt+<code>8</code> \u00b0 Shift+Alt+<code>9</code> \u00b7 Shift+Alt+<code>-</code> X16 logo Shift+Alt+<code>=</code> \u00b1 Shift+Alt+<code>q</code> \u0152 Shift+Alt+<code>t</code> \u00fe Shift+Alt+<code>\\</code> \u00bb Shift+Alt+<code>a</code> \u00b9 Shift+Alt+<code>d</code> \u00d0 Shift+Alt+<code>k</code> X16 logo Shift+Alt+<code>'</code> \u00c6 Shift+Alt+<code>c</code> \u00b3 Shift+Alt+<code>b</code> \u00b2 Shift+Alt+<code>/</code> \u00bf <p>(The X16 logo is code point \\xad, SHY, soft-hyphen.)</p> <p>The following combinations are dead keys:</p> <ul> <li>Alt+`</li> <li>Alt+<code>6</code></li> <li>Alt+<code>e</code></li> <li>Alt+<code>u</code></li> <li>Alt+<code>p</code></li> <li>Alt+<code>a</code></li> <li>Alt+<code>k</code></li> <li>Alt+<code>;</code></li> <li>Alt+<code>x</code></li> <li>Alt+<code>c</code></li> <li>Alt+<code>v</code></li> <li>Alt+<code>n</code></li> <li>Alt+<code>,</code></li> <li>Alt+<code>.</code></li> <li>Shift+Alt+<code>S</code></li> </ul> <p>They generate additional characters when combined with a second keypress:</p> First Key Second Key Result Alt+` <code>a</code> \u00e0 Alt+` <code>e</code> \u00e8 Alt+` <code>i</code> \u00ec Alt+` <code>o</code> \u00f2 Alt+` <code>u</code> \u00f9 Alt+` <code>A</code> \u00c0 Alt+` <code>E</code> \u00c8 Alt+` <code>I</code> \u00cc Alt+` <code>O</code> \u00d2 Alt+` <code>U</code> \u00d9 Alt+` <code>\u2423</code> ` Alt+<code>6</code> <code>e</code> \u00ea Alt+<code>6</code> <code>u</code> \u00fb Alt+<code>6</code> <code>i</code> \u00ee Alt+<code>6</code> <code>o</code> \u00f4 Alt+<code>6</code> <code>a</code> \u00e2 Alt+<code>6</code> <code>E</code> \u00ca Alt+<code>6</code> <code>U</code> \u00db Alt+<code>6</code> <code>I</code> \u00ce Alt+<code>6</code> <code>O</code> \u00d4 Alt+<code>6</code> <code>A</code> \u00c2 Alt+<code>e</code> <code>e</code> \u00e9 Alt+<code>e</code> <code>y</code> \u00fd Alt+<code>e</code> <code>u</code> \u00fa Alt+<code>e</code> <code>i</code> \u00ed Alt+<code>e</code> <code>o</code> \u00f3 Alt+<code>e</code> <code>a</code> \u00e1 Alt+<code>e</code> <code>E</code> \u00c9 Alt+<code>e</code> <code>Y</code> \u00dd Alt+<code>e</code> <code>U</code> \u00da Alt+<code>e</code> <code>I</code> \u00cd Alt+<code>e</code> <code>O</code> \u00d3 Alt+<code>e</code> <code>A</code> \u00c1 Alt+<code>u</code> <code>e</code> \u00eb Alt+<code>u</code> <code>y</code> \u00ff Alt+<code>u</code> <code>u</code> \u00fc Alt+<code>u</code> <code>i</code> \u00ef Alt+<code>u</code> <code>o</code> \u00f6 Alt+<code>u</code> <code>a</code> \u00e4 Alt+<code>u</code> <code>E</code> \u00cb Alt+<code>u</code> <code>Y</code> \u0178 Alt+<code>u</code> <code>U</code> \u00dc Alt+<code>u</code> <code>I</code> \u00cf Alt+<code>u</code> <code>O</code> \u00d6 Alt+<code>u</code> <code>A</code> \u00c4 Alt+<code>p</code> <code>\u2423</code> , Alt+<code>a</code> <code>\u2423</code> \u00af Alt+<code>k</code> <code>a</code> \u00e5 Alt+<code>k</code> <code>A</code> \u00c5 Alt+<code>x</code> <code>\u2423</code> . Alt+<code>c</code> <code>c</code> \u00e7 Alt+<code>c</code> <code>C</code> \u00c7 Alt+<code>v</code> <code>s</code> \u0161 Alt+<code>v</code> <code>z</code> \u017e Alt+<code>v</code> <code>S</code> \u0160 Alt+<code>v</code> <code>Z</code> \u017d Alt+<code>n</code> <code>o</code> \u00f5 Alt+<code>n</code> <code>a</code> \u00e3 Alt+<code>n</code> <code>n</code> \u00f1 Alt+<code>n</code> <code>O</code> \u00d5 Alt+<code>n</code> <code>A</code> \u00c3 Alt+<code>n</code> <code>N</code> \u00d1 Shift+Alt+<code>s</code> <code>\u2423</code> \\xa0 Shift+Alt+<code>;</code> <code>=</code> \u00d7 <p>\"\u2423\" denotes the space bar.</p>"},{"location":"X16%20Reference%20-%2003%20-%20Editor/#rom-keyboard-layouts","title":"ROM Keyboard Layouts","text":"<p>The following keyboard layouts are available from ROM. You can select one directly with the BASIC <code>KEYMAP</code> command, e.g. <code>KEYMAP\"ABC/X16\"</code>, or via the X16 Control Panel with the BASIC <code>MENU</code> command.</p> Identifier Description Code <code>ABC/X16</code> ABC - Extended (X16) - <code>EN-US/INT</code> United States - International 00020409 <code>EN-GB</code> United Kingdom 00000809 <code>SV-SE</code> Swedish 0000041D <code>DE-DE</code> German 00000407 <code>DA-DK</code> Danish 00000406 <code>IT-IT</code> Italian 00000410 <code>PL-PL</code> Polish (Programmers) 00000415 <code>NB-NO</code> Norwegian 00000414 <code>HU-HU</code> Hungarian 0000040E <code>ES-ES</code> Spanish 0000040A <code>FI-FI</code> Finnish 0000040B <code>PT-BR</code> Portuguese (Brazil ABNT) 00000416 <code>CS-CZ</code> Czech 00000405 <code>JA-JP</code> Japanese 00000411 <code>FR-FR</code> French 0000040C <code>DE-CH</code> Swiss German 00000807 <code>EN-US/DVO</code> United States - Dvorak 00010409 <code>ET-EE</code> Estonian 00000425 <code>FR-BE</code> Belgian French 0000080C <code>EN-CA</code> Canadian French 00001009 <code>IS-IS</code> Icelandic 0000040F <code>PT-PT</code> Portuguese 00000816 <code>HR-HR</code> Croatian 0000041A <code>SK-SK</code> Slovak 0000041B <code>SL-SI</code> Slovenian 00000424 <code>LV-LV</code> Latvian 00000426 <code>LT-LT</code> Lithuanian IBM 00000427 <p>All remaining keyboards are based on the respective Windows layouts. <code>EN-US/INT</code> differs from <code>EN-US</code> only in Alt/AltGr combinations and some dead keys.</p> <p>The BASIC command <code>KEYMAP</code> allows activating a specific keyboard layout. It can be added to the auto-boot file, e.g.:</p> <pre><code>10 KEYMAP\"NB-NO\"\nSAVE\"AUTOBOOT.X16\n</code></pre>"},{"location":"X16%20Reference%20-%2003%20-%20Editor/#loadable-keyboard-layouts","title":"Loadable Keyboard Layouts","text":"<p>The tables for the active keyboard layout reside in banked RAM, at $A000 on bank 0:</p> Addresses Description $A000-$A07F Table 0 $A080-$A0FF Table 1 $A100-$A17F Table 2 $A180-$A1FF Table 3 $A200-$A27F Table 4 $A280-$A07F Table 5 $A300-$A37F Table 6 $A380-$A3FF Table 7 $A400-$A47F Table 8 $A480-$A4FF Table 9 $A500-$A57F Table 10 $A580-$A58F big-endian bitfield:keynum codes for which Caps means Shift $A590-$A66F dead key table $A670-$A67E ASCIIZ identifier (e.g. \"ABC/X16\") <p>The first byte of each of the 11 tables is the table ID which contains the encoding and the combination of modifiers that this table is for.</p> Bit Description 7 0: PETSCII, 1: ISO 6-3 always 0 2 Ctrl 1 Alt 0 Shift <ul> <li>AltGr is represented by Ctrl+Alt.</li> <li>ID $C6 represents Alt or AltGr (ISO only)</li> <li>ID $C7 represents Shift+Alt or Shift+AltGr (ISO only)</li> <li>Empty tables have an ID of $FF.</li> </ul> <p>The identifier is followed by 127 output codes for the keynum inputs 1-127.</p> <ul> <li>Dead keys (i.e. keys that don't generate anything by themselves but modify the next key) have a code of 0 and are further described in the dead key table (ISO only)</li> <li>Keys that produce nothing have an entry of 0. (They can be distinguished from dead keys as they don't have an entry in the dead key table.)</li> </ul> <p>The dead key table has one section for every dead key with the following layout:</p> Byte Description 0 dead key ID (PETSCII/ISO and Shift/Alt/Ctrl) 1 dead key scancode 2 full length of this table in bytes 3 first additional key ISO code 4 first effective key ISO code 5 second additional key ISO code 6 second effective key ISO code ... ... n-1 terminator 0xFF <p>Custom layouts can be loaded from disk like this:</p> <pre><code>BLOAD\"KEYMAP\",8,0,$A000\n</code></pre> <p>Here is an example that activates a layout derived from \"ABC/X16\", with unshifted Y and Z swapped in PETSCII mode:</p> <pre><code>100 KEYMAP\"ABC/X16\"                               :REM START WITH DEFAULT LAYOUT\n110 BANK 0                                        :REM ACTIVATE RAM BANK 0\n120 FORI=0TO11:B=$A000+128*I:IFPEEK(B)&lt;&gt;0THENNEXT :REM SEARCH FOR TABLE $00\n130 POKEB+$2E,ASC(\"Y\")                            :REM SET KEYNUM $2E ('Z') to 'Y'\n140 POKEB+$16,ASC(\"Z\")                            :REM SET KEYNUM $16 ('Y') to 'Z'\n170 REM\n180 REM *** DOING THE SAME FOR SHIFTED CHARACTERS\n190 REM *** IS LEFT AS AN EXERCISE TO THE READER\n</code></pre>"},{"location":"X16%20Reference%20-%2003%20-%20Editor/#custom-basin-petscii-code-override-handler","title":"Custom BASIN PETSCII code override handler","text":"<p>Note: This is a new feature in R44</p> <p>Some use cases of the BASIN (CHRIN) API call may benefit from being able to modify its behavior, such as intercepting or redirecting certain PETSCII codes.  The Machine Language Monitor uses this mechanism to implement custom behavior for F-keys and for loading additional disassembly or memory display when scrolling the screen.</p> <p>To set up a custom handler, one must configure it before each call to BASIN.</p> <p>The key handler vector is in RAM bank 0 at addresses $ac03-$ac05.  The first two bytes are the call address, and the next byte is the RAM or ROM bank.  If your callback routine is in low ram, specifying the bank in $ac05 is not necessary.</p> <p>The editor will call your callback for every keystroke received and pass the PETSCII code in the A register with carry set.  If your handler does not want to override, simply return with carry set.</p> <p>If you do wish to override, return with carry clear.  The editor will then unblink the cursor and call your callback a second time with carry clear for the same PETSCII code.  This is your opportunity to override. Before returning, you are free to update the screen or perform other KERNAL API calls (with the exception of BASIN). At the end of your routine, set <code>A</code> to the PETSCII code you wish the editor to process. If you wish to suppress the input keystroke, set <code>A</code> to <code>0</code>.</p> <pre><code>ram_bank = $00\nedkeyvec = $ac03\nedkeybk  = $ac05\n\nBASIN    = $ffcf\nBSOUT    = $ffd2\n\n.segment \"ONCE\"\n.segment \"STARTUP\"\n    jmp start\n.segment \"CODE\"\n\nkeyhandler:\n    bcs @check\n    cmp #$54 ; 'T'\n    bne :+\n    lda #$57 ; 'W'\n    rts\n:   lda #$54 ; 'T'\n    rts\n@check:\n    cmp #$54 ; 'T'\n    beq @will_override\n    cmp #$57 ; 'W'\n    beq @will_override\n    sec\n    rts\n@will_override:\n    clc\n    rts\n\nenable_basin_callback:\n    lda ram_bank\n    pha\n    stz ram_bank ; RAM bank 0 contains the handler vector\n    php\n    sei\n    lda #&lt;keyhandler\n    sta edkeyvec\n    lda #&gt;keyhandler\n    sta edkeyvec+1\n    ; setting the bank is optional and unnecessary\n    ; if the handler is in low RAM.\n    ; lda #0\n    ; sta edkeybk\n    plp\n    pla\n    sta ram_bank\n    rts\n\nstart:\n    jsr enable_basin_callback\n    ; T and W are swapped\n@1: jsr BASIN\n    cmp #13\n    bne @1\n    jsr BSOUT\n    ; normal BASIN\n@2: jsr BASIN\n    cmp #13\n    bne @2\n\n    rts\n</code></pre>"},{"location":"X16%20Reference%20-%2003%20-%20Editor/#custom-keyboard-keynum-code-handler","title":"Custom Keyboard Keynum Code Handler","text":"<p>Note: This is new behavior for R43, differing from previous releases.</p> <p>If you need more control over the translation of keynum codes into PETSCII/ISO codes, or if you need to intercept any key down or up event, you can hook the custom scancode handler vector at $032E/$032F.</p> <p>On all key down and key up events, the keyboard driver calls this vector with</p> <ul> <li>.A: keycode, where bit 7 (most-significant) is clear on key down, and set on key up.</li> </ul> <p>The keynum codes are enumerated here, and their names, similar to that of PS/2 codes, are based on their function in the US layout.</p> <p>The handler needs to return a key event the same way in .A</p> <ul> <li>To remove a keypress so that it is not added to the keyboard queue, return .A = 0.</li> <li>To manually add a key to the keyboard queue, use the <code>kbdbuf_put</code> KERNAL API.</li> </ul> <p>You can even write a completely custom keyboard translation layer:</p> <ul> <li>Place the code at $A000-$A58F in RAM bank 0. This is safe, since the tables won't be used in this case, and the active RAM bank will be set to 0 before entry to the handler.</li> <li>Fill the locale at $A590.</li> <li>For every keynum that should produce a PETSCII/ISO code, use <code>kbdbuf_put</code> to store it in the keyboard buffer.</li> <li>Always set .A = 0 before return from the custom handler.</li> </ul> <pre><code>;EXAMPLE: A custom handler that prints \"A\" on Alt key down\n\nsetup:\n    sei\n    lda #&lt;keyhandler\n    sta $032e\n    lda #&gt;keyhandler\n    sta $032f\n    cli\n    rts\n\nkeyhandler:\n    pha\n\n    and #$ff    ;ensure A sets flags\n    bmi exit    ;A &amp; 0x80 is key up\n\n    cmp #$3c    ;Left Alt keynum\n    bne exit\n\n    lda #'a'\n    jsr $ffd2\n\nexit:\n    pla\n    rts\n</code></pre>"},{"location":"X16%20Reference%20-%2003%20-%20Editor/#function-key-shortcuts","title":"Function Key Shortcuts","text":"<p>The following Function key macros are pre-defined for your convenience. These shortcuts only work in the screen editor. When a program is running, the F-keys generate the corresponding PETSCII character code.</p> Key Function Comment F1 <code>LIST:</code> Lists the current program F2 <code>SAVE\"@:</code> Press F2 and then type a filename to save your program. The <code>@:</code> instructs DOS to allow overwrite. F3 <code>LOAD \"</code> Load a file directly, or cursor up over a file listing and press F3 to load a program. F4 40/80 Toggles between 40 and 80 column screen modes, clearing the screen. Pressing return is required to prevent accidental mode switches. F5 <code>RUN:</code> Run the current program. F6 <code>MONITOR</code> Opens the Supermon machine language monitor. F7 <code>DOS\"$&lt;cr&gt;</code> Displays a directory listing. F8 <code>DOS\"</code> Issue DOS commands. F9 - Not defined.  Formerly cycled through keyboard layouts. Instead, use the <code>MENU</code> command to enter the X16 Control Panel, select one, and optionally save the layout as a boot preference. F10 - Not defined F11 - Not defined F12 debug debug features in emulators"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/","title":"4: BASIC Programming","text":""},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#table-of-basic-statements-and-functions","title":"Table of BASIC statements and functions","text":"Keyword Type Summary Origin <code>ABS</code> function Returns absolute value of a number C64 <code>AND</code> operator Returns boolean \"AND\" or bitwise intersection C64 <code>ASC</code> function Returns numeric PETSCII value from string C64 <code>ATN</code> function Returns arctangent of a number C64 <code>BANK</code> command Sets the RAM and ROM banks to use for PEEK, POKE, and SYS C128 <code>BIN$</code> function Converts numeric to a binary string X16 <code>BINPUT#</code> command Reads a fixed-length block of data from an open file X16 <code>BLOAD</code> command Loads a headerless binary file from disk to a memory address X16 <code>BOOT</code> command Loads and runs <code>AUTOBOOT.X16</code> X16 <code>BSAVE</code> command Saves a headerless copy of a range of memory to a file X16 <code>BVERIFY</code> command Verifies that a file on disk matches RAM contents X16 <code>BVLOAD</code> command Loads a headerless binary file from disk to VRAM X16 <code>CHAR</code> command Draws a text string in graphics mode X16 <code>CHR$</code> function Returns PETSCII character from numeric value C64 <code>CLOSE</code> command Closes a logical file number C64 <code>CLR</code> command Clears BASIC variable state C64 <code>CLS</code> command Clears the screen X16 <code>CMD</code> command Redirects output to non-screen device C64 <code>CONT</code> command Resumes execution of a BASIC program C64 <code>COLOR</code> command Sets text fg and bg color X16 <code>COS</code> function Returns cosine of an angle in radians C64 <code>DA$</code> variable Returns the date in YYYYMMDD format from the system clock X16 <code>DATA</code> command Declares one or more constants C64 <code>DEF</code> command Defines a function for use later in BASIC C64 <code>DIM</code> command Allocates storage for an array C64 <code>DOS</code> command Disk and SD card directory operations X16 <code>EDIT</code> command Open the built-in text editor X16 <code>END</code> command Terminate program execution and return to <code>READY.</code> C64 <code>EXEC</code> command Play back a script from RAM into the BASIC editor X16 <code>EXP</code> function Returns the inverse natural log of a number C64 <code>FMCHORD</code> command Start or stop simultaneous notes on YM2151 X16 <code>FMDRUM</code> command Plays a drum sound on YM2151 X16 <code>FMFREQ</code> command Plays a frequency in Hz on YM2151 X16 <code>FMINIT</code> command Stops sound and reinitializes YM2151 X16 <code>FMINST</code> command Loads a patch preset into a YM2151 channel X16 <code>FMNOTE</code> command Plays a musical note on YM2151 X16 <code>FMPAN</code> command Sets stereo panning on YM2151 X16 <code>FMPLAY</code> command Plays a series of notes on YM2151 X16 <code>FMPOKE</code> command Writes a value into a YM2151 register X16 <code>FMVIB</code> command Controls vibrato and tremolo on YM2151 X16 <code>FMVOL</code> command Sets channel volume on YM2151 X16 <code>FN</code> function Calls a previously defined function C64 <code>FOR</code> command Declares the start of a loop construct C64 <code>FRAME</code> command Draws an unfilled rectangle in graphics mode X16 <code>FRE</code> function Returns the number of unused BASIC bytes free C64 <code>GET</code> command Polls the keyboard cache for a single keystroke C64 <code>GET#</code> command Polls an open logical file for a single character C64 <code>GOSUB</code> command Jumps to a BASIC subroutine C64 <code>GOTO</code> command Branches immediately to a line number C64 <code>HELP</code> command Displays a brief summary of online help resources X16 <code>HEX$</code> function Converts numeric to a hexadecimal string X16 <code>I2CPEEK</code> function Reads a byte from a device on the I\u00b2C bus X16 <code>I2CPOKE</code> command Writes a byte to a device on the I\u00b2C bus X16 <code>IF</code> command Tests a boolean condition and branches on result C64 <code>INPUT</code> command Reads a line or values from the keyboard C64 <code>INPUT#</code> command Reads lines or values from a logical file C64 <code>INT</code> function Discards the fractional part of a number C64 <code>JOY</code> function Reads gamepad button state X16 <code>KEYMAP</code> command Changes the keyboard layout X16 <code>LEFT$</code> function Returns a substring starting from the beginning of a string C64 <code>LEN</code> function Returns the length of a string C64 <code>LET</code> command Explicitly declares a variable C64 <code>LINE</code> command Draws a line in graphics mode X16 <code>LINPUT</code> command Reads a line from the keyboard X16 <code>LINPUT#</code> command Reads a line or other delimited data from an open file X16 <code>LIST</code> command Outputs the program listing to the screen C64 <code>LOAD</code> command Loads a program from disk into memory C64 <code>LOCATE</code> command Moves the text cursor to new location X16 <code>LOG</code> function Returns the natural logarithm of a number C64 <code>MENU</code> command Invokes the Commander X16 utility menu X16 <code>MID$</code> function Returns a substring from the middle of a string C64 <code>MON</code> command Enters the machine language monitor X16 <code>MOUSE</code> command Hides or shows mouse pointer X16 <code>MOVSPR</code> command Set the X/Y position of a sprite X16 <code>MX/MY/MB</code> variable Reads the mouse position and button state X16 <code>MWHEEL</code> variable Reads the mouse wheel movement X16 <code>NEW</code> command Resets the state of BASIC and clears program memory C64 <code>NEXT</code> command Declares the end of a loop construct C64 <code>NOT</code> operator Bitwise or boolean inverse C64 <code>OLD</code> command Undoes a NEW command or warm reset X16 <code>ON</code> command A GOTO/GOSUB table based on a variable value C64 <code>OPEN</code> command Opens a logical file to disk or other device C64 <code>OR</code> operator Bitwise or boolean \"OR\" C64 <code>PEEK</code> function Returns a value from a memory address C64 <code>\u03c0</code> function Returns the constant for the value of pi C64 <code>POINTER</code> function Returns the address of a BASIC variable C128 <code>POKE</code> command Assigns a value to a memory address C64 <code>POS</code> function Returns the column position of the text cursor C64 <code>POWEROFF</code> command Immediately powers down the Commander X16 X16 <code>PRINT</code> command Prints data to the screen or other output C64 <code>PRINT#</code> command Prints data to an open logical file C64 <code>PSET</code> command Changes a pixel's color in graphics mode X16 <code>PSGCHORD</code> command Starts or stops simultaneous notes on VERA PSG X16 <code>PSGFREQ</code> command Plays a frequency in Hz on VERA PSG X16 <code>PSGINIT</code> command Stops sound and reinitializes VERA PSG X16 <code>PSGNOTE</code> command Plays a musical note on VERA PSG X16 <code>PSGPAN</code> command Sets stereo panning on VERA PSG X16 <code>PSGPLAY</code> command Plays a series of notes on VERA PSG X16 <code>PSGVOL</code> command Sets voice volume on VERA PSG X16 <code>PSGWAV</code> command Sets waveform on VERA PSG X16 <code>READ</code> command Assigns the next <code>DATA</code> constant to one or more variables C64 <code>REBOOT</code> command Performs a warm reboot of the system X16 <code>RECT</code> command Draws a filled rectangle in graphics mode X16 <code>REM</code> command Declares a comment C64 <code>REN</code> command Renumbers a BASIC program X16 <code>RESET</code> command Performs a hard reset of the system X16 <code>RESTORE</code> command Resets the <code>READ</code> pointer to a <code>DATA</code> constant C64 <code>RETURN</code> command Returns from a subroutine to the statement following a GOSUB C64 <code>RIGHT$</code> function Returns a substring from the end of a string C64 <code>RND</code> function Returns a floating point number 0 &lt;= n &lt; 1 C64 <code>RPT$</code> function Returns a string of repeated characters X16 <code>RUN</code> command Clears the variable state and starts a BASIC program C64 <code>SAVE</code> command Saves a BASIC program from memory to disk C64 <code>SCREEN</code> command Selects a text or graphics mode X16 <code>SGN</code> function Returns the sign of a numeric value C64 <code>SIN</code> function Returns the sine of an angle in radians C64 <code>SLEEP</code> command Introduces a delay in program execution X16 <code>SPC</code> function Returns a string with a set number of spaces C64 <code>SPRITE</code> command Sets attributes for a sprite including visibility X16 <code>SPRMEM</code> command Set the VRAM address for a sprite's visual data X16 <code>SQR</code> function Returns the square root of a numeric value C64 <code>ST</code> variable Returns the status of certain DOS/peripheral operations C64 <code>STEP</code> keyword Used in a <code>FOR</code> declaration to declare the iterator step C64 <code>STOP</code> command Breaks out of a BASIC program C64 <code>STR$</code> function Converts a numeric value to a string C64 <code>STRPTR</code> function Returns the address of a BASIC string X16 <code>SYS</code> command Transfers control to machine language at a memory address C64 <code>TAB</code> function Returns a string with spaces used for column alignment C64 <code>TAN</code> function Return the tangent for an angle in radians C64 <code>TATTR</code> function Returns a tile attribute from the tile/text layer X16 <code>TDATA</code> function Returns a tile from the tile/text layer X16 <code>THEN</code> keyword Control structure as part of an <code>IF</code> statement C64 <code>TI</code> variable Returns the jiffy timer value C64 <code>TI$</code> variable Returns the time HHMMSS from the system clock C64 <code>TILE</code> command Changes a tile or character on the tile/text layer X16 <code>TO</code> keyword Part of the <code>FOR</code> loop declaration syntax C64 <code>USR</code> function Call a user-defined function in machine language C64 <code>VAL</code> function Parse a string to return a numeric value C64 <code>VERIFY</code> command Verify that a BASIC program was written to disk correctly C64 <code>VPEEK</code> function Returns a value from VERA's VRAM X16 <code>VPOKE</code> command Sets a value in VERA's VRAM X16 <code>VLOAD</code> command Loads a file to VERA's VRAM X16 <code>WAIT</code> command Waits for a memory location to match a condition C64"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#commodore-64-compatibility","title":"Commodore 64 Compatibility","text":"<p>The Commander X16 BASIC interpreter is 100% backwards-compatible with the Commodore 64 one. This includes the following features:</p> <ul> <li>All statements and functions</li> <li>Strings, arrays, integers, floats</li> <li>Max. 80 character BASIC lines</li> <li>Printing control characters like cursor control and color codes, e.g.:</li> <li><code>CHR$(147)</code>: clear screen</li> <li><code>CHR$(5)</code>: white text</li> <li><code>CHR$(18)</code>: reverse</li> <li><code>CHR$(14)</code>: switch to upper/lowercase font</li> <li><code>CHR$(142)</code>: switch to uppercase/graphics font</li> <li>The BASIC vector table ($0300-$030B, $0311/$0312)</li> <li>SYS arguments in RAM</li> </ul> <p>Because of the differences in hardware, the following functions and statements are incompatible between C64 and X16 BASIC programs.</p> <ul> <li><code>POKE</code>: write to a memory address</li> <li><code>PEEK</code>: read from a memory address</li> <li><code>WAIT</code>: wait for memory contents</li> <li><code>SYS</code>: execute machine language code (when used with ROM code)</li> </ul> <p>The BASIC interpreter also currently shares all problems of the C64 version, like the slow garbage collector.</p>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#saving-files","title":"Saving Files","text":"<p>By default, you cannot automatically overwrite a file with SAVE, BSAVE, or OPEN. To overwrite a file, you must prefix the filename with <code>@:</code>, like this: <code>SAVE \"@:HELLO WORLD\"</code>. (<code>\"@0:filename\"</code> is also acceptable.)</p> <p>This follows the Commodore convention, which extended to all of their diskette drives and third party hard drives and flash drive readers.</p> <p>Always confirm you have successfully saved a file by checking the DOS status. When you use the SAVE command from Immediate (or Direct) mode, the system does this for you. In Program mode, you have to do it yourself.</p> <p>There are two ways to check the error channel from inside a program:</p> <ol> <li>You can use the DOS command and make the user perform actions necessary to recover from an error (such as re-saving the file with an @: prefix).</li> <li>You can read the error yourself, using the following BASIC code:</li> </ol> <pre><code>10 OPEN 15,8,15\n20 INPUT#15,A,B$\n30 PRINT A;B$\n40 CLOSE 15\n</code></pre> <p>Refer to Chapter 13 for more details on CMDR-DOS and the command channel.</p>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#new-statements-and-functions","title":"New Statements and Functions","text":"<p>There are several new statement and functions. Note that all BASIC keywords (such as <code>FOR</code>) get converted into tokens (such as <code>$81</code>), and the tokens for the new keywords have likely shifted from one ROM version to the next. Therefore, loading BASIC program saved from an old revision of BASIC may mix up keywords. As of ROM version R42, the keyword token positions should no longer shift and programs saved in R42 BASIC should be compatible with future versions.</p>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#asc","title":"ASC","text":"<p>TYPE: Integer Function FORMAT: ASC(&lt;string&gt;)</p> <p>Action: Returns an integer value representing the PETSCII code for the first character of <code>string</code>. If <code>string</code> is the empty string, <code>ASC()</code> returns 0.</p> <p>EXAMPLE of ASC Function:</p> <pre><code>?ASC(\"A\")\n 65\n\n?ASC(\"\")\n 0\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#bin","title":"BIN$","text":"<p>TYPE: String Function FORMAT: BIN$(n)</p> <p>Action: Return a string representing the binary value of n. If n &lt;= 255, 8 characters are returned and if 255 &lt; n &lt;= 65535, 16 characters are returned.</p> <p>EXAMPLE of BIN$ Function:</p> <pre><code>PRINT BIN$(200)   : REM PRINTS 11001000 AS BINARY REPRESENTATION OF 200\nPRINT BIN$(45231) : REM PRINTS 1011000010101111 TO REPRESENT 16 BITS\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#bank","title":"BANK","text":"<p>TYPE: Command FORMAT: BANK m[,n]</p> <p>Action: Set the active RAM (m) and ROM bank (n) for the purposes of <code>PEEK</code>, <code>POKE</code>, and <code>SYS</code>.  Specifying the ROM bank is optional. If it is not specified, its previous value is retained.</p> <p>EXAMPLE of BANK Statement:</p> <pre><code>BANK 1,10    : REM SETS THE RAM BANK TO 1 AND THE ROM BANK TO 10\n?PEEK($A000) : REM PRINTS OUT THE VALUE STORED IN $A000 IN RAM BANK 1\nSYS $C063    : REM CALLS ROUTINE AT $C09F IN ROM BANK 10 AUDIO (YM_INIT)\n</code></pre> <p>Note: In the above example, the <code>SYS $C063</code> in ROM bank 10 is a call to ym_init, which does the first half of what the BASIC command <code>FMINIT</code> does, without setting any default instruments. It is generally not recommended to call routines in ROM directly this way, and most BASIC programmers will never have a need to call <code>SYS</code> directly, but advanced users may find a good reason to do so.</p> <p>Note: BANK uses its own register to store the the command's desired bank numbers; this will not always be the same as the value stored in <code>$00</code> or <code>$01</code>. In fact, <code>$01</code> is always going to read <code>4</code> when PEEKing from BASIC. If you need to know the currently selected RAM and/or RAM banks, you should explicitly set them and use variables to track your selected bank number(s).</p> <p>Note: Memory address <code>$00</code>, which is the hardware RAM bank register, will usually report the bank set by the <code>BANK</code> command. The one exception is after a <code>BLOAD</code> or <code>BVERIFY</code> inside of a running BASIC program.  <code>BLOAD</code> and <code>BVERIFY</code> change the RAM bank (as if you called <code>BANK</code>) to the bank that <code>BLOAD</code> or <code>BVERIFY</code> stopped at.</p>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#binput","title":"BINPUT#","text":"<p>TYPE: Command FORMAT: BINPUT# &lt;n&gt;,&lt;var$&gt;,&lt;len&gt;</p> <p>Action: <code>BINPUT#</code> Reads a block of data from an open file and stores the data into a string variable. If there are fewer than <code>&lt;len&gt;</code> bytes available to be read from the file, fewer bytes will be stored.  If the end of the file is reached, <code>ST AND 64</code> will be true.</p> <p>EXAMPLE of BINPUT# Statement:</p> <pre><code>10 OPEN 8,8,8,\"FILE.BIN,S,R\"\n20 BINPUT#8,A$,10\n30 PRINT \"I GOT\";LEN(A$);\"BYTES\"\n40 IF ST&lt;&gt;0 THEN 20\n50 CLOSE 8\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#boot","title":"BOOT","text":"<p>TYPE: Command FORMAT: BOOT</p> <p>Action: Load and run a PRG file named <code>AUTOBOOT.X16</code> from device 8. If the file is not found, nothing is done and no error is printed.</p> <p>EXAMPLE of BOOT Statement:</p> <pre><code>BOOT\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#bload","title":"BLOAD","text":"<p>TYPE: Command FORMAT: BLOAD &lt;filename&gt;, &lt;device&gt;, &lt;bank&gt;, &lt;address&gt;</p> <p>Action: Loads a binary file directly into RAM</p> <p>Note: If the file is loaded to high RAM (starting in the range <code>$A000-$BFFF</code>), and the file is larger than what would fit in the current bank, the load will wrap around into subsequent banks.</p> <p>After a successful load, <code>$030D</code> and <code>$030E</code> will contain the address of the final byte loaded + 1.  If relevant, the value in memory location <code>$00</code> will point to the bank in which the next byte would have been loaded.</p> <p>EXAMPLES of BLOAD:</p> <pre><code>BLOAD \"MYFILE.BIN\",8,1,$A000:REM LOADS A FILE NAMED MYFILE.BIN FROM DEVICE 8 STARTING IN BANK 1 AT $A000.\nBLOAD \"WHO.PCX\",8,10,$B000:REM LOADS A FILE NAMED WHO.PCX INTO RAM STARTING IN BANK 10 AT $B000.\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#bsave","title":"BSAVE","text":"<p>TYPE: Command FORMAT: BSAVE &lt;filename&gt;, &lt;device&gt;, &lt;bank&gt;, &lt;start address&gt;, &lt;end address&gt;</p> <p>Action: Saves a region of memory to a binary file.</p> <p>Note: The save will stop one byte before <code>end address</code>.</p> <p>This command does not allow for automatic bank advancing, but you can achieve a similar result with successive BSAVE invocations to append additional memory locations to the same file.</p> <p>EXAMPLES of BSAVE:</p> <pre><code>BSAVE \"MYFILE.BIN\",8,1,$A000,$C000\n</code></pre> <p>The above example saves a region of memory from $A000 in bank 1 through and including $BFFF, stopping before $C000.</p> <pre><code>BSAVE \"MYFILE.BIN,S,A\",8,2,$A000,$B000\n</code></pre> <p>The above example appends a region of memory from $A000 through and including $AFFF, stopping before $B000.  Running both of the above examples in succession will result in a file MYFILE.BIN 12KiB in size.</p>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#bvload","title":"BVLOAD","text":"<p>TYPE: Command FORMAT: BVLOAD &lt;filename&gt;, &lt;device&gt;, &lt;VERA_high_address&gt;, &lt;VERA_low_address&gt;</p> <p>Action: Loads a binary file directly into VERA RAM.</p> <p>EXAMPLES of BVLOAD:</p> <pre><code>BVLOAD \"MYFILE.BIN\", 8, 0, $4000  :REM LOADS MYFILE.BIN FROM DEVICE 8 TO VRAM $4000.\nBVLOAD \"MYFONT.BIN\", 8, 1, $F000  :REM LOAD A FONT INTO THE DEFAULT FONT LOCATION ($1F000).\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#char","title":"CHAR","text":"<p>TYPE: Command FORMAT: CHAR &lt;x&gt;,&lt;y&gt;,&lt;color&gt;,&lt;string&gt;</p> <p>Action: This command draws a text string on the graphics screen in a given color.</p> <p>The string can contain printable ASCII characters (<code>CHR$($20)</code> to <code>CHR$($7E)</code>), as well most PETSCII control codes.</p> <p>EXAMPLE of CHAR Statement:</p> <pre><code>10 SCREEN $80\n20 A$=\"The quick brown fox jumps over the lazy dog.\"\n24 CHAR 0,6,0,A$\n30 CHAR 0,6+12,0,CHR$($04)+A$   :REM UNDERLINE\n40 CHAR 0,6+12*2,0,CHR$($06)+A$ :REM BOLD\n50 CHAR 0,6+12*3,0,CHR$($0B)+A$ :REM ITALICS\n60 CHAR 0,6+12*4,0,CHR$($0C)+A$ :REM OUTLINE\n70 CHAR 0,6+12*5,0,CHR$($12)+A$ :REM REVERSE\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#close","title":"CLOSE","text":"<p>TYPE: Command FORMAT: CLOSE &lt;file number&gt;</p> <p>Action: Closes any files used by <code>OPEN</code> statements.  The <code>CLOSE</code> statement takes a single argument that is the file number to be closed.</p> <p>EXAMPLE of CLOSE Statement:</p> <pre><code>CLOSE 0   : REM CLOSE FILE OPENED AS 0\nCLOSE 4   : REM CLOSE FILE OPENED AS 4\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#cls","title":"CLS","text":"<p>TYPE: Command FORMAT: CLS</p> <p>Action: Clears the screen. Same effect as <code>?CHR$(147);</code>.</p> <p>EXAMPLE of CLS Statement:</p> <pre><code>CLS\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#color","title":"COLOR","text":"<p>TYPE: Command FORMAT: COLOR &lt;fgcol&gt;[,&lt;bgcol&gt;]</p> <p>Action: This command works sets the text mode foreground color, and optionally the background color.</p> <p>EXAMPLES of COLOR Statement:</p> <pre><code>COLOR 2   : REM SET FG COLOR TO RED, KEEP BG COLOR\nCOLOR 2,0 : REM SET FG COLOR TO RED, BG COLOR TO BLACK\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#dos","title":"DOS","text":"<p>TYPE: Command FORMAT: DOS &lt;string&gt;</p> <p>Action: This command works with the command/status channel or the directory of a Commodore DOS device and has different functionality depending on the type of argument.</p> <ul> <li>Without an argument, <code>DOS</code> prints the status string of the current device.</li> <li>With a string argument of <code>\"8\"</code> or <code>\"9\"</code>, it switches the current device to the given number.</li> <li>With an argument starting with <code>\"$\"</code>, it shows the directory of the device.</li> <li>Any other argument will be sent as a DOS command.</li> </ul> <p>EXAMPLES of DOS Statement:</p> <pre><code>DOS\"$\"          : REM SHOWS DIRECTORY\nDOS\"S:BAD_FILE\" : REM DELETES \"BAD_FILE\"\nDOS             : REM PRINTS DOS STATUS, E.G. \"01,FILES SCRATCHED,01,00\"\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#edit","title":"EDIT","text":"<p>TYPE: Command FORMAT: EDIT [&lt;filename&gt;]</p> <p>Action: Opens the built-in text editor, X16-Edit, a modeless editor with features similar to GNU Nano.</p> <ul> <li>Without an argument, the editor begins with an empty file.</li> <li>With a string argument, it attempts to load a file before displaying it.</li> </ul> <p>The EDIT command loads the editor in the screen mode and character set that was active at the time the command was run.</p> <p>EXAMPLE of EDIT Statement:</p> <pre><code>EDIT \"README.TXT\"\n</code></pre> <p>A more elaborate X16-Edit manual can be found here</p>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#exec","title":"EXEC","text":"<p>TYPE: Command FORMAT: EXEC &lt;memory address&gt;[,&lt;ram bank&gt;]</p> <p>Action: Plays back a null-terminated script from MEMORY into the BASIC editor. Among other uses, this can be used to \"type\" in a program from a plain text file.</p> <ul> <li>If the <code>ram bank</code> argument is omitted and the address is in the range $A000-$BFFF, the RAM bank selected by the <code>BANK</code> command is used.</li> <li>The input can span multiple RAM banks. The input will stop once it reaches a null byte ($00) or if a BASIC error occurs.</li> <li>The redirected input only applies to BASIC immediate mode. While programs are running, the EXEC handling is suspended.</li> </ul> <p>EXAMPLE of EXEC Statement:</p> <pre><code>BLOAD \"MYPROGRAM.BAS\",8,1,$A000 : REM \"BANK PEEK(0)\" NO LONGER NEEDED\nPOKE PEEK($30D)+(PEEK($30E)*256),0 : REM NULL TERMINATE IN END BANK\nEXEC $A000,1\n</code></pre> <p>This program will load a plain ASCII or PETSCII FILE.BAS from disk and tokenize it for you:</p> <pre><code>10 BLOAD \"FILE.BAS\", 8, 1, $A000\n20 POKE PEEK(781) + 256 * PEEK(782), 0\n30 EXEC $A000, 1\n40 NEW\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#fmchord","title":"FMCHORD","text":"<p>TYPE: Command FORMAT: FMCHORD &lt;first channel&gt;,&lt;string&gt;</p> <p>Action: This command uses the same syntax as <code>FMPLAY</code>, but instead of playing a series of notes, it will start all of the notes in the string simultaneously on one or more channels. The first parameter to <code>FMCHORD</code> is the first channel to use, and will be used for the first note in the string, and subsequent notes in the string will be started on subsequent channels, with the channel after 7 being channel 0.</p> <p>All macros are supported, even the ones that only affect the behavior of <code>PSGPLAY</code> and <code>FMPLAY</code>.</p> <p>The full set of macros is documented here.</p> <p>EXAMPLE of FMCHORD statement:</p> <pre><code>10 FMINIT\n20 FMVIB 195,10\n30 FMINST 1,16:FMINST 2,16:FMINST 3,16 : REM ORGAN\n40 FMVOL 1,50:FMVOL 2,50:FMVOL 3,50 : REM MAKE ORGAN QUIETER\n50 FMINST 0,11 : REM VIBRAPHONE\n60 FMCHORD 1,\"O3CG&gt;E T90\" : REM START SOME ORGAN CHORDS (CHANNELS 1,2,3)\n70 FMPLAY 0,\"O4G4.A8G4E2.\" : REM PLAY MELODY (CHANNEL 0)\n80 FMPLAY 0,\"O4G4.A8G4E2.\"\n90 FMCHORD 1,\"O2G&gt;DB\" : REM SWITCH ORGAN CHORDS (CHANNELS 1,2,3)\n100 FMPLAY 0,\"O5D2D4&lt;B2\" : REM PLAY MORE MELODY\n110 FMCHORD 1,\"O2F\" : REM SWITCH ONE OF THE ORGAN CHORD NOTES\n120 FMPLAY 0,\"R4\" : REM PAUSE FOR THE LENGTH OF ONE QUARTER NOTE\n130 FMCHORD 1,\"O3CEG\" : REM SWITCH ALL THREE CHORD NOTES\n140 FMPLAY 0,\"O5C2C4&lt;G2.\" : REM PLAY THE REST OF THE MELODY\n150 FMCHORD 1,\"RRR\" : REM RELEASE THE CHANNELS THAT ARE PLAYING THE CHORD\n</code></pre> <p>This will play the first few lines of Silent Night with a vibraphone lead and organ accompaniment.</p>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#fmdrum","title":"FMDRUM","text":"<p>TYPE: Command FORMAT: FMDRUM &lt;channel&gt;,&lt;drum number&gt;</p> <p>Action: Loads a drum preset onto the YM2151 and triggers it. Valid range is from 25 to 87, corresponding to the General MIDI percussion note values. FMDRUM will load a patch preset corresponding to the selected drum into the channel. If you then try to play notes on that same channel without loading an instrument patch, it will use the drum patch that was loaded for the drum sound instead, which may not sound particularly musical.</p>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#fmfreq","title":"FMFREQ","text":"<p>TYPE: Command FORMAT: FMFREQ &lt;channel&gt;,&lt;frequency&gt;</p> <p>Action: Play a note by frequency on the YM2151. The accepted range is in Hz from 17 to 4434. FMFREQ also accepts a frequency of 0 to release the note.</p> <p>EXAMPLE of FMFREQ statement:</p> <pre><code>0 FMINST 0,160 : REM LOAD PURE SINE PATCH\n10 FMINST 1,160 : REM HERE TOO\n20 FMFREQ 0,350 : REM PLAY A SINE WAVE AT 350 HZ\n30 FMFREQ 1,440 : REM PLAY A SINE WAVE AT 440 HZ ON ANOTHER CHANNEL\n40 FOR X=1 TO 10000 : NEXT X : REM DELAY A BIT\n50 FMFREQ 0,0 : FMFREQ 1,0 : REM RELEASE BOTH CHANNELS\n</code></pre> <p>The above BASIC program plays a sound similar to a North American dial tone for a few seconds.</p>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#fminit","title":"FMINIT","text":"<p>TYPE: Command FORMAT: FMINIT</p> <p>Action: Initialize YM2151, silence all channels, and load a set of default patches into all 8 channels.</p>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#fminst","title":"FMINST","text":"<p>TYPE: Command FORMAT: FMINST &lt;channel&gt;,&lt;patch&gt;</p> <p>Load an instrument onto the YM2151 in the form of a patch preset into a channel. Valid channels range from 0 to 7. Valid patches range from 0 to 162.</p>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#fmnote","title":"FMNOTE","text":"<p>TYPE: Command FORMAT: FMNOTE &lt;channel&gt;,&lt;note&gt;</p> <p>Action: Play a note on the YM2151. The note value is constructed as follows. Using hexadecimal notation, the first nybble is the octave, 0-7, and the second nybble is the note within the octave as follows:</p> <code>$x0</code> <code>$x1</code> <code>$x2</code> <code>$x3</code> <code>$x4</code> <code>$x5</code> <code>$x6</code> <code>$x7</code> <code>$x8</code> <code>$x9</code> <code>$xA</code> <code>$xB</code> <code>$xC</code> <code>$xD-$xF</code> Release C C\u266f/D\u266d D D\u266f/E\u266d E F F\u266f/G\u266d G G\u266f/A\u266d A A\u266f/B\u266d B no-op <p>Notes can also be represented by negative numbers to skip retriggering, and will thus snap to another note without restarting the playback of the note.</p> <p>EXAMPLE of FMNOTE statement:</p> <pre><code>0 FMINST 1,64 : REM LOAD SOPRANO SAX\n10 FMNOTE 1,$4A : REM PLAYS CONCERT A\n20 FOR X=1 TO 5000 : NEXT X : REM DELAYS FOR A BIT\n30 FMNOTE 1,0 : REM RELEASES THE NOTE\n40 FOR X=1 TO 1000 : NEXT X : REM DELAYS FOR A BIT\n50 FMNOTE 1,$3A : REM PLAYS A IN THE 3RD OCTAVE\n60 FOR X=1 TO 2500 : NEXT X : REM SHORT DELAY\n70 FMNOTE 1,-$3B : REM UP A HALF STEP TO A# WITHOUT RETRIGGERING\n80 FOR X=1 TO 2500 : NEXT X : REM SHORT DELAY\n90 FMNOTE 1,0 : REM RELEASES THE NOTE\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#fmpan","title":"FMPAN","text":"<p>TYPE: Command FORMAT: FMPAN &lt;channel&gt;,&lt;panning&gt;</p> <p>Action: Sets the simple stereo panning on a YM2151 channel. Valid values are as follows:</p> <ul> <li>1 = left</li> <li>2 = right</li> <li>3 = both</li> </ul>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#fmplay","title":"FMPLAY","text":"<p>TYPE: Command FORMAT: FMPLAY &lt;channel&gt;,&lt;string&gt;</p> <p>Action: This command is very similar to <code>PLAY</code> on other BASICs such as GWBASIC. It takes a string of notes, rests, tempo changes, note lengths, and other macros, and plays all of the notes synchronously.  That is, the FMPLAY command will not return control until all of the notes and rests in the string have been fully played.</p> <p>The full set of macros is documented here.</p> <p>EXAMPLE of FMPLAY statement:</p> <pre><code>10 FMINIT : REM INITIALIZE AND LOAD DEFAULT PATCHES, WILL USE E.PIANO\n20 FMPLAY 1,\"T90 O4 L4\" : REM TEMPO 90 BPM, OCTAVE 4, NOTE LENGTH 4 (QUARTER)\n30 FMPLAY 1,\"CDECCDECEFGREFGR\" : REM FIRST TWO LINES OF TUNE\n40 FMPLAY 1,\"G8A8G8F8EC G8A8G8F8EC\" : REM THIRD LINE\n50 FMPLAY 1,\"C&lt;G&gt;CRC&lt;G&gt;CR\" : REM FOURTH LINE\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#fmpoke","title":"FMPOKE","text":"<p>TYPE: Command FORMAT: FMPOKE &lt;register&gt;,&lt;value&gt;</p> <p>Action: This command uses the AUDIO API to write a value to one of the the YM2151's registers at a low level.</p> <p>EXAMPLE of FMPOKE statement:</p> <pre><code>10 FMINIT\n20 FMPOKE $28,$4A : REM SET KC TO A4 (A-440) ON CHANNEL 0\n30 FMPOKE $08,$00 : REM RELEASE CHANNEL 0\n40 FMPOKE $08,$78 : REM START NOTE PLAYBACK ON CHANNEL 0 W/ ALL OPERATORS\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#fmvib","title":"FMVIB","text":"<p>TYPE: Command FORMAT: FMVIB &lt;speed&gt;,&lt;depth&gt;</p> <p>Action: This command sets the LFO speed and the phase and amplitude modulation depth values on the YM2151. The speed value ranges from 0 to 255, and corresponds to an LFO frequency from 0.008 Hz to 32.6 Hz.  The depth value ranges from 0-127 and affects both AMD and PMD.</p> <p>Only some patch presets (instruments) are sensitive to the LFO. Those are marked in this table with the \u2020 symbol.  The LFO affects all channels equally, and it depends on the instrument as to whether it is affected.</p> <p>Good values for most instruments are speed somewhere between 190-220. A good light vibrato for most wind instruments would have a depth of 10-15, while tremolo instruments like the Vibraphone or Tremolo Strings are most realistic around 20-30.</p> <p>EXAMPLE of FMVIB statement:</p> <pre><code>10 FMVIB 200,30\n20 FMINST 0,11 : REM VIBRAPHONE\n30 FMPLAY 0,\"T60 O4 CDEFGAB&gt;C\"\n40 FMVIB 0,0\n50 FMPLAY 0,\"C&lt;BAGFEDC\"\n</code></pre> <p>The above BASIC program plays a C major scale with a vibraphone patch, first with a vibrato/tremolo effect, and then plays the scale in reverse with the vibrato turned off.</p>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#fmvol","title":"FMVOL","text":"<p>TYPE: Command FORMAT: FMVOL &lt;channel&gt;,&lt;volume&gt;</p> <p>Action: This command sets the channel's volume. The volume remains at the requested level until another <code>FMVOL</code> command for that channel or <code>FMINIT</code> is called.  Valid range is from 0 (completely silent) to 63 (full volume)</p>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#frame","title":"FRAME","text":"<p>TYPE: Command FORMAT: FRAME &lt;x1&gt;,&lt;y1&gt;,&lt;x2&gt;,&lt;y2&gt;,&lt;color&gt;</p> <p>Action: This command draws a rectangle frame on the graphics screen in a given color.</p> <p>EXAMPLE of FRAME Statement:</p> <pre><code>10 SCREEN$80\n20 FORI=1TO20:FRAMERND(1)*320,RND(1)*200,RND(1)*320,RND(1)*200,RND(1)*128:NEXT\n30 GOTO20\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#hex","title":"HEX$","text":"<p>TYPE: String Function FORMAT: HEX$(n)</p> <p>Action: Return a string representing the hexadecimal value of n. If n &lt;= 255, 2 characters are returned and if 255 &lt; n &lt;= 65535, 4 characters are returned.</p> <p>EXAMPLE of HEX$ Function:</p> <pre><code>PRINT HEX$(200)   : REM PRINTS C8 AS HEXADECIMAL REPRESENTATION OF 200\nPRINT HEX$(45231) : REM PRINTS B0AF TO REPRESENT 16 BIT VALUE\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#help","title":"HELP","text":"<p>TYPE: Command FORMAT: HELP</p> <p>Action: The <code>HELP</code> command displays a brief summary of the ROM build, and points users to this guide at its home on GitHub, and to the community forums website.</p>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#i2cpeek","title":"I2CPEEK","text":"<p>TYPE: Integer Function FORMAT: I2CPEEK(&lt;device&gt;,&lt;register&gt;)</p> <p>Action: Returns the value from a register on an I\u00b2C device.</p> <p>EXAMPLE of I2CPEEK Function:</p> <pre><code>PRINT HEX$(I2CPEEK($6F,0) AND $7F)\n</code></pre> <p>This command reports the seconds counter from the RTC by converting its internal BCD representation to a string.</p>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#i2cpoke","title":"I2CPOKE","text":"<p>TYPE: Command FORMAT: I2CPOKE &lt;device&gt;,&lt;register&gt;,&lt;value&gt;</p> <p>Action: Sets the value to a register on an I\u00b2C device.</p> <p>EXAMPLE of I2CPOKE Function:</p> <pre><code>I2CPOKE $6F,$40,$80\n</code></pre> <p>This command sets a byte in NVRAM on the RTC to the value <code>$80</code></p>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#joy","title":"JOY","text":"<p>TYPE: Integer Function FORMAT: JOY(n)</p> <p>Action: Return the state of a joystick.</p> <p><code>JOY(1)</code> through <code>JOY(4)</code> return the state of SNES controllers connected to the system, and <code>JOY(0)</code> returns the state of the \"keyboard joystick\", a set of keyboard keys that map to the SNES controller layout. See <code>joystick_get</code> for details.</p> <p>If no controller is connected to the SNES port (or no keyboard is connected), the function returns -1. Otherwise, the result is a bit field, with pressed buttons <code>OR</code>ed together:</p> Value Button $800 A $400 X $200 L $100 R $080 B $040 Y $020 SELECT $010 START $008 UP $004 DOWN $002 LEFT $001 RIGHT <p>Note that this bitfield is different from the <code>joystick_get</code> KERNEL API one. Also note that the keyboard joystick will allow LEFT and RIGHT as well as UP and DOWN to be pressed at the same time, while controllers usually prevent this mechanically.</p> <p>EXAMPLE of JOY Function:</p> <pre><code>10 REM DETECT CONTROLLER, FALL BACK TO KEYBOARD\n20 J = 0: FOR I=1 TO 4: IF JOY(I) &gt;= 0 THEN J = I: GOTO40\n30 NEXT\n40 :\n50 V=JOY(J)\n60 PRINT CHR$(147);V;\": \";\n70 IF V = -1 THEN PRINT\"DISCONNECTED \": GOTO50\n80 IF V AND 8 THEN PRINT\"UP \";\n90 IF V AND 4 THEN PRINT\"DOWN \";\n100 IF V AND 2 THEN PRINT\"LEFT \";\n110 IF V AND 1 THEN PRINT\"RIGHT \";\n120 GOTO50\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#keymap","title":"KEYMAP","text":"<p>TYPE: Command FORMAT: KEYMAP &lt;string&gt;</p> <p>Action: This command sets the current keyboard layout. It can be put into an AUTOBOOT file to always set the keyboard layout on boot.</p> <p>EXAMPLE of KEYMAP Statement:</p> <pre><code>10 KEYMAP\"SV-SE\"    :REM SMALL BASIC PROGRAM TO SET LAYOUT TO SWEDISH/SWEDEN\nSAVE\"AUTOBOOT.X16\"  :REM SAVE AS AUTOBOOT FILE\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#line","title":"LINE","text":"<p>TYPE: Command FORMAT: LINE &lt;x1&gt;,&lt;y1&gt;,&lt;x2&gt;,&lt;y2&gt;,&lt;color&gt;</p> <p>Action: This command draws a line on the graphics screen in a given color.</p> <p>EXAMPLE of LINE Statement:</p> <pre><code>10 SCREEN128\n20 FORA=0TO2*\u03c0STEP2*\u03c0/200\n30 :  LINE100,100,100+SIN(A)*100,100+COS(A)*100\n40 NEXT\n</code></pre> <p>If you're pasting this example into the Commander X16 emulator, use this code block instead so that the \u03c0 symbol is properly received.</p> <pre><code>10 SCREEN128\n20 FORA=0TO2*\\XFFSTEP2*\\XFF/200\n30 :  LINE100,100,100+SIN(A)*100,100+COS(A)*100\n40 NEXT\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#linput","title":"LINPUT","text":"<p>TYPE: Command **FORMAT: LINPUT &lt;var$&gt;</p> <p>Action: <code>LINPUT</code> Reads a line of data from the keyboard and stores the data into a string variable. Unlike <code>INPUT</code>, no parsing or cooking of the input is done, and therefore quotes, commas, and colons are stored in the string as typed. No prompt is displayed, either.</p> <p>The input is taken from the KERNAL editor, hence the user will have the freedom of all of the features of the editor such as cursor movement, mode switching, and color changing.</p> <p>Due to how the editor works, an empty line will return <code>\" \"</code>\u2013 a string with a single space, and trailing spaces are not preserved.</p> <p>EXAMPLE of LINPUT Statement:</p> <pre><code>10 LINPUT A$\n20 IF A$=\" \" THEN 50\n30 PRINT \"YOU TYPED: \";A$\n40 END\n50 PRINT \"YOU TYPED AN EMPTY STRING: \";A$\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#linput_1","title":"LINPUT#","text":"<p>TYPE: Command FORMAT: LINPUT# &lt;n&gt;,&lt;var$&gt;[,&lt;delimiter&gt;]</p> <p>Action: <code>LINPUT#</code> Reads a line of data from an open file and stores the data into a string variable. The delimiter of a line by default is 13 (carriage return). The delimiter is not part of the stored value. If the end of the file is reached while reading, <code>ST AND 64</code> will be true.</p> <p><code>LINPUT#</code> can be used to read structured data from files. It can be particularly useful to extract quoted or null-terminated strings from files while reading.</p> <p>EXAMPLE of LINPUT# Statement:</p> <pre><code>10 I=0\n20 OPEN 1,8,0,\"$\"\n30 LINPUT#1,A$,$22\n40 IF ST&lt;&gt;0 THEN 130\n50 LINPUT#1,A$,$22\n60 IF I=0 THEN 90\n70 PRINT \"ENTRY: \";\n80 GOTO 100\n90 PRINT \"LABEL: \";\n100 PRINT CHR$($22);A$;CHR$($22)\n110 I=I+1\n120 IF ST=0 THEN 30\n130 CLOSE 1\n</code></pre> <p>The above example parses and prints out the filenames from a directory listing.</p>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#list","title":"LIST","text":"<p>TYPE: Command FORMAT: LIST [start] [-] [end]</p> <p>Action: <code>LIST</code> Displays the currently loaded BASIC program on the screen. The start and ending line numbers are both optional.</p> <p>The start and/or end may be specified. If both are specified, a hyphen must be included. So LIST has 4 modes:</p> <p><code>LIST</code> by itself will display the entire program.</p> <p><code>LIST 10-20</code> will display lines 10 to 20, inclusive.</p> <p><code>LIST -100</code> will display from the start to line 100</p> <p><code>LIST 50-</code> will display line 50 to the end of the program.</p> <p>Pressing the <code>CONTROL</code> key during a listing will slow the listing down once printing reaches the bottom of the screen. Approxmately one line per second will be displayed.</p> <p>Pressing the <code>SPACE BAR</code> during the listing will cause the listing to pause. Pressing the <code>SPACE BAR</code> a second time will unpause the listing. You may also use the down arrow key to scroll by one line or use the <code>PgDn</code> key to scroll approximately one screen full of text.</p>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#locate","title":"LOCATE","text":"<p>TYPE: Command FORMAT: LOCATE &lt;line&gt;[,&lt;column&gt;]</p> <p>Action: This command positions the text mode cursor at the given location. The values are 1-based. If no column is given, only the line is changed.</p> <p>EXAMPLE of LOCATE Statement:</p> <pre><code>100 REM DRAW CIRCLE ON TEXT SCREEN\n110 SCREEN0\n120 R=25\n130 X0=40\n140 Y0=30\n150 FORT=0TO360STEP1\n160 :  X=X0+R*COS(T)\n170 :  Y=Y0+R*SIN(T)\n180 :  LOCATEY,X:PRINTCHR$($12);\" \";\n190 NEXT\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#menu","title":"MENU","text":"<p>TYPE: Command FORMAT: MENU</p> <p>Action: This command currently invokes the Commander X16 Control Panel. In the future, the menu may instead present a menu of ROM-based applications and routines.</p> <p>EXAMPLE of MENU Statement:</p> <pre><code>MENU\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#mon","title":"MON","text":"<p>TYPE: Command FORMAT: MON (Alternative: MONITOR)</p> <p>Action: This command enters the machine language monitor. See the Chapter 7: Machine Language Monitor for a  description.</p> <p>EXAMPLE of MON Statement:</p> <pre><code>MON\nMONITOR\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#mouse","title":"MOUSE","text":"<p>TYPE: Command FORMAT: MOUSE &lt;mode&gt;</p> <p>Action: This command configures the mouse pointer.</p> Mode Description 0 Hide mouse 1 Show mouse, set default mouse pointer -1 Show mouse, don't configure mouse cursor <p><code>MOUSE 1</code> turns on the mouse pointer and <code>MOUSE 0</code> turns it off. If the BASIC program has its own mouse pointer sprite configured, it can use <code>MOUSE -1</code>, which will turn the mouse pointer on, but not set the default pointer sprite.</p> <p>The size of the mouse pointer's area will be configured according to the current screen mode. If the screen mode is changed, the MOUSE statement has to be repeated.</p> <p>EXAMPLES of MOUSE Statement:</p> <pre><code>MOUSE 1 : REM ENABLE MOUSE\nMOUSE 0 : REM DISABLE MOUSE\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#movspr","title":"MOVSPR","text":"<p>TYPE: Command FORMAT: MOVSPR &lt;sprite idx&gt;,&lt;x&gt;,&lt;y&gt;</p> <p>Action: This command positions a sprite's upper left corner at a specific pixel location.  It does not change its visibility.</p> <p><code>sprite idx</code> is a value between 0-127 inclusive. <code>x</code> and <code>y</code> have a range of -32768 to 32767 inclusive, but their meanings wrap every 1024 values. Values approaching 1023 will peek out from the left and top of the screen for x and y respectively as if they were negative and approaching 0. -1024, 1024, 0, and 2048 are all equivalent. Likewise, -10 and 1014 are equivalent.</p> <p>EXAMPLE of MOVSPR Statement:</p> <pre><code>10 BVLOAD \"MYSPRITE.BIN\",8,1,$3000\n20 SPRMEM 1,1,$3000,1\n30 SPRITE 1,3,0,0,3,3\n40 MOVSPR 1,320,200\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#mxmymb","title":"MX/MY/MB","text":"<p>TYPE: System variable FORMAT: MX FORMAT: MY FORMAT: MB</p> <p>Action: Return the horizontal (<code>MX</code>) or vertical (<code>MY</code>) position of the mouse pointer, or the mouse button state (<code>MB</code>).</p> <p><code>MB</code> returns the sum of the following values depending on the state of the buttons:</p> Value Button 0 none 1 left 2 right 4 third <p>EXAMPLE of MX/MY/MB variables:</p> <pre><code>REM SIMPLE DRAWING PROGRAM\n10 SCREEN$80\n20 MOUSE1\n25 OB=0\n30 TX=MX:TY=MY:TB=MB\n35 IFTB=0GOTO25\n40 IFOBTHENLINEOX,OY,TX,TY,16\n50 IFOB=0THENPSETTX,TY,16\n60 OX=TX:OY=TY:OB=TB\n70 GOTO30\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#mwheel","title":"MWHEEL","text":"<p>TYPE: System variable FORMAT: MWHEEL</p> <p>Action: Return the mouse scroll wheel movement since the value was last read. The value is negative if the scroll wheel is moved away from the user, and positive if it is moved towards the user. The range of the returned value is -128 to +127.</p>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#old","title":"OLD","text":"<p>TYPE: Command FORMAT: OLD</p> <p>Action: This command recovers the BASIC program in RAM that has been previously deleted using the <code>NEW</code> command or through a RESET.</p> <p>EXAMPLE of OLD Statement:</p> <pre><code>OLD\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#pointer","title":"POINTER","text":"<p>TYPE: Function FORMAT: POINTER(&lt;variable&gt;)</p> <p>Action: Returns the memory address of the internal structure representing a BASIC variable.</p> <p>EXAMPLE of POINTER function:</p> <pre><code>10 A$=\"MOO\"\n20 PRINT HEX$(POINTER(A$))\nRUN\n0823\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#poweroff","title":"POWEROFF","text":"<p>TYPE: Command FORMAT: POWEROFF</p> <p>Action: This command instructs the SMC to power down the system. This is equivalent to pressing the physical power switch.</p> <p>EXAMPLE of POWEROFF Statement:</p> <pre><code>POWEROFF\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#pset","title":"PSET","text":"<p>TYPE: Command FORMAT: PSET &lt;x&gt;,&lt;y&gt;,&lt;color&gt;</p> <p>Action: This command sets a pixel on the graphics screen to a given color.</p> <p>EXAMPLE of PSET Statement:</p> <pre><code>10 SCREEN$80\n20 FORI=1TO20:PSETRND(1)*320,RND(1)*200,RND(1)*256:NEXT\n30 GOTO20\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#psgchord","title":"PSGCHORD","text":"<p>TYPE: Command FORMAT: PSGCHORD &lt;first voice&gt;,&lt;string&gt;</p> <p>Action: This command uses the same syntax as <code>PSGPLAY</code>, but instead of playing a series of notes, it will start all of the notes in the string simultaneously on one or more voices. The first parameter to <code>PSGCHORD</code> is the first voice to use, and will be used for the first note in the string, and subsequent notes in the string will be started on subsequent voices, with the voice after 15 being voice 0.</p> <p>All macros are supported, even the ones that only affect <code>PSGPLAY</code> and <code>FMPLAY</code>.</p> <p>The full set of macros is documented here.</p> <p>EXAMPLE of PSGCHORD statement:</p> <pre><code>10 PSGINIT\n20 PSGCHORD 15,\"O3G&gt;CE\" : REM STARTS PLAYING A CHORD ON VOICES 15, 0, AND 1\n30 PSGPLAY 14,\"&gt;C&lt;DGB&gt;CDE\" : REM PLAYS A SERIES OF NOTES ON VOICE 14\n40 PSGCHORD 15,\"RRR\" : REM RELEASES CHORD ON VOICES 15, 0, AND 1\n50 PSGPLAY 14,\"O4CAG&gt;C&lt;A\" : REM PLAYS A SERIES OF NOTES ON VOICE 14\n60 PSGCHORD 0,\"O3A&gt;CF\" : REM STARTS PLAYING A CHORD ON VOICES 0, 1, AND 2\n70 PSGPLAY 14,\"L16FGAB-&gt;CDEF4\" : REM PLAYS A SERIES OF NOTES ON VOICE\n80 PSGCHORD 0,\"RRR\" : REM RELEASES CHORD ON VOICES 0, 1, AND 2\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#psgfreq","title":"PSGFREQ","text":"<p>TYPE: Command FORMAT: PSGFREQ &lt;voice&gt;,&lt;frequency&gt;</p> <p>Action: Play a note by frequency on the VERA PSG. The accepted range is in Hz from 1 to 24319. PSGFREQ also accepts a frequency of 0 to release the note.</p> <p>EXAMPLE of PSGFREQ statement:</p> <pre><code>10 PSGINIT : REM RESET ALL VOICES TO SQUARE WAVEFORM\n20 PSGFREQ 0,350 : REM PLAY A SQUARE WAVE AT 350 HZ\n30 PSGFREQ 1,440 : REM PLAY A SQUARE WAVE AT 440 HZ ON ANOTHER VOICE\n40 FOR X=1 TO 10000 : NEXT X : REM DELAY A BIT\n50 PSGFREQ 0,0 : PSGFREQ 1,0 : REM RELEASE BOTH VOICES\n</code></pre> <p>The above BASIC program plays a sound similar to a North American dial tone for a few seconds.</p>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#psginit","title":"PSGINIT","text":"<p>TYPE: Command FORMAT: PSGINIT</p> <p>Action: Initialize VERA PSG, silence all voices, set volume to 63 on all voices, and set the waveform to pulse and the duty cycle to 63 (50%) for all 16 voices.</p>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#psgnote","title":"PSGNOTE","text":"<p>TYPE: Command FORMAT: PSGNOTE &lt;voice&gt;,&lt;note&gt;</p> <p>Action: Play a note on the VERA PSG. The note value is constructed as follows. Using hexadecimal notation, the first nybble is the octave, 0-7, and the second nybble is the note within the octave as follows:</p> <code>$x0</code> <code>$x1</code> <code>$x2</code> <code>$x3</code> <code>$x4</code> <code>$x5</code> <code>$x6</code> <code>$x7</code> <code>$x8</code> <code>$x9</code> <code>$xA</code> <code>$xB</code> <code>$xC</code> <code>$xD-$xF</code> Release C C\u266f/D\u266d D D\u266f/E\u266d E F F\u266f/G\u266d G G\u266f/A\u266d A A\u266f/B\u266d B no-op <p>EXAMPLE of PSGNOTE statement:</p> <pre><code>10 PSGNOTE 1,$4A : REM PLAYS CONCERT A\n20 FOR X=1 TO 5000 : NEXT X : REM DELAYS FOR A BIT\n30 PSGNOTE 1,0 : REM RELEASES THE NOTE\n40 FOR X=1 TO 2500 : NEXT X : REM SHORT DELAY\n50 PSGNOTE 1,$3A : REM PLAYS A IN THE 3RD OCTAVE\n60 FOR X=1 TO 2500 : NEXT X : REM SHORT DELAY\n70 PSGNOTE 1,0 : REM RELEASES THE NOTE\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#psgpan","title":"PSGPAN","text":"<p>TYPE: Command FORMAT: PSGPAN &lt;voice&gt;,&lt;panning&gt;</p> <p>Action: Sets the simple stereo panning on a VERA PSG voice. Valid values are as follows:</p> <ul> <li>1 = left</li> <li>2 = right</li> <li>3 = both</li> </ul>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#psgplay","title":"PSGPLAY","text":"<p>TYPE: Command FORMAT: PSGPLAY &lt;voice&gt;,&lt;string&gt;</p> <p>Action: This command is very similar to <code>PLAY</code> on other BASICs such as GWBASIC. It takes a string of notes, rests, tempo changes, note lengths, and other macros, and plays all of the notes synchronously.  That is, the PSGPLAY command will not return control until all of the notes and rests in the string have been fully played.</p> <p>The full set of macros is documented here.</p> <p>EXAMPLE of PSGPLAY statement:</p> <pre><code>10 PSGWAV 0,31 : REM PULSE, 25% DUTY\n20 PSGPLAY 0,\"T180 S0 O5 L32\" : REM TEMPO 180 BPM, LEGATO, OCTAVE 5, 32ND NOTES\n30 PSGPLAY 0,\"C&lt;G&gt;CEG&gt;C&lt;G&lt;A-\"\n40 PSGPLAY 0,\"&gt;CE-A-E-A-&gt;CE-A-\"\n50 PSGPLAY 0,\"E-&lt;&lt;B-&gt;DFB-FB-&gt;DFB-F\" : REM GRAB YOURSELF A MUSHROOM\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#psgvol","title":"PSGVOL","text":"<p>TYPE: Command FORMAT: PSGVOL &lt;voice&gt;,&lt;volume&gt;</p> <p>Action: This command sets the voice's volume. The volume remains at the requested level until another <code>PSGVOL</code> command for that voice or <code>PSGINIT</code> is called.  Valid range is from 0 (completely silent) to 63 (full volume).</p>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#psgwav","title":"PSGWAV","text":"<p>TYPE: Command FORMAT: PSGWAV &lt;voice&gt;,&lt;w&gt;</p> <p>Action: Sets the waveform and duty cycle for a PSG voice.</p> <ul> <li>w = 0-63 -&gt; Pulse: Duty cycle is <code>(w+1)/128</code>. A value of 63 means 50% duty.</li> <li>w = 64-127 -&gt; Sawtooth (all values have identical effect)</li> <li>w = 128-191 -&gt; Triangle (all values have identical effect)</li> <li>w = 192-255 -&gt; Noise (all values have identical effect)</li> </ul> <p>EXAMPLE of PSGWAV Statement:</p> <pre><code>10 FOR O=$20 TO $50 STEP $10:REM OCTAVE LOOP\n20 FOR N=1 TO 11 STEP 2:REM NOTE LOOP, EVERY OTHER NOTE\n30 PSGNOTE 0,O+N:REM START PLAYBACK OF THE NOTE\n40 FOR P=0 TO 30:REM PULSE WIDTH MODULATION LOOP (INCREASING DUTY)\n50 PSGWAV 0,P:REM SET PW\n60 FOR D=1 TO 30:NEXT D:REM DELAY LOOP\n70 NEXT P\n80 PSGNOTE 0,O+N+1:REM START PLAYBACK OF THE NOTE + A SEMITONE\n90 FOR P=31 TO 1 STEP -1:REM PWM LOOP (DECREASING DUTY)\n100 PSGWAV 0,P:REM SET PW\n110 FOR D=1 TO 30:NEXT D:REM DELAY LOOP\n120 NEXT P\n130 NEXT N\n140 NEXT O\n150 PSGNOTE 0,0:REM STOP SOUND\n</code></pre> <p>This example plays a chromatic scale while applying pulse-width modulation on the voice.</p>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#rect","title":"RECT","text":"<p>TYPE: Command FORMAT: RECT &lt;x1&gt;,&lt;y1&gt;,&lt;x2&gt;,&lt;y2&gt;,&lt;color&gt;</p> <p>Action: This command draws a solid rectangle on the graphics screen in a given color.</p> <p>EXAMPLE of RECT Statement:</p> <pre><code>10 SCREEN$80\n20 FORI=1TO20:RECTRND(1)*320,RND(1)*200,RND(1)*320,RND(1)*200,RND(1)*256:NEXT\n30 GOTO20\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#reboot","title":"REBOOT","text":"<p>TYPE: Command FORMAT: REBOOT</p> <p>Action: Performs a software reset of the system by calling the ROM reset vector.</p> <p>EXAMPLE of REBOOT Statement:</p> <pre><code>REBOOT\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#ren","title":"REN","text":"<p>TYPE: Command FORMAT: REN [&lt;new line num&gt;[, &lt;increment&gt;[, &lt;first old line num&gt;]]]</p> <p>Action: Renumbers a BASIC program while updating the line number arguments of GOSUB, GOTO, RESTORE, RUN, and THEN.</p> <p>Optional arguments:</p> <ul> <li>The line number of the first line after renumbering, default: 10</li> <li>The value of the increment for subsequent lines, default 10</li> <li>The earliest old line to start renumbering at, default: 0</li> </ul> <p>THIS STATEMENT IS EXPERIMENTAL.  Please ensure your have saved your program before using this command to renumber.</p> <p>KNOWN BUG: In release R43, due to improper parsing of escape tokens, REN will improperly treat arguments to these statements as line numbers:</p> <ul> <li><code>FRAME</code></li> <li><code>RECT</code></li> <li><code>MOUSE</code></li> <li><code>COLOR</code></li> <li><code>PSGWAV</code></li> </ul> <p>This behavior has been fixed in R44.</p> <p>EXAMPLE of REN Statement:</p> <pre><code>10 PRINT \"HELLO\"\n20 DATA 1,2,3\n30 DATA 4,5,6\n40 READ X\n50 PRINT X\n60 RESTORE 30\n70 READ X\n80 PRINT X\n90 GOTO 10\n\nREN 100,5\n\nLIST\n100 PRINT \"HELLO\"\n105 DATA 1,2,3\n110 DATA 4,5,6\n115 READ X\n120 PRINT X\n125 RESTORE 110\n130 READ X\n135 PRINT X\n140 GOTO 100\nREADY.\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#reset","title":"RESET","text":"<p>TYPE: Command FORMAT: RESET</p> <p>Action: This command instructs the SMC to assert the reset line on the system, which performs a hard reset. This is equivalent to pressing the physical reset switch.</p> <p>EXAMPLE of RESET Statement:</p> <pre><code>RESET\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#restore","title":"RESTORE","text":"<p>TYPE: Command FORMAT: RESTORE [&lt;linenum&gt;]</p> <p>Action: This command resets the pointer for the <code>READ</code> command. Without arguments, it will reset the pointer to the first <code>DATA</code> constant in the program.  With a parameter <code>linenum</code>, the command will reset the pointer to the first <code>DATA</code> constant at or after that line number.</p> <p>EXAMPLE of RESTORE Statement:</p> <pre><code>10 DATA 1,2,3\n20 DATA 4,5,6\n30 READ Y\n40 PRINT Y\n50 RESTORE 20\n60 READ Y\n70 PRINT Y\n</code></pre> <p>This program will output the number 1 followed by the number 4.</p>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#rpt","title":"RPT$","text":"<p>TYPE: Function FORMAT: RPT$(&lt;byte&gt;,&lt;count&gt;)</p> <p>Action: Returns a string of &lt;count&gt; instances of the PETSCII character represented by the numeric value &lt;byte&gt;.  This function is similar in behavior to <code>CHR$()</code> but takes a second argument as a repeat count.</p> <p><code>RPT$(A,1)</code> is functionally equivalent to <code>CHR$(A)</code>.</p> <p>EXAMPLE of RPT$ function:</p> <pre><code>10 REM TEN EXCLAMATION MARKS\n20 PRINT RPT$(33,10)\nREADY.\nRUN\n!!!!!!!!!!\n\nREADY.\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#save","title":"SAVE","text":"<p>TYPE: Command FORMAT: SAVE &lt;filename&gt; [, &lt;device&gt;]</p> <p>Action: Saves a BASIC program to a file.</p> <p>This saves the currently loaded BASIC program to a file. If the device number is not supplied, SAVE will use the default drive. This is usually the SD card.</p> <p>Note that SAVE will not overwrite an existing file by default. To do this, you must prefix the filename with @:, like this: <code>SAVE \"@:filename\"</code></p> <p>EXAMPLES of SAVE:</p> <pre><code>SAVE \"HELLO.PRG\"\n</code></pre> <p>The above example saves your Hello World program to the SD card.</p> <pre><code>SAVE \"@:HELLO.PRG\",9\n</code></pre> <p>The above example overwrites an existing file on drive 9, which would be a Commodore style disk drive plugged into the IEC port.</p>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#screen","title":"SCREEN","text":"<p>TYPE: Command FORMAT: SCREEN &lt;mode&gt;</p> <p>Action: This command switches screen modes.</p> <p>For a list of supported modes, see Chapter 3: Editor. The value of -1 toggles between modes $00 and $03.</p> <p>EXAMPLE of SCREEN Statement:</p> <pre><code>SCREEN 3 : REM SWITCH TO 40 CHARACTER MODE\nSCREEN 0 : REM SWITCH TO 80 CHARACTER MODE\nSCREEN -1 : REM SWITCH BETWEEN 40 and 80 CHARACTER MODE\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#sleep","title":"SLEEP","text":"<p>TYPE: Command FORMAT: SLEEP [&lt;jiffies&gt;]</p> <p>Action: With the default interrupt source configured and enabled, this command waits for <code>jiffies</code>+1 VSYNC events and then resumes program execution. In other words, <code>SLEEP</code> with no arguments is equivalent to <code>SLEEP 0</code>, which waits until the beginning of the next frame. Another useful example, <code>SLEEP 60</code>, pauses for approximately 1 second.</p> <p>Allowed values for <code>jiffies</code> is from 0 to 65535, inclusive.</p> <p>EXAMPLE of SLEEP Statement:</p> <pre><code>10 FOR I=1 TO 10\n20 PRINT I\n30 SLEEP 60\n40 NEXT\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#sprite","title":"SPRITE","text":"<p>TYPE: Command FORMAT: SPRITE &lt;sprite idx&gt;,&lt;priority&gt;[,&lt;palette offset&gt;[,&lt;flip&gt;[,&lt;x-width&gt;[,&lt;y-width&gt;[,&lt;color depth&gt;]]]]]</p> <p>Action: This command configures a sprite's geometry, palette, and visibility.</p> <p>The first two arguments are required, but the remainder are optional.</p> <ul> <li><code>sprite idx</code> is a value between 0-127 inclusive.</li> <li><code>priority</code>, also known as z-depth changes the visibility of the sprite and above which layer it is rendered.  Range is 0-3 inclusive.  0 = off, 1 = below layer 0, 2 = in between layers 0 and 1, 3 = above layer 1</li> <li><code>palette offset</code> is the palette offset for the sprite. Range is 0-15 inclusive. This value is multiplied by 16 to determine the starting palette index.</li> <li><code>flip</code> controls the X and Y flipping of the sprite. Range is 0-3 inclusive. 0 = unflipped, 1 = X is flipped, 2 = Y is flipped, 3 = both X and Y are flipped.</li> <li><code>x-width</code> and <code>y-width</code> represent the dimensions of the sprite. Range is 0-3 inclusive. 0 = 8px, 1 = 16px, 2 = 32px, 3 = 64px.</li> <li><code>color depth</code> selects either 4 or 8-bit color depth for the sprite. 0 = 4-bit, 1 = 8-bit.  This attribute can also be set by the <code>SPRMEM</code> command.</li> </ul> <p>Note: If VERA's sprite layer is disabled when the <code>SPRITE</code> command is called, the sprite layer will be enabled, regardless of the arguments to <code>SPRITE</code>.</p> <p>EXAMPLE of SPRITE Statement:</p> <pre><code>10 BVLOAD \"MYSPRITE.BIN\",8,1,$3000\n20 SPRMEM 1,1,$3000,1\n30 SPRITE 1,3,0,0,3,3\n40 MOVSPR 1,320,200\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#sprmem","title":"SPRMEM","text":"<p>TYPE: Command FORMAT: SPRMEM &lt;sprite idx&gt;,&lt;VRAM bank&gt;,&lt;VRAM address&gt;[,&lt;color depth&gt;]</p> <p>Action: This command configures the address of where the sprite's pixel data is to be found. It also can change or set the color depth of the sprite.</p> <p>The first three arguments are required, but the last one is optional.</p> <ul> <li><code>sprite idx</code> is a value between 0-127 inclusive.</li> <li><code>VRAM bank</code> is a value, <code>0</code> or <code>1</code>, which represents which of the two 64k regions of VRAM to select.</li> <li><code>VRAM address</code> is a 16-bit value, $0000-$FFFF, is the address within the VRAM bank to point the sprite to. The lowest 5 bits are ignored.</li> <li><code>color depth</code> selects either 4 or 8-bit color depth for the sprite. 0 = 4-bit, 1 = 8-bit.  This attribute can also be set by the <code>SPRITE</code> command.</li> </ul> <p>EXAMPLE of SPRITE Statement:</p> <pre><code>10 BVLOAD \"MYSPRITE.BIN\",8,1,$3000\n20 SPRMEM 1,1,$3000,1\n30 SPRITE 1,3,0,0,3,3\n40 MOVSPR 1,320,200\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#strptr","title":"STRPTR","text":"<p>TYPE: Function FORMAT: STRPTR(&lt;variable&gt;)</p> <p>Action: Returns the memory address of the first character of a string contained within a string variable. If the string variable has zero length, this function will likely still return a non-zero value pointing either to the close quotation mark in the literal assignment, or to somewhere undefined in string memory. Programs should check the <code>LEN()</code> of string variables before using the pointer returned from <code>STRPTR</code>.</p> <p>EXAMPLE of STRPTR function:</p> <pre><code>10 A$=\"MOO\"\n20 P=STRPTR(A$)\n30 FOR I=0 TO LEN(A$)-1\n40 PRINT CHR$(PEEK(P+I));\n50 NEXT\n60 A$=\"\"\n70 P=STRPTR(A$)\n80 FOR I=0 TO LEN(A$)-1 : REM THIS LOOP WILL STILL ALWAYS HAPPEN ONCE\n90 PRINT CHR$(PEEK(P+I));\n100 NEXT\nRUN\nMOO\"\nREADY.\n</code></pre> <p>In this case, the pointer returned on line 70 pointed to the first character after the open quote on line 60. Since it was an empty string, the pointer ended up pointing to the close quote. To avoid this scenario, we should have checked the <code>LEN(A$)</code> before line 80 and skipped over the loop.</p>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#sys","title":"SYS","text":"<p>TYPE: Command FORMAT: SYS &lt;address&gt;</p> <p>Action: The SYS command executes a machine language subroutine located at &lt;address&gt;. Execution continues until an RTS is executed, and control returns to the BASIC program.</p> <p>In order to communicate with the routine, you can pre-load the CPU registers by using POKE to write to the following memory locations:</p> <ul> <li><code>$030C</code>: Accumulator</li> <li><code>$030D</code>: X Register</li> <li><code>$030E</code>: Y Register</li> <li><code>$030F</code>: Status Register/Flags</li> </ul> <p>When the routine is over, the CPU registers will be loaded back in to these locations. So you can read the results of a machine language routine by PEEKing these locations.</p> <p>EXAMPLE of SYS statemet:</p> <p>Push a &lt;CR&gt; into the keyboard buffer.</p> <pre><code>POKE $30C,13\nSYS $FEC3\n</code></pre> <p>Run the Machine Language Monitor (Supermon)</p> <pre><code>SYS  $FECC\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#tile","title":"TILE","text":"<p>TYPE: Command FORMAT: TILE &lt;x&gt;,&lt;y&gt;,&lt;tile/screen code&gt;[,&lt;attribute&gt;]</p> <p>Action: The <code>TILE</code> command sets the tile or text character at the given x/y tile/character coordinate to the given screen code or tile index, optionally resetting the attribute byte. It works for tiles or text on Layer 1.</p> <p>In the default text mode, this can be used to quickly change a character on the screen and optionally its fg/bg color without needing to calculate the VRAM address for VPOKE.</p> <p>However, it can also be used if VERA Layer 1's map base value is changed or the map size is changed.</p> <p>EXAMPLE of TILE command:</p> <pre><code>10 REM VERY SLOWLY CLEAR THE SCREEN IN STYLE\n20 FOR Y=59 TO 0 STEP -1\n30 FOR X=79 TO 0 STEP -1\n40 FOR I=255 TO 32 STEP -1\n50 TILE X,Y,I\n60 NEXT:NEXT:NEXT\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#tattr","title":"TATTR","text":"<p>TYPE: Function FORMAT: TATTR(&lt;x coordinate&gt;,&lt;y coordinate&gt;)</p> <p>Action: The <code>TATTR</code>function retrieves the text/tile attribute at the given x/y coordinate. It works for tiles or text on Layer 1.</p> <p>In the default text modes, this can be used to retrieve the color attribute (fg/bg) of a specific coordinate without needing to calculate the VRAM address for VPEEK.</p> <p>EXAMPLE of TATTR command:</p> <pre><code>10 REM COPY BUTTERFLY LOGO WITH COLORS TO CENTER OF 80X60 SCREEN\n20 XO = 37 : YO = 27\n30 FOR X = 0 TO 6\n40 FOR Y = 0 TO 6\n50 TD = TDATA(X, Y)\n60 TA = TATTR(X, Y)\n70 TILE XO+X, YO+Y, TD, TA\n80 NEXT:NEXT\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#tdata","title":"TDATA","text":"<p>TYPE: Function FORMAT: TDATA(&lt;x coordinate&gt;,&lt;y coordinate&gt;)</p> <p>Action: The <code>TDATA</code>function retrieves the text/tile at the given x/y coordinate. It works for tiles or text on Layer 1.</p> <p>In the default text modes, this can be used to retrieve the character a specific coordinate without needing to calculate the VRAM address for VPEEK.</p> <p>EXAMPLE of TATTR command:</p> <pre><code>10 REM COPY BUTTERFLY LOGO TO CENTER OF 80X60 SCREEN\n20 XO = 37 : YO = 27\n30 FOR X = 0 TO 6\n40 FOR Y = 0 TO 6\n50 TD = TDATA(X, Y)\n60 TILE XO+X, YO+Y, TD\n70 NEXT:NEXT\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#vpeek","title":"VPEEK","text":"<p>TYPE: Integer Function FORMAT: VPEEK (&lt;bank&gt;, &lt;address&gt;)</p> <p>Action: Return a byte from the video address space. The video address space has 17 bit addresses, which is exposed as 2 banks of 65536 addresses each.</p> <p>In addition, VPEEK can reach add-on VERA cards with higher bank numbers.</p> <p>BANK 2-3 is for IO3 (VERA at $9F60-$9F7F) BANK 4-5 is for IO4 (VERA at $9F80-$9F9F)</p> <p>EXAMPLE of VPEEK Function:</p> <pre><code>PRINT VPEEK(1,$B000) : REM SCREEN CODE OF CHARACTER AT 0/0 ON SCREEN\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#vpoke","title":"VPOKE","text":"<p>TYPE: Command FORMAT: VPOKE &lt;bank&gt;, &lt;address&gt;, &lt;value&gt;</p> <p>Action: Set a byte in the video address space. The video address space has 17 bit addresses, which is exposed as 2 banks of 65536 addresses each.</p> <p>In addition, VPOKE can reach add-on VERA cards with higher bank numbers.</p> <p>BANK 2-3 is for IO3 (VERA at $9F60-$9F7F) BANK 4-5 is for IO4 (VERA at $9F80-$9F9F)</p> <p>EXAMPLE of VPOKE Statement:</p> <pre><code>VPOKE 1,$B000+1,1 * 16 + 2 : REM SETS THE COLORS OF THE CHARACTER\n                             REM AT 0/0 TO RED ON WHITE\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#vload","title":"VLOAD","text":"<p>TYPE: Command FORMAT: VLOAD &lt;filename&gt;, &lt;device&gt;, &lt;VERA_high_address&gt;, &lt;VERA_low_address&gt;</p> <p>Action: Loads a file directly into VERA RAM, skipping the two-byte header that is presumed to be in the file.</p> <p>EXAMPLES of VLOAD:</p> <pre><code>VLOAD \"MYFILE.PRG\", 8, 0, $4000  :REM LOADS MYFILE.PRG FROM DEVICE 8 TO VRAM $4000\n                                  REM WHILE SKIPPING THE FIRST TWO BYTES OF THE FILE.\n</code></pre> <p>To load a raw binary file without skipping the first two bytes, use <code>BVLOAD</code></p>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#other-new-features","title":"Other New Features","text":""},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#hexadecimal-and-binary-literals","title":"Hexadecimal and Binary Literals","text":"<p>The numeric constants parser supports both hex (<code>$</code>) and binary (<code>%</code>) literals, like this:</p> <pre><code>PRINT $EA31 + %1010\n</code></pre> <p>The size of hex and binary values is only restricted by the range that can be represented by BASIC's internal floating point representation.</p>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#load-into-vram","title":"LOAD into VRAM","text":"<p>In BASIC, the contents of files can be directly loaded into VRAM with the <code>LOAD</code> statement. When a secondary address greater than one is used, the KERNAL will now load the file into the VERA's VRAM address space. The first two bytes of the file are used as lower 16 bits of the address. The upper 4 bits are <code>(SA-2) &amp; 0x0ff</code> where <code>SA</code> is the secondary address.</p> <p>Examples:</p> <pre><code>10 REM LOAD VERA SETTINGS\n20 LOAD\"VERA.BIN\",1,17 : REM SET ADDRESS TO $FXXXX\n30 REM LOAD TILES\n40 LOAD\"TILES.BIN\",1,3 : REM SET ADDRESS TO $1XXXX\n50 REM LOAD MAP\n60 LOAD\"MAP.BIN\",1,2 : REM SET ADDRESS TO $0XXXX\n</code></pre>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#default-device-numbers","title":"Default Device Numbers","text":"<p>In BASIC, the LOAD, SAVE and OPEN statements default to the last-used IEEE device (device numbers 8 and above), or 8.</p>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#internal-representation","title":"Internal Representation","text":"<p>Like on the C64, BASIC keywords are tokenized.</p> <ul> <li>The C64 BASIC V2 keywords occupy the range of $80 (<code>END</code>) to $CB (<code>GO</code>).</li> <li>BASIC V3.5 also used $CE (<code>RGR</code>) to $FD (<code>WHILE</code>).</li> <li>BASIC V7 introduced the $CE escape code for function tokens $CE-$02 (<code>POT</code>) to $CE-$0A (<code>POINTER</code>), and the $FE escape code for statement tokens $FE-$02 (<code>BANK</code>) to $FE-$38 (<code>SLOW</code>).</li> <li>The unreleased BASIC V10 extended the escaped tokens up to $CE-$0D (<code>RPALETTE</code>) and $FE-$45 (<code>EDIT</code>).</li> </ul> <p>The X16 BASIC aims to be as compatible as possible with this encoding. Keywords added to X16 BASIC that also exist in other versions of BASIC match the token, and new keywords are encoded in the ranges $CE-$80+ and $FE-$80+.</p>"},{"location":"X16%20Reference%20-%2004%20-%20BASIC/#auto-boot","title":"Auto-Boot","text":"<p>When BASIC starts, it automatically executes the <code>BOOT</code> command, which tries to load a PRG file named <code>AUTOBOOT.X16</code> from device 8 and, if successful, runs it. Here are some use cases for this:</p> <ul> <li>An SD card with a game can auto-boot this way.</li> <li>An SD card with a collection of applications can show a menu that allows selecting an application to load.</li> <li>The user's \"work\" SD card can contain a small auto-boot BASIC program that sets the keyboard layout and changes the screen colors, for example.</li> </ul>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/","title":"5: KERNAL","text":"<p>The Commander X16 contains a version of KERNAL as its operating system in ROM. It contains</p> <ul> <li>\"Channel I/O\" API for abstracting devices</li> <li>a variable size screen editor</li> <li>a color bitmap graphics API with proportional fonts</li> <li>simple memory management</li> <li>timekeeping</li> <li>drivers</li> <li>PS/2 keyboard and mouse</li> <li>NES/SNES controller</li> <li>Commodore Serial Bus (\"IEC\")</li> <li>I2C bus</li> </ul>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#kernal-version","title":"KERNAL Version","text":"<p>The KERNAL version can be read from location $FF80 in ROM. A value of $FF indicates a custom build. All other values encode the build number. Positive numbers are release versions ($02 = release version 2), two's complement negative numbers are prerelease versions ($FE = $100 - 2 = prerelease version 2).</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#compatibility-considerations","title":"Compatibility Considerations","text":"<p>For applications to remain compatible between different versions of the ROM, they can rely upon:</p> <ul> <li>the KERNAL API calls at $FF81-$FFF3</li> <li>the KERNAL vectors at $0314-$0333</li> </ul> <p>The following features must not be relied upon:</p> <ul> <li>the zero page and $0200+ memory layout</li> <li>direct function offsets in the ROM</li> </ul>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#commodore-64-api-compatibility","title":"Commodore 64 API Compatibility","text":"<p>The KERNAL fully supports the C64 KERNAL API.</p> <p>These routines have been stable ever since the C64 came out and are extensively documented in various resources dedicated to the C64. Currently, they are not documented here so if you need to look them up, here is a very thorough reference of these standard kernal routines (hosted on M. Steil's website). It integrates a dozen or so different sources for documentation about these routines.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#commodore-128-api-compatibility","title":"Commodore 128 API Compatibility","text":"<p>In addition, the X16 supports a subset of the C128 API.</p> <p>The following C128 APIs have equivalent functionality on the X16 but are not compatible:</p> Address C128 Name X16 Name $FF5F <code>SWAPPER</code> <code>screen_mode</code> $FF62 <code>DLCHR</code> <code>screen_set_charset</code> $FF74 <code>FETCH</code> <code>fetch</code> $FF77 <code>STASH</code> <code>stash</code>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#new-api-for-the-commander-x16","title":"New API for the Commander X16","text":"<p>There are lots of new APIs. Please note that their addresses and their behavior is still preliminary and can change between revisions.</p> <p>Some new APIs use the \"16 bit\" ABI, which uses virtual 16 bit registers r0 through r15, which are located in zero page locations $02 through $21: r0 = r0L = $02, r0H = $03, r1 = r1L = $04 etc.</p> <p>The 16 bit ABI generally follows the following conventions:</p> <ul> <li>arguments</li> <li>word-sized arguments: passed in r0-r5</li> <li>byte-sized arguments: if three or less, passed in .A, .X, .Y; otherwise in 16 bit registers</li> <li>boolean arguments: c, n</li> <li>return values</li> <li>basic rules as above</li> <li>function takes no arguments: r0-r5, else indirect through passed-in pointer</li> <li>arguments in r0-r5 can be \"inout\", i.e. they can be updated</li> <li>saved/scratch registers</li> <li>r0-r5: arguments (saved)</li> <li>r6-r10: saved</li> <li>r11-r15: scratch</li> <li>.A, .X, .Y, c, n: scratch (unless used otherwise)</li> </ul>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#kernal-api-functions","title":"KERNAL API functions","text":"Label Address Class Description Inputs Affects Origin <code>ACPTR</code> <code>$FFA5</code> CPB Read byte from peripheral bus A X C64 <code>BASIN</code> <code>$FFCF</code> ChIO Get character A X C64 <code>BSAVE</code> <code>$FEBA</code> ChIO Like <code>SAVE</code> but omits the 2-byte header A X Y A X Y X16 <code>BSOUT</code> <code>$FFD2</code> ChIO Write byte in A to default output. For writing to a file must call <code>OPEN</code> and <code>CHKOUT</code> beforehand. A C C64 <code>CIOUT</code> <code>$FFA8</code> CPB Send byte to peripheral bus A A X C64 <code>CLALL</code> <code>$FFE7</code> ChIO Close all channels A X C64 <code>CLOSE</code> <code>$FFC3</code> ChIO Close a channel A A X Y P C64 <code>CHKIN</code> <code>$FFC6</code> ChIO Set channel for character input X A X C64 <code>clock_get_date_time</code> <code>$FF50</code> Time Get the date and time none r0 r1 r2 r3 A X Y P X16 <code>clock_set_date_time</code> <code>$FF4D</code> Time Set the date and time r0 r1 r2 r3 A X Y P X16 <code>CHRIN</code> <code>$FFCF</code> ChIO Alias for <code>BASIN</code> A X C64 <code>CHROUT</code> <code>$FFD2</code> ChIO Alias for <code>BSOUT</code> A C C64 <code>CLOSE_ALL</code> <code>$FF4A</code> ChIO Close all files on a device C128 <code>CLRCHN</code> <code>$FFCC</code> ChIO Restore character I/O to screen/keyboard A X C64 <code>console_init</code> <code>$FEDB</code> Video Initialize console mode none r0 A P X16 <code>console_get_char</code> <code>$FEE1</code> Video Get character from console A r0 r1 r2 r3 r4 r5 r6 r12 r13 r14 r15 A X Y P X16 <code>console_put_char</code> <code>$FEDE</code> Video Print character to console A C r0 r1 r2 r3 r4 r5 r6 r12 r13 r14 r15 A X Y P X16 <code>console_put_image</code> <code>$FED8</code> Video Draw image as if it was a character r0 r1 r2 r0 r1 r2 r3 r4 r5 r14 r15 A X Y P X16 <code>console_set_paging_message</code> <code>$FED5</code> Video Set paging message or disable paging r0 A P X16 <code>enter_basic</code> <code>$FF47</code> Misc Enter BASIC C A X Y P X16 <code>entropy_get</code> <code>$FECF</code> Misc get 24 random bits none A X Y P X16 <code>extapi</code> <code>$FEAB</code> Misc Extended API A X Y P A X Y P X16 <code>extapi16</code> <code>$FEA8</code> Misc Extended 65C816 API A X Y P A X Y P X16 <code>fetch</code> <code>$FF74</code> Mem Read a byte from any RAM or ROM bank (A) X Y A X P X16 <code>FB_cursor_next_line</code> \u2020 <code>$FF02</code> Video Move direct-access cursor to next line r0\u2020 A P X16 <code>FB_cursor_position</code> <code>$FEFF</code> Video Position the direct-access cursor r0 r1 A P X16 <code>FB_fill_pixels</code> <code>$FF17</code> Video Fill pixels with constant color, update cursor r0 r1 A A X Y P X16 <code>FB_filter_pixels</code> <code>$FF1A</code> Video Apply transform to pixels, update cursor r0 r1 r14H r15 A X Y P X16 <code>FB_get_info</code> <code>$FEF9</code> Video Get screen size and color depth none r0 r1 A P X16 <code>FB_get_pixel</code> <code>$FF05</code> Video Read one pixel, update cursor none A X16 <code>FB_get_pixels</code> <code>$FF08</code> Video Copy pixels into RAM, update cursor r0 r1 (r0) A X Y P X16 <code>FB_init</code> <code>$FEF6</code> Video Enable graphics mode none A P X16 <code>FB_move_pixels</code> <code>$FF1D</code> Video Copy horizontally consecutive pixels to a different position r0 r1 r2 r3 r4 A X Y P X16 <code>FB_set_8_pixels</code> <code>$FF11</code> Video Set 8 pixels from bit mask (transparent), update cursor A X A P X16 <code>FB_set_8_pixels_opaque</code> <code>$FF14</code> Video Set 8 pixels from bit mask (opaque), update cursor r0L A X Y r0L A P X16 <code>FB_set_palette</code> <code>$FEFC</code> Video Set (parts of) the palette A X r0 A X Y P X16 <code>FB_set_pixel</code> <code>$FF0B</code> Video Set one pixel, update cursor A none X16 <code>FB_set_pixels</code> <code>$FF0E</code> Video Copy pixels from RAM, update cursor r0 r1 A X P X16 <code>GETIN</code> <code>$FFE4</code> Kbd Get character from keyboard A X C64 <code>GRAPH_clear</code> <code>$FF23</code> Video Clear screen none r0 r1 r2 r3 A X Y P X16 <code>GRAPH_draw_image</code> <code>$FF38</code> Video Draw a rectangular image r0 r1 r2 r3 r4 A P X16 <code>GRAPH_draw_line</code> <code>$FF2C</code> Video Draw a line r0 r1 r2 r3 r0 r1 r2 r3 r7 r8 r9 r10 r12 r13 A X Y P X16 <code>GRAPH_draw_oval</code> \ud83d\udeab <code>$FF35</code> Video Draw an oval or circle - - X16 <code>GRAPH_draw_rect</code> \u2020 <code>$FF2F</code> Video Draw a rectangle (optionally filled) r0 r1 r2 r3 r4 C A P X16 <code>GRAPH_get_char_size</code> <code>$FF3E</code> Video Get size and baseline of a character A X A X Y P X16 <code>GRAPH_init</code> <code>$FF20</code> Video Initialize graphics r0 r0 r1 r2 r3 A X Y P X16 <code>GRAPH_move_rect</code> \u2020 <code>$FF32</code> Video Move pixels r0 r1 r2 r3 r4 r5 r1 r3 r5 A X Y P X16 <code>GRAPH_put_char</code> \u2020 <code>$FF41</code> Video Print a character r0 r1 A r0 r1 A X Y P X16 <code>GRAPH_set_colors</code> <code>$FF29</code> Video Set stroke, fill and background colors A X Y none X16 <code>GRAPH_set_font</code> <code>$FF3B</code> Video Set the current font r0 r0 A Y P X16 <code>GRAPH_set_window</code> \u2020 <code>$FF26</code> Video Set clipping region r0 r1 r2 r3 A P X16 <code>i2c_batch_read</code> <code>$FEB4</code> I2C Read multiple bytes from an I2C device X r0 r1 C A Y C X16 <code>i2c_batch_write</code> <code>$FEB7</code> I2C Write multiple bytes to an I2C device X r0 r1 C A Y r2 C X16 <code>i2c_read_byte</code> <code>$FEC6</code> I2C Read a byte from an I2C device A X Y A C X16 <code>i2c_write_byte</code> <code>$FEC9</code> I2C Write a byte to an I2C device A X Y A C X16 <code>IOBASE</code> <code>$FFF3</code> Misc Return start of I/O area X Y C64 <code>JSRFAR</code> <code>$FF6E</code> Misc Execute a routine on another RAM or ROM bank PC+3 PC+5 none X16 <code>joystick_get</code> <code>$FF56</code> Joy Get one of the saved controller states A A X Y P X16 <code>joystick_scan</code> <code>$FF53</code> Joy Poll controller states and save them none A X Y P X16 <code>kbd_scan</code> <code>$FF9F</code> Kbd Process a keystroke and place it in the buffer none A X Y P C64 <code>kbdbuf_get_modifiers</code> <code>$FEC0</code> Kbd Get currently pressed modifiers A A X P X16 <code>kbdbuf_peek</code> <code>$FEBD</code> Kbd Get next char and keyboard queue length A X A X P X16 <code>kbdbuf_put</code> <code>$FEC3</code> Kbd Append a character to the keyboard queue A X X16 <code>keymap</code> <code>$FED2</code> Kbd Set or get the current keyboard layout Call address X Y C A X Y C X16 <code>LISTEN</code> <code>$FFB1</code> CPB Send LISTEN command A A X C64 <code>LKUPLA</code> <code>$FF59</code> ChIO Search tables for given LA C128 <code>LKUPSA</code> <code>$FF5C</code> ChIO Search tables for given SA C128 <code>LOAD</code> <code>$FFD5</code> ChIO Load a file into main memory or VRAM A X Y A X Y C64 <code>MACPTR</code> <code>$FF44</code> CPB Read multiple bytes from the peripheral bus A X Y C A X Y P X16 <code>MCIOUT</code> <code>$FEB1</code> CPB Write multiple bytes to the peripheral bus A X Y C A X Y P X16 <code>MEMBOT</code> <code>$FF9C</code> Mem Get address of start of usable RAM C64 <code>MEMTOP</code> <code>$FF99</code> Mem Get/set number of banks and address of the end of usable RAM A X Y C64 <code>memory_copy</code> <code>$FEE7</code> Mem Copy a memory region to a different region r0 r1 r2 r2 A X Y P X16 <code>memory_crc</code> <code>$FEEA</code> Mem Calculate the CRC16 of a memory region r0 r1 r2 A X Y P X16 <code>memory_decompress</code> <code>$FEED</code> Mem Decompress an LZSA2 block r0 r1 r1 A X Y P X16 <code>memory_fill</code> <code>$FEE4</code> Mem Fill a memory region with a byte value A r0 r1 r1 X Y P X16 <code>monitor</code> <code>$FECC</code> Misc Enter machine language monitor none A X Y P X16 <code>mouse_config</code> <code>$FF68</code> Mouse Configure mouse pointer A X Y A X Y P X16 <code>mouse_get</code> <code>$FF6B</code> Mouse Get saved mouse sate X A (X) P X16 <code>mouse_scan</code> <code>$FF71</code> Mouse Poll mouse state and save it none A X Y P X16 <code>OPEN</code> <code>$FFC0</code> ChIO Open a channel/file. A X Y C64 <code>PLOT</code> <code>$FFF0</code> Video Read/write cursor position A X Y A X Y C64 <code>PRIMM</code> <code>$FF7D</code> Misc Print string following the caller\u2019s code C128 <code>RDTIM</code> <code>$FFDE</code> Time Read system clock A X Y C64 <code>READST</code> <code>$FFB7</code> ChIO Return status byte A C64 <code>SAVE</code> <code>$FFD8</code> ChIO Save a file from memory A X Y A X Y C C64 <code>SCNKEY</code> <code>$FF9F</code> Kbd Alias for <code>kbd_scan</code> none A X Y P C64 <code>SCREEN</code> <code>$FFED</code> Video Get the text resolution of the screen X Y C64 <code>screen_mode</code> <code>$FF5F</code> Video Get/set screen mode A C A X Y P X16 <code>screen_set_charset</code> <code>$FF62</code> Video Activate 8x8 text mode charset A X Y A X Y P X16 <code>SECOND</code> <code>$FF93</code> CPB Send LISTEN secondary address A A C64 <code>SETLFS</code> <code>$FFBA</code> ChIO Set file parameters (LA, FA, and SA). A X Y C64 <code>SETMSG</code> <code>$FF90</code> ChIO Set verbosity A C64 <code>SETNAM</code> <code>$FFBD</code> ChIO Set file name. A X Y C64 <code>SETTIM</code> <code>$FFDB</code> Time Write system clock A X Y A X Y C64 <code>SETTMO</code> <code>$FFA2</code> CPB Set timeout C64 <code>sprite_set_image</code> \u2020 <code>$FEF0</code> Video Set the image of a sprite r0 r1 r2L A X Y C A P X16 <code>sprite_set_position</code> <code>$FEF3</code> Video Set the position of a sprite r0 r1 A A X P X16 <code>stash</code> <code>$FF77</code> Mem Write a byte to any RAM bank stavec A X Y (stavec) X P X16 <code>STOP</code> <code>$FFE1</code> Kbd Test for STOP key A X P C64 <code>TALK</code> <code>$FFB4</code> CPB Send TALK command A A C64 <code>TKSA</code> <code>$FF96</code> CPB Send TALK secondary address A A C64 <code>UDTIM</code> <code>$FFEA</code> Time Increment the jiffies clock A X C64 <code>UNLSN</code> <code>$FFAE</code> CPB Send UNLISTEN command A C64 <code>UNTLK</code> <code>$FFAB</code> CPB Send UNTALK command A C64 <p>\ud83d\udeab = Currently unimplemented \u2020 = Partially implemented</p> <p>Some notes:</p> <ul> <li>For device #8, the Commodore Peripheral Bus calls first talk to the \"Computer DOS\" built into the ROM to detect an SD card, before falling back to the Commodore Serial Bus.</li> <li>The <code>IOBASE</code> call returns $9F00, the location of the first VIA controller.</li> <li>The <code>SETTMO</code> call has been a no-op since the Commodore VIC-20, and has no function on the X16 either.</li> <li>The layout of the zero page ($0000-$00FF) and the KERNAL/BASIC variable space ($0200+) are generally not compatible with the C64.</li> </ul> <p>The KERNAL indirect vectors ($0314-$0333) are fully compatible with the C64:</p> <p>$0314-$0315: <code>CINV</code> \u2013 IRQ Interrupt Routine $0316-$0317: <code>CBINV</code> \u2013 BRK Instruction Interrupt $0318-$0319: <code>NMINV</code> \u2013 Non-Maskable Interrupt $031A-$031B: <code>IOPEN</code> \u2013 Kernal OPEN Routine $031C-$031D: <code>ICLOSE</code> \u2013 Kernal CLOSE Routine $031E-$031F: <code>ICHKIN</code> \u2013 Kernal CHKIN Routine $0320-$0321: <code>ICKOUT</code> \u2013 Kernal CKOUT Routine $0322-$0323: <code>ICLRCH</code> \u2013 Kernal CLRCHN Routine $0324-$0325: <code>IBASIN</code> \u2013 Kernal CHRIN Routine $0326-$0327: <code>IBSOUT</code> \u2013 Kernal CHROUT Routine $0328-$0329: <code>ISTOP</code> \u2013 Kernal STOP Routine $032A-$032B: <code>IGETIN</code> \u2013 Kernal GETIN Routine $032C-$032D: <code>ICLALL</code> \u2013 Kernal CLALL Routine $0330-$0331: <code>ILOAD</code> \u2013 Kernal LOAD Routine $0332-$0333: <code>ISAVE</code> \u2013 Kernal SAVE Routine</p> <p>Additional KERNAL indirect vectors have been added as part of the KERNAL's 65C816 support</p> <p>$0334-$0335: <code>IECOP</code> - COP Instruction Interrupt Routine (emulation mode) $0336-$0337: <code>IEABORT</code> - ABORT Routine (emulation mode) $0338-$0339: <code>INIRQ</code> - IRQ Interrupt Routine (native mode) $033A-$033B: <code>INBRK</code> - BRK Instruction Interrupt Routine (native mode) $033C-$033D: <code>INNMI</code> - Non-Maskable Interrupt Routine (native mode) $033E-$033F: <code>INCOP</code> - COP Instruction Interrupt Routine (native mode) $0340-$0341: <code>INABORT</code> - ABORT Routine (native mode)</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#commodore-peripheral-bus","title":"Commodore Peripheral Bus","text":"<p>The X16 adds two new functions for dealing with the Commodore Peripheral Bus (\"IEEE\"):</p> <p>$FEB1: <code>MCIOUT</code> - write multiple bytes to peripheral bus $FF44: <code>MACPTR</code> - read multiple bytes from peripheral bus</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-acptr","title":"Function Name: ACPTR","text":"<p>Purpose: Read a byte from the peripheral bus Call address: $FFA5 Communication registers: .A Preparatory routines: <code>SETNAM</code>, <code>SETLFS</code>, <code>OPEN</code>, <code>CHKIN</code> Error returns: None Registers affected: .A .X .Y .P</p> <p>Description: This routine gets a byte of data off the peripheral bus. The data is returned in the accumulator.  Errors are returned in the status word which can be read via the <code>READST</code> API call.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-macptr","title":"Function Name: MACPTR","text":"<p>Purpose: Read multiple bytes from the peripheral bus Call address: $FF44 Communication registers: .A .X .Y c Preparatory routines: <code>SETNAM</code>, <code>SETLFS</code>, <code>OPEN</code>, <code>CHKIN</code> Error returns: None Registers affected: .A .X .Y</p> <p>Description: The routine <code>MACPTR</code> is the multi-byte variant of the <code>ACPTR</code> KERNAL routine. Instead of returning a single byte in .A, it can read multiple bytes in one call and write them directly to memory.</p> <p>The number of bytes to be read is passed in the .A register; a value of 0 indicates that it is up to the KERNAL to decide how many bytes to read. A pointer to where the data is supposed to be written is passed in the .X (lo) and .Y (hi) registers. If carry flag is clear, the destination address will advance with each byte read. If the carry flag is set, the destination address will not advance as data is read. This is useful for reading data directly into VRAM, PCM FIFO, etc.</p> <p>For reading into Hi RAM, you must set the desired bank prior to calling <code>MACPTR</code>. During the read, <code>MACPTR</code> will automatically wrap to the next bank as required, leaving the new bank active when finished.</p> <p>Upon return, a set c flag indicates that the device or file does not support <code>MACPTR</code>, and the program needs to read the data byte-by-byte using the <code>ACPTR</code> call instead.</p> <p>If <code>MACPTR</code> is supported, c is clear and .X (lo) and .Y (hi) contain the number of bytes read. It is possible that this is less than the number of bytes requested to be read! (But is always greater than 0)</p> <p>Like with <code>ACPTR</code>, the status of the operation can be retrieved using the <code>READST</code> KERNAL call.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-mciout","title":"Function Name: MCIOUT","text":"<p>Purpose: Write multiple bytes to the peripheral bus Call address: $FEB1 Communication registers: .A .X .Y c Preparatory routines: <code>SETNAM</code>, <code>SETLFS</code>, <code>OPEN</code>, <code>CHKOUT</code> Error returns: None Registers affected: .A .X .Y</p> <p>Description: The routine <code>MCIOUT</code> is the multi-byte variant of the <code>CIOUT</code> KERNAL routine. Instead of writing a single byte, it can write multiple bytes from memory in one call.</p> <p>The number of bytes to be written is passed in the .A register; a value of 0 indicates 256 bytes. A pointer to the data to be read from is passed in the .X (lo) and .Y (hi) registers. If carry flag is clear, the source address will advance with each byte read out. If the carry flag is set, the source address will not advance as data is read out. This is useful for saving data directly from VRAM.</p> <p>For reading from Hi RAM, you must set the desired bank prior to calling <code>MCIOUT</code>. During the operation, <code>MCIOUT</code> will automatically wrap to the next bank as required, leaving the new bank active when finished.</p> <p>Upon return, a set c flag indicates that the device or file does not support <code>MCIOUT</code>, and the program needs to write the data byte-by-byte using the <code>CIOUT</code> call instead.</p> <p>If <code>MCIOUT</code> is supported, c is clear and .X (lo) and .Y (hi) contain the number of bytes written. It is possible that this is less than the number of bytes requested to be written! (But is always greater than 0)</p> <p>Like with <code>CIOUT</code>, the status of the operation can be retrieved using the <code>READST</code> KERNAL call.  If an error occurred, <code>READST</code> should return nonzero.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#channel-io","title":"Channel I/O","text":""},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-bsave","title":"Function Name: <code>BSAVE</code>","text":"<p>Purpose: Save an area of memory to a file without writing an address header. Call Address: $FEBA Communication Registers: .A .X .Y Preparatory routines: SETNAM, SETLFS Error returns: c = 0 if no error, c = 1 in case of error and A will contain kernel error code Registers affected: .A .X .Y .P</p> <p>Description: Save the contents of a memory range to a file.  Unlike <code>SAVE</code>, this call does not write the start address to the beginning of the output file.</p> <p><code>SETLFS</code> and <code>SETNAM</code> must be called beforehand. A is address of zero page pointer to the start address. X and Y contain the exclusive end address to save. That is, these should contain the address immediately after the final byte:  X = low byte, Y = high byte. Upon return, if C is clear, there were no errors.  C being set indicates an error in which case A will have the error number.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-close","title":"Function Name: <code>CLOSE</code>","text":"<p>Purpose: Close a logical file Call address: $FFC3 Communication registers: .A Preparatory routines: None Error returns: None Registers affected: .A .X .Y .P</p> <p>Description: <code>CLOSE</code> releases resources associated with a logical file number.  If the associated device is a serial device on the IEC bus or is a simulated serial device such as CMDR-DOS backed by the X16 SD card, and the file was opened with a secondary address, a close command is sent to the device or to CMDR-DOS.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-load","title":"Function Name: <code>LOAD</code>","text":"<p>Purpose: Load the contents of a file from disk to memory Call address: $FFD5 Communication registers: .A .X .Y Preparatory routines: SETNAM, SETLFS Error returns: None Registers affected: .A .X .Y .P</p> <p>Description: Loads a file from disk to memory.</p> <p>The behavior of <code>LOAD</code> can be modified by parameters passed to prior call to <code>SETLFS</code>.  In particular, the .Y register, which usually denotes the secondary address, has a specific meaning as follows:</p> <ul> <li>.Y = 0: load to the address given in .X/.Y to the <code>LOAD</code> call, skipping the first two bytes of the file. (like <code>LOAD \"FILE\",8</code> in BASIC)</li> <li>.Y = 1: load to the address given by the first two bytes of the file. The address in .X/.Y is ignored. (like <code>LOAD \"FILE\",8,1</code> in BASIC)</li> <li>.Y = 2: load the entire file to the address given in .X/.Y to the <code>LOAD</code> call. This is also known as a headerless load. (like <code>BLOAD \"FILE\",8,1,$A000</code> in BASIC)</li> </ul> <p>For the <code>LOAD</code> call itself, .X and .Y is the memory address to load the file into. .A controls where the file is to be loaded. On the X16, <code>LOAD</code> has an additional feature to load the contents of a file directly into VRAM.</p> <ul> <li>If the A register is zero, the kernal loads into system memory.</li> <li>If the A register is 1, the kernal performs a verify.</li> <li>If the A register is 2, the kernal loads into VRAM, starting from $00000 + the specified starting address.</li> <li>If the A register is 3, the kernal loads into VRAM, starting from $10000 + the specified starting address.</li> </ul> <p>(On the C64, if A is greater than or equal to 1, the kernal performs a verify)</p> <p>For loads into the banked RAM area. The current RAM bank (in location <code>$00</code>) is used as the start point for the load along with the supplied address. If the load is large enough to advance to the end of banked RAM (<code>$BFFF</code>), the RAM bank is automatically advanced, and the load continues into the next bank starting at <code>$A000</code>.</p> <p>After the load, if c is set, an error occurred and .A will contain the error code. If c is clear, .X/.Y will point to the address of final byte loaded + 1.</p> <p>Note: One does not need to call <code>CLOSE</code> after <code>LOAD</code>.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-open","title":"Function Name: <code>OPEN</code>","text":"<p>Purpose: Opens a channel/file Call address: $FFC0 Communication registers: None Preparatory routines: SETNAM, SETLFS Error returns: None Registers affected: .A .X .Y</p> <p>Description: Opens a file or channel. The most common pattern is to then redirect the standard input or output to the file using <code>CHKIN</code> or <code>CHKOUT</code> respectively. Afterwards, I/O from or to the file or channel is done using <code>BASIN</code> (<code>CHRIN</code>) and <code>BSOUT</code> (<code>CHROUT</code>) respectively.</p> <p>For file I/O, the lower level calls <code>ACPTR</code> and <code>MACPTR</code> can be used in place of <code>CHRIN</code>, since <code>CHKIN</code> does the low-level setup for this.  Likewise <code>CIOUT</code> and <code>MCIOUT</code> can be used after <code>CHKOUT</code> for the same reason.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-save","title":"Function Name: <code>SAVE</code>","text":"<p>Purpose: Save an area of memory to a file. Call Address: $FFD8 Communication Registers: .A .X .Y Preparatory routines: SETNAM, SETLFS Error returns: c = 0 if no error, c = 1 in case of error and A will contain kernel error code Registers affected: .A .X .Y .P</p> <p>Description: Save the contents of a memory range to a file. The (little-endian) start address is written to the file as the first two bytes of output, followed by the requested data.</p> <p><code>SETLFS</code> and <code>SETNAM</code> must be called beforehand. A is address of zero page pointer to start address. X = low byte of end address + 1, Y = high byte of end address. If C is zero there were no errors; 1 is an error in which case A will have the error</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-setlfs","title":"Function Name: <code>SETLFS</code>","text":"<p>Purpose: Set file parameters Call Address: $FFBA Communication Registers: .A .X .Y Preparatory routines: SETNAM Error returns: None Registers affected: .A .X .Y</p> <p>Description: Set file parameters typically after calling SETNAM</p> <p>A is the logical file number, X is the device number, and Y is the secondary address.</p> <p>Since multiple files can be open (with some exceptions), the value of A specifies the file number. If only one file is being opened at a time, $01 can be used.</p> <p>The device number corresponds to the hardware device where the file lives. On the X16, $08 would be the SD card.</p> <p>The secondary address has some special meanings:</p> <p>When used with <code>OPEN</code> on disk type devices, the following applies:</p> <ul> <li>0 = Load (open for read)</li> <li>1 = Save (open for write)</li> <li>2-14 = Read mode, by default. Write, Append, and Modify modes can be specified in the SETNAM filename string as the third argument, e.g. <code>\"FILE.DAT,S,W\"</code> for write mode. The seek command \"P\" is available in any mode.</li> <li>15 = Command Channel (for sending special commands to CMDR-DOS or the disk device)</li> </ul> <p>When used with <code>LOAD</code> the following applies:</p> <ul> <li>0 = Load the data to address specified in the X and Y register of the LOAD call, regardless of the address header. The two-byte header itself is not loaded into RAM.</li> <li>1 = Load to the address specified in the file's header. The two-byte header itself is not loaded into RAM.</li> <li>2 = Load the data to address specified in the X and Y register of the LOAD call. The entire file is loaded (\"headerless\").</li> </ul> <p>For more information see Chapter 13: Working with CMDR-DOS</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-setnam","title":"Function Name: <code>SETNAM</code>","text":"<p>Purpose: Set file name Call Address: $FFBD Communication Registers: .A .X .Y Preparatory routines: SETLFS Error returns: None Registers affected: .A .X .Y</p> <p>Description: Inform the kernal the name of the file that is to later be opened.  A is filename length, X is low byte of filename pointer, Y is high byte of filename pointer.</p> <p>For example:</p> <pre><code>  lda #$08\n  ldx #&lt;filename\n  ldy #&gt;filename\n  jsr SETNAM\n</code></pre> <p><code>SETLFS</code> and <code>SETNAM</code> both need to be called prior other file comamnds, such as <code>OPEN</code> or <code>SAVE</code>.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#memory","title":"Memory","text":"<p>$FEE4: <code>memory_fill</code> - fill memory region with a byte value $FEE7: <code>memory_copy</code> - copy memory region $FEEA: <code>memory_crc</code> - calculate CRC16 of memory region $FEED: <code>memory_decompress</code> - decompress LZSA2 block $FF74: <code>fetch</code> - read a byte from any RAM or ROM bank $FF77: <code>stash</code> - write a byte to any RAM bank $FF99: <code>MEMTOP</code> - get number of banks and address of end of usable RAM</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-memory_fill","title":"Function Name: memory_fill","text":"<p>Signature: void memory_fill(word address: r0, word num_bytes: r1, byte value: .A); Purpose: Fill a memory region with a byte value. Call address: $FEE4</p> <p>Description: This function fills the memory region specified by an address (r0) and a size in bytes (r1) with the constant byte value passed in .A. r0 and .A are preserved, r1 is destroyed.</p> <p>If the target address is in the $9F00-$9FFF range, all bytes will be written to the same address (r0), i.e. the address will not be incremented. This is useful for filling VERA memory ($9F23 or $9F24), for example.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-memory_copy","title":"Function Name: memory_copy","text":"<p>Signature: void memory_copy(word source: r0, word target: r1, word num_bytes: r2); Purpose: Copy a memory region to a different region. Call address: $FEE7</p> <p>Description: This function copies one memory region specified by an address (r0) and a size in bytes (r2) to a different region specified by its start address (r1). The two regions may overlap. r0 and r1 are preserved, r2 is destroyed.</p> <p>Like with <code>memory_fill</code>, source and destination addresses in the $9F00-$9FFF range will not be incremented during the copy. This allows, for instance, uploading data from RAM to VERA (destination of $9F23 or $9F24), downloading data from VERA (source $9F23 or $9F24) or copying data inside VERA (source $9F23, destination $9F24). This functionality can also be used to upload, download or transfer data with other I/O devices that have an 8 bit data port.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-memory_crc","title":"Function Name: memory_crc","text":"<p>Signature: (word result: r2) memory_crc(word address: r0, word num_bytes: r1); Purpose: Calculate the CRC16 of a memory region. Call address: $FEEA</p> <p>Description: This function calculates the CRC16 checksum of the memory region specified by an address (r0) and a size in bytes (r1). The result is returned in r2. r0 is preserved, r1 is destroyed.</p> <p>Like <code>memory_fill</code>, this function does not increment the address if it is in the range of $9F00-$9FFF, which allows checksumming VERA memory or data streamed from any other I/O device.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-memory_decompress","title":"Function Name: memory_decompress","text":"<p>Signature: void memory_decompress(word input: r0, inout word output: r1); Purpose: Decompress an LZSA2 block Call address: $FEED</p> <p>Description: This function decompresses an LZSA2-compressed data block from the location passed in r0 and outputs the decompressed data at the location passed in r1. After the call, r1 will be updated with the location of the last output byte plus one.</p> <p>If the target address is in the $9F00-$9FFF range, all bytes will be written to the same address (r0), i.e. the address will not be incremented. This is useful for decompressing directly into VERA memory ($9F23 or $9F24), for example. Note that decompressing from I/O is not supported.</p> <p>Notes:</p> <ul> <li>To create compressed data, use the <code>lzsa</code> tool^1 like this: <code>lzsa -r -f2 &lt;original_file&gt; &lt;compressed_file&gt;</code></li> <li>If using the LZSA library to compress data, make sure to use format 2 and include the raw blocks flag, which is what the above command does.</li> <li>This function cannot be used to decompress data in-place, as the output data would overwrite the input data before it is consumed. Therefore, make sure to load the input data to a different location.</li> <li>It is possible to have the input data stored in banked RAM, with the obvious 8 KB size restriction.</li> </ul>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-fetch","title":"Function Name: fetch","text":"<p>Purpose: Read a byte from any RAM or ROM bank Call address: $FF74 Communication registers: .A .X .Y .P</p> <p>Description: This function performs an <code>LDA (ZP),Y</code> from any RAM or ROM bank. The the zero page address containing the base address is passed in .A, the bank in .X and the offset from the vector in .Y. The data byte is returned in .A. The flags are set according to .A, .X is destroyed, but .Y is preserved.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-stash","title":"Function Name: stash","text":"<p>Purpose: Write a byte to any RAM bank Call address: $FF77 Communication registers: .A .X .Y</p> <p>Description: This function performs an <code>STA (ZP),Y</code> to any RAM bank. The the zero page address containing the base address is passed in <code>stavec</code> ($03B2), the bank in .X and the offset from the vector in .Y. After the call, .X is destroyed, but .A and .Y are preserved.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-memtop","title":"Function Name: MEMTOP","text":"<p>Purpose: Get/Set top of RAM, number of usable RAM banks. Call address: $FF99 Communication registers: .A .X .Y .P (Carry) Registers affected: .A .X .Y</p> <p>Description: Original C64 function which gets or sets the top of the usable address in RAM. On the X16, it additionally provides the number of RAM banks available on the system and can even be used to set this value after boot if desired.</p> <p>To set the top of RAM, and the number of available banks, clear the carry flag.</p> <p>To get the top of RAM and the number of available banks, set carry flag.</p> <p>Note that the number of RAM banks is for informational purposes or for use by other programs. The KERNAL does not use this value itself.</p> <p>Getting the number of usable RAM banks:</p> <p>On the X16, calling MEMTOP with the carry flag set will return the number of available RAM banks on the system in A. For example:</p> <pre><code>  sec\n  jsr MEMTOP\n  sta zp_NUM_BANKS\n</code></pre> <p>If the system has 512k of banked RAM, zp_NUM_BANKS will contain $40 (64). For 1024k, $80; for 1536k, $C0. For 2048k, the result will be $00 (which can be thought of as $100, or 256). It is possible to have other values (e.g. $42), such as if the system has bad banked RAM.</p> <p>Setting the top of BASIC RAM</p> <p>This routine changes the top of memory, allowing you to save a small machine language routine at the top of BASIC RAM, just below the I/O space:</p> <pre><code>10 POKE$30F,1:SYS$FF99\n20 Y=$8C:X=$00\n30 POKE$30D,X:POKE$30E,Y:POKE$30F,0:SYS$FF99\n40 CLR\n</code></pre> <p>Analysis:</p> <p>The SYS command uses memory locations $30C-$30F to pre-load the CPU registers, it then dumps the registers back to these locations after the SYS call is complete. $30D is the X register, $30E is .Y, and $30F is the flags. The Carry flag is bit 0, so setting $30F to 1 before calling MEMTOP indicates that this is a read of the values.</p> <ol> <li>Line 10 reads the current values. Do this to preserve the extended RAM bank    count.</li> <li>Line 20 uses the X and Y variables to make the code easier to read. Set Y to    the high byte of the address and X to the low byte.</li> <li>Line 30 POKEs those values in, clears the Carry bit ($30F is now 0), and    calls MEMTOP again.</li> <li>Finally, use CLR to lock in the new values. Since this clears all the    variables, you should probably do this at the top of your program.</li> </ol> <p>The address entered is actually the first byte of free space after your BASIC program space, so if you set MEMTOP to $9C00, then you can start your assembly program at $9C00 with <code>* = $9C00</code> or <code>org $9c00</code>.</p> <p>To reserve 256 bytes, set X to $9E. To reserve 1KB, set X to $9C. To return to the default values, set Y=$9F and X=0.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#clock","title":"Clock","text":"<p>$FF4D: <code>clock_set_date_time</code> - set date and time $FF50: <code>clock_get_date_time</code> - get date and time</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-clock_set_date_time","title":"Function Name: clock_set_date_time","text":"<p>Purpose: Set the date and time Call address: $FF4D Communication registers: r0 r1 r2 r3 Preparatory routines: None Error returns: None Registers affected: .A .X .Y</p> <p>Description: The routine <code>clock_set_date_time</code> sets the system's real-time-clock.</p> Register Contents r0L year (1900-based) r0H month (1-12) r1L day (1-31) r1H hours (0-23) r2L minutes (0-59) r2H seconds (0-59) r3L jiffies (0-59) r3H weekday (0-6) <p>Jiffies are 1/60th seconds.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-clock_get_date_time","title":"Function Name: clock_get_date_time","text":"<p>Purpose: Get the date and time Call address: $FF50 Communication registers: r0 r1 r2 r3 Preparatory routines: None Error returns: None Registers affected: .A .X .Y</p> <p>Description: The routine <code>clock_get_date_time</code> returns the state of the system's real-time-clock. The register assignment is identical to <code>clock_set_date_time</code>.</p> <p>On the Commander X16, the jiffies field is unsupported and will always read back as 0.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-rdtim","title":"Function Name: RDTIM","text":"<p>Purpose: Read system clock Call address: $FFDE Communication registers: .A .X .Y Preparatory routines: None Error returns: None Registers affected: .A .X .Y</p> <p>Description: Original C64 function which reads the system clock.  The clock's resolution is a 60th of a second.  Three bytes are returned by the routine.  The accumulator contains the least significant byte, the X index register contains the next most significant byte, and the Y index register contains the the most significant byte.</p> <p>The behavior of this Kernal routine is the same on the X16 and C64 despite errors in the Commodore 64 Programmer's Reference Guide and some other period books which incorrectly describe the order/significance of the resulting bytes in the registers.</p> <p>EXAMPLE:</p> <pre><code>jsr RDTIM\nsta STARTTIME    ; least significant byte\nstx STARTTIME+1\nsty STARTTIME+2  ; most significant byte\n</code></pre>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#keyboard","title":"Keyboard","text":"<p>$FEBD: <code>kbdbuf_peek</code> - get first char in keyboard queue and queue length $FEC0: <code>kbdbuf_get_modifiers</code> - get currently pressed modifiers $FEC3: <code>kbdbuf_put</code> - append a char to the keyboard queue $FED2: <code>keymap</code> - set or get the current keyboard layout</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-kbdbuf_peek","title":"Function Name: kbdbuf_peek","text":"<p>Purpose: Get next char and keyboard queue length Call address: $FEBD Communication registers: .A .X Preparatory routines: None Error returns: None Registers affected: -</p> <p>Description: The routine <code>kbdbuf_peek</code> returns the next character in the keyboard queue in .A, without removing it from the queue, and the current length of the queue in .X. If .X is 0, the Z flag will be set, and the value of .A is undefined.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-kbdbuf_get_modifiers","title":"Function Name: kbdbuf_get_modifiers","text":"<p>Purpose: Get currently pressed modifiers Call address: $FEC0 Communication registers: .A Preparatory routines: None Error returns: None Registers affected: -</p> <p>Description: The routine <code>kbdbuf_get_modifiers</code> returns a bitmask that represents the currently pressed modifier keys in .A:</p> Bit Value Description Comment 0 1 Shift 1 2 Alt C64: Commodore 2 4 Control 3 8 Logo/Windows C128: Alt 4 16 Caps <p>This allows detecting combinations of a regular key and a modifier key in cases where there is no dedicated PETSCII code for the combination, e.g. Ctrl+Esc or Alt+F1.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-kbdbuf_put","title":"Function Name: kbdbuf_put","text":"<p>Purpose: Append a char to the keyboard queue Call address: $FEC3 Communication registers: .A Preparatory routines: None Error returns: None Registers affected: .X</p> <p>Description: The routine <code>kbdbuf_put</code> appends the char in .A to the keyboard queue.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-keymap","title":"Function Name: keymap","text":"<p>Purpose: Set or get the current keyboard layout Call address: $FED2 Communication registers: .X .Y Preparatory routines: None Error returns: c = 1 in case of error Registers affected: -</p> <p>Description: If c is set, the routine <code>keymap</code> returns a pointer to a zero-terminated string with the current keyboard layout identifier in .X/.Y. If c is clear, it sets the keyboard layout to the zero-terminated identifier pointed to by .X/.Y. On return, c is set in case the keyboard layout is unsupported.</p> <p>Keyboard layout identifiers are in the form \"DE\", \"DE-CH\" etc.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-kbd_scan","title":"Function Name: kbd_scan","text":"<p>Also Known As: SCNKEY Purpose: Read a keycode previously fetched from the SMC, apply keymap localization, and add it to the X16's buffer. Call address: $FF9F Communication registers: None Preparatory routines: <code>ps2data_fetch</code> Error returns: None Registers affected: .A .X .Y</p> <p>Description:</p> <p>This routine is called by the default KERNAL IRQ hancler in order to process a keystroke previously fetched by <code>ps2data_fetch</code>, translate it to the appropriate localized PETSCII or ISO code based on the configured layout, and place it in the KERNAL's keyboard buffer.</p> <p>Unless the KERNAL IRQ handler is being bypassed or supplemented, it is not normally necessary to call this routine from user code, as both <code>ps2data_fetch</code> and <code>kbd_scan</code> are both run inside the default IRQ handler.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#mouse","title":"Mouse","text":"<p>$FF68: <code>mouse_config</code> - configure mouse pointer $FF71: <code>mouse_scan</code> - query mouse $FF6B: <code>mouse_get</code> - get state of mouse</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-mouse_config","title":"Function Name: mouse_config","text":"<p>Purpose: Configure the mouse pointer Call address: $FF68 Communication registers: .A .X .Y Preparatory routines: None Error returns: None Registers affected: .A .X .Y</p> <p>Description: The routine <code>mouse_config</code> configures the mouse pointer.</p> <p>The argument in .A specifies whether the mouse pointer should be visible or not, and what shape it should have. For a list of possible values, see the basic statement <code>MOUSE</code>.</p> <p>The arguments in .X and .Y specify the screen resolution in 8 pixel increments. The values .X = 0 and .Y = 0 keep the current resolution.</p> <p>EXAMPLE:</p> <p>SEC  JSR screen_mode ; get current screen size (in 8px) into .X and .Y  LDA #1  JSR mouse_config ; show the default mouse pointer</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-mouse_scan","title":"Function Name: mouse_scan","text":"<p>Purpose: Query the mouse and save its state Call address: $FF71 Communication registers: None Preparatory routines: None Error returns: None Registers affected: .A .X .Y</p> <p>Description: The routine <code>mouse_scan</code> retrieves all state from the mouse and saves it. It can then be retrieved using <code>mouse_get</code>. The default interrupt handler already takes care of this, so this routine should only be called if the interrupt handler has been completely replaced.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-mouse_get","title":"Function Name: mouse_get","text":"<p>Purpose: Get the mouse state Call address: $FF6B Communication registers: .X Preparatory routines: <code>mouse_config</code> Error returns: None Registers affected: .A .X</p> <p>Description: The routine <code>mouse_get</code> returns the state of the mouse. The caller passes the offset of a zero-page location in .X, which the routine will populate with the mouse position in 4 consecutive bytes:</p> Offset Size Description 0 2 X Position 2 2 Y Position <p>The state of the mouse buttons is returned in the .A register:</p> Bit Description 0 Left Button 1 Right Button 2 Middle Button 3 Unused 4 Button 4 5 Button 5 <p>If a button is pressed, the corresponding bit is set. Buttons 4 and 5 are extended buttons not supported by all mice.</p> <p>If available, the movement of the scroll wheel since the last call to this function is returned in the .X register as an 8-bit signed value. Moving the scroll wheel away from the user is represented by a negative value, and moving it towards the user is represented by a positive value. If the connected mouse has no scroll wheel, the value 0 is returned in the .X register.</p> <p>EXAMPLE:</p> <pre><code>LDX #$70\nJSR mouse_get ; get mouse position in $70/$71 (X) and $72/$73 (Y)\nAND #1\nBNE BUTTON_PRESSED\n</code></pre>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#joystick","title":"Joystick","text":"<p>$FF53: <code>joystick_scan</code> - query joysticks $FF56: <code>joystick_get</code> - get state of one joystick</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-joystick_scan","title":"Function Name: joystick_scan","text":"<p>Purpose: Query the joysticks and save their state Call address: $FF53 Communication registers: None Preparatory routines: None Error returns: None Registers affected: .A .X .Y</p> <p>Description: The routine <code>joystick_scan</code> retrieves all state from the four joysticks and saves it. It can then be retrieved using <code>joystick_get</code>. The default interrupt handler already takes care of this, so this routine should only be called if the interrupt handler has been completely replaced.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-joystick_get","title":"Function Name: joystick_get","text":"<p>Purpose: Get the state of one of the joysticks Call address: $FF56 Communication registers: .A Preparatory routines: <code>joystick_scan</code> Error returns: None Registers affected: .A .X .Y</p> <p>Description: The routine <code>joystick_get</code> retrieves all state from one of the joysticks. The number of the joystick is passed in .A (0 for the keyboard joystick and 1 through 4 for SNES controllers), and the state is returned in .A, .X and .Y.</p> <pre><code>      .A, byte 0:      | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |\n                  SNES | B | Y |SEL|STA|UP |DN |LT |RT |\n\n      .X, byte 1:      | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |\n                  SNES | A | X | L | R | 1 | 1 | 1 | 1 |\n      .Y, byte 2:\n                  $00 = joystick present\n                  $FF = joystick not present\n</code></pre> <p>If a button is pressed, the corresponding bit is zero.</p> <p>(With a dedicated handler, the API can also be used for other devices with an SNES controller connector. The data returned in .A/.X/Y is just the raw 24 bits returned by the device.)</p> <p>The keyboard joystick uses the standard SNES9X/ZSNES mapping:</p> SNES Button Keyboard Key Alt. Keyboard Key A X Left Ctrl B Z Left Alt X S Y A L D R C START Enter SELECT Left Shift D-Pad Cursor Keys <p>Note that the keyboard joystick will allow LEFT and RIGHT as well as UP and DOWN to be pressed at the same time, while controllers usually prevent this mechanically.</p> <p>How to Use:</p> <p>If the default interrupt handler is used:</p> <p>1) Call this routine.</p> <p>If the default interrupt handler is disabled or replaced:</p> <p>1) Call <code>joystick_scan</code> to have the system query the joysticks. 2) Call this routine.</p> <p>EXAMPLE:</p> <pre><code>      JSR joystick_scan\n      LDA #0\n      JSR joystick_get\n      TXA\n      AND #128\n      BEQ A_PRESSED\n</code></pre>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#i2c","title":"I2C","text":"<p>$FEB4: <code>i2c_batch_read</code> - read multiple bytes from an I2C device $FEB7: <code>i2c_batch_write</code> - write multiple bytes to an I2C device $FEC6: <code>i2c_read_byte</code> - read a byte from an I2C device $FEC9: <code>i2c_write_byte</code> - write a byte to an I2C device</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-i2c_batch_read","title":"Function Name: i2c_batch_read","text":"<p>Purpose: Read bytes from a given I2C device into a RAM location Call address: $FEB4 Communication registers: .X r0 r1 c Preparatory routines: None Error returns: c = 1 in case of error Registers affected: .A .Y .P</p> <p>Description: The routine <code>i2c_batch_read</code> reads a fixed number of bytes from an I2C device into RAM.  To call, put I2C device (address) in .X, the pointer to the RAM location to which to place the data into r0, and the number of bytes to read into r1.  If carry is set, the RAM location isn't advanced.  This might be useful if you're reading from an I2C device and writing directly into VRAM.</p> <p>If the routine encountered an error, carry will be set upon return.</p> <p>EXAMPLE:</p> <pre><code>ldx #$50 ; One of the cartridge I2C flash devices\nlda #&lt;$0400\nsta r0\nlda #&gt;$0400\nsta r0+1\nlda #&lt;500\nsta r1\nlda #&gt;500\nsta r1+1\nclc\njsr i2c_batch_read ; read 500 bytes from I2C device $50 into RAM starting at $0400\n</code></pre>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-i2c_batch_write","title":"Function Name: i2c_batch_write","text":"<p>Purpose: Write bytes to a given I2C device with data in RAM Call address: $FEB7 Communication registers: .X r0 r1 r2 c Preparatory routines: None Error returns: c = 1 in case of error Registers affected: .A .Y .P r2</p> <p>Description: The routine <code>i2c_batch_write</code> writes a fixed number of bytes from RAM to an I2C device.  To call, put I2C device (address) in .X, the pointer to the RAM location from which to read into r0, and the number of bytes to write into r1.  If carry is set, the RAM location isn't advanced.  This might be useful if you're reading from an I/O device and writing that data to an I2C device.</p> <p>The number of bytes written is returned in r2. If the routine encountered an error, carry will be set upon return.</p> <p>EXAMPLE:</p> <pre><code>ldx #$50 ; One of the cartridge I2C flash devices\nlda #&lt;$0400\nsta r0\nlda #&gt;$0400\nsta r0+1\nlda #&lt;500\nsta r1\nlda #&gt;500\nsta r1+1\nclc\njsr i2c_batch_write ; write 500 bytes to I2C device $50 from RAM\n                    ; starting at $0400\n                    ; for this example, the first two bytes in\n                    ; the $0400 buffer would be the target address\n                    ; in the I2C flash. This, of course, varies\n                    ; between various I2C device types.\n</code></pre>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-i2c_read_byte","title":"Function Name: i2c_read_byte","text":"<p>Purpose: Read a byte at a given offset from a given I2C device Call address: $FEC6 Communication registers: .A .X .Y Preparatory routines: None Error returns: c = 1 in case of error Registers affected: .A</p> <p>Description: The routine <code>i2c_read_byte</code> reads a single byte at offset .Y from I2C device .X and returns the result in .A. c is 0 if the read was successful, and 1 if no such device exists.</p> <p>EXAMPLE:</p> <pre><code>LDX #$6F ; RTC device\nLDY #$20 ; start of NVRAM inside RTC\nJSR i2c_read_byte ; read first byte of NVRAM\n</code></pre>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-i2c_write_byte","title":"Function Name: i2c_write_byte","text":"<p>Purpose: Write a byte at a given offset to a given I2C device Call address: $FEC9 Communication registers: .A .X .Y Preparatory routines: None Error returns: c = 1 in case of error Registers affected: .A .P</p> <p>Description: The routine <code>i2c_write_byte</code> writes the byte in .A at offset .Y of I2C device .X. c is 0 if the write was successful, and 1 if no such device exists.</p> <p>EXAMPLES:</p> <pre><code>LDX #$6F ; RTC device\nLDY #$20 ; start of NVRAM inside RTC\nLDA #'X'\nJSR i2c_write_byte ; write first byte of NVRAM\n\nLDX #$42 ; System Management Controller\nLDY #$01 ; magic location for system poweroff\nLDA #$00 ; magic value for system poweroff\nJSR i2c_write_byte ; power off the system\n\n; Reset system at the end of your program\nLDX #$42  ; System Management Controller\nLDY #$02  ; magic location for system reset\nLDA #$00  ; magic value for system poweroff/reset\nJSR $FEC9 ; reset the computer\n</code></pre>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#sprites","title":"Sprites","text":"<p>$FEF0: <code>sprite_set_image</code> - set the image of a sprite $FEF3: <code>sprite_set_position</code> - set the position of a sprite</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-sprite_set_image","title":"Function Name: sprite_set_image","text":"<p>Purpose: Set the image of a sprite Call address: $FEF0 Signature: bool sprite_set_image(byte number: .A, width: .X, height: .Y, apply_mask: c, word pixels: r0, word mask: r1, byte bpp: r2L); Error returns: c = 1 in case of error</p> <p>Description: This function sets the image of a sprite. The number of the sprite is given in .A, The bits per pixel (bpp) in r2L, and the width and height in .X and .Y. The pixel data at r0 is interpreted accordingly and converted into the graphics hardware's native format. If the c flag is set, the transparency mask pointed to by r1 is applied during the conversion. The function returns c = 0 if converting the data was successful, and c = 1 otherwise. Note that this does not change the visibility of the sprite.</p> <p>Note: There are certain limitations on the possible values of width, height, bpp and apply_mask:</p> <ul> <li>width and height may not exceed the hardware's capabilities.</li> <li>Legal values for bpp are 1, 4 and 8. If the hardware only supports lower depths, the image data is converted down.</li> <li>apply_mask is only valid for 1 bpp data.</li> </ul>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-sprite_set_position","title":"Function Name: sprite_set_position","text":"<p>Purpose: Set the position of a sprite or hide it. Call address: $FEF3 Signature: void sprite_set_position(byte number: .A, word x: r0, word y: r1); Error returns: None</p> <p>Description: This function shows a given sprite (.A) at a certain position or hides it. The position is passed in r0 and r1. If the x position is negative (&gt;$8000), the sprite will be hidden.</p> <p>Note: This routine only supports setting the position for sprite numbers 0-31.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#framebuffer","title":"Framebuffer","text":"<p>The framebuffer API is a low-level graphics API that completely abstracts the framebuffer by exposing a minimal set of high-performance functions. It is useful as an abstraction and as a convenience library for applications that need high performance framebuffer access.</p> <pre><code>$FEF6: `FB_init` - enable graphics mode\n$FEF9: `FB_get_info` - get screen size and color depth\n$FEFC: `FB_set_palette` - set (parts of) the palette\n$FEFF: `FB_cursor_position` - position the direct-access cursor\n$FF02: `FB_cursor_next_line` - move direct-access cursor to next line\n$FF05: `FB_get_pixel` - read one pixel, update cursor\n$FF08: `FB_get_pixels` - copy pixels into RAM, update cursor\n$FF0B: `FB_set_pixel` - set one pixel, update cursor\n$FF0E: `FB_set_pixels` - copy pixels from RAM, update cursor\n$FF11: `FB_set_8_pixels` - set 8 pixels from bit mask (transparent), update cursor\n$FF14: `FB_set_8_pixels_opaque` - set 8 pixels from bit mask (opaque), update cursor\n$FF17: `FB_fill_pixels` - fill pixels with constant color, update cursor\n$FF1A: `FB_filter_pixels` - apply transform to pixels, update cursor\n$FF1D: `FB_move_pixels` - copy horizontally consecutive pixels to a different position\n</code></pre> <p>All calls are vectored, which allows installing a replacement framebuffer driver.</p> <pre><code>$02E4: I_FB_init\n$02E6: I_FB_get_info\n$02E8: I_FB_set_palette\n$02EA: I_FB_cursor_position\n$02EC: I_FB_cursor_next_line\n$02EE: I_FB_get_pixel\n$02F0: I_FB_get_pixels\n$02F2: I_FB_set_pixel\n$02F4: I_FB_set_pixels\n$02F6: I_FB_set_8_pixels\n$02F8: I_FB_set_8_pixels_opaque\n$02FA: I_FB_fill_pixels\n$02FC: I_FB_filter_pixels\n$02FE: I_FB_move_pixels\n</code></pre> <p>The model of this API is based on the direct-access cursor. In order to read and write pixels, the cursor has to be set to a specific x/y-location, and all subsequent calls will access consecutive pixels at the cursor position and update the cursor.</p> <p>The default driver supports the VERA framebuffer at a resolution of 320x200 pixels and 256 colors. Using <code>screen_mode</code> to set mode $80 will enable this driver.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-fb_init","title":"Function Name: FB_init","text":"<p>Signature: void FB_init(); Purpose: Enter graphics mode.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-fb_get_info","title":"Function Name: FB_get_info","text":"<p>Signature: void FB_get_info(out word width: r0, out word height: r1, out byte color_depth: .A); Purpose: Return the resolution and color depth</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-fb_set_palette","title":"Function Name: FB_set_palette","text":"<p>Signature: void FB_set_palette(word pointer: r0, index: .A, color count: .X); Purpose: Set (parts of) the palette</p> <p>Description: <code>FB_set_palette</code> copies color data from the address pointed to by r0, updates the color in VERA palette RAM starting at the index A, with the length of the update (in words) in X.  If X is 0, all 256 colors are copied (512 bytes)</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-fb_cursor_position","title":"Function Name: FB_cursor_position","text":"<p>Signature: void FB_cursor_position(word x: r0, word y: r1); Purpose: Position the direct-access cursor</p> <p>Description: <code>FB_cursor_position</code> sets the direct-access cursor to the given screen coordinate. Future operations will access pixels at the cursor location and update the cursor.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-fb_cursor_next_line","title":"Function Name: FB_cursor_next_line","text":"<p>Signature: void FB_cursor_next_line(word x: r0); Purpose: Move the direct-access cursor to next line</p> <p>Description: <code>FB_cursor_next_line</code> increments the y position of the direct-access cursor, and sets the x position to the same one that was passed to the previous <code>FB_cursor_position</code> call. This is useful for drawing rectangular shapes, and faster than explicitly positioning the cursor.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-fb_get_pixel","title":"Function Name: FB_get_pixel","text":"<p>Signature: byte FB_get_pixel(); Purpose: Read one pixel, update cursor</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-fb_get_pixels","title":"Function Name: FB_get_pixels","text":"<p>Signature: void FB_get_pixels(word ptr: r0, word count: r1); Purpose: Copy pixels into RAM, update cursor</p> <p>Description: This function copies pixels into an array in RAM. The array consists of one byte per pixel.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-fb_set_pixel","title":"Function Name: FB_set_pixel","text":"<p>Signature: void FB_set_pixel(byte color: .A); Purpose: Set one pixel, update cursor</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-fb_set_pixels","title":"Function Name: FB_set_pixels","text":"<p>Signature: void FB_set_pixels(word ptr: r0, word count: r1); Purpose: Copy pixels from RAM, update cursor</p> <p>Description: This function sets pixels from an array of pixels in RAM. The array consists of one byte per pixel.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-fb_set_8_pixels","title":"Function Name: FB_set_8_pixels","text":"<p>Signature: void FB_set_8_pixels(byte pattern: .A, byte color: .X); Purpose: Set 8 pixels from bit mask (transparent), update cursor</p> <p>Description: This function sets all 1-bits of the pattern to a given color and skips a pixel for every 0 bit. The order is MSB to LSB. The cursor will be moved by 8 pixels.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-fb_set_8_pixels_opaque","title":"Function Name: FB_set_8_pixels_opaque","text":"<p>Signature: void FB_set_8_pixels_opaque(byte pattern: .A, byte mask: r0L, byte color1: .X, byte color2: .Y); Purpose: Set 8 pixels from bit mask (opaque), update cursor</p> <p>Description: For every 1-bit in the mask, this function sets the pixel to color1 if the corresponding bit in the pattern is 1, and to color2 otherwise. For every 0-bit in the mask, it skips a pixel. The order is MSB to LSB. The cursor will be moved by 8 pixels.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-fb_fill_pixels","title":"Function Name: FB_fill_pixels","text":"<p>Signature: void FB_fill_pixels(word count: r0, word step: r1, byte color: .A); Purpose: Fill pixels with constant color, update cursor</p> <p>Description: <code>FB_fill_pixels</code> sets pixels with a constant color. The argument <code>step</code> specifies the increment between pixels. A value of 0 or 1 will cause consecutive pixels to be set. Passing a <code>step</code> value of the screen width will set vertically adjacent pixels going top down. Smaller values allow drawing dotted horizontal lines, and multiples of the screen width allow drawing dotted vertical lines.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-fb_filter_pixels","title":"Function Name: FB_filter_pixels","text":"<p>Signature: void FB_filter_pixels(word ptr: r0, word count: r1); Purpose: Apply transform to pixels, update cursor</p> <p>Description: This function allows modifying consecutive pixels. The function pointer will be called for every pixel, with the color in .A, and it needs to return the new color in .A.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-fb_move_pixels","title":"Function Name: FB_move_pixels","text":"<p>Signature: void FB_move_pixels(word sx: r0, word sy: r1, word tx: r2, word ty: r3, word count: r4); Purpose: Copy horizontally consecutive pixels to a different position</p> <p>[Note: Overlapping regions are not yet supported.]</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#graphics","title":"Graphics","text":"<p>The high-level graphics API exposes a set of standard functions. It allows applications to easily perform some common high-level actions like drawing lines, rectangles and images, as well as moving parts of the screen. All commands are completely implemented on top of the framebuffer API, that is, they will continue working after replacing the framebuffer driver with one that supports a different resolution, color depth or even graphics device.</p> <p>$FF20: <code>GRAPH_init</code> - initialize graphics $FF23: <code>GRAPH_clear</code> - clear screen $FF26: <code>GRAPH_set_window</code> - set clipping region $FF29: <code>GRAPH_set_colors</code> - set stroke, fill and background colors $FF2C: <code>GRAPH_draw_line</code> - draw a line $FF2F: <code>GRAPH_draw_rect</code> - draw a rectangle (optionally filled) $FF32: <code>GRAPH_move_rect</code> - move pixels $FF35: <code>GRAPH_draw_oval</code> - draw an oval or circle $FF38: <code>GRAPH_draw_image</code> - draw a rectangular image $FF3B: <code>GRAPH_set_font</code> - set the current font $FF3E: <code>GRAPH_get_char_size</code> - get size and baseline of a character $FF41: <code>GRAPH_put_char</code> - print a character</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-graph_init","title":"Function Name: GRAPH_init","text":"<p>Signature: void GRAPH_init(word vectors: r0); Purpose: Activate framebuffer driver, enter and initialize graphics mode</p> <p>Description: This call activates the framebuffer driver whose vector table is passed in r0. If r0 is 0, the default driver is activated. It then switches the video hardware into graphics mode, sets the window to full screen, initializes the colors and activates the system font.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-graph_clear","title":"Function Name: GRAPH_clear","text":"<p>Signature: void GRAPH_clear(); Purpose: Clear the current window with the current background color.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-graph_set_window","title":"Function Name: GRAPH_set_window","text":"<p>Signature: void GRAPH_set_window(word x: r0, word y: r1, word width: r2, word height: r3); Purpose: Set the clipping region</p> <p>Description: All graphics commands are clipped to the window. This function configures the origin and size of the window. All 0 arguments set the window to full screen.</p> <p>[Note: Only text output and GRAPH_clear currently respect the clipping region.]</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-graph_set_colors","title":"Function Name: GRAPH_set_colors","text":"<p>Signature: void GRAPH_set_colors(byte stroke: .A, byte fill: .X, byte background: .Y); Purpose: Set the three colors</p> <p>Description: This function sets the three colors: The stroke color, the fill color and the background color.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-graph_draw_line","title":"Function Name: GRAPH_draw_line","text":"<p>Signature: void GRAPH_draw_line(word x1: r0, word y1: r1, word x2: r2, word y2: r3); Purpose: Draw a line using the stroke color</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-graph_draw_rect","title":"Function Name: GRAPH_draw_rect","text":"<p>Signature: void GRAPH_draw_rect(word x: r0, word y: r1, word width: r2, word height: r3, word corner_radius: r4, bool fill: c); Purpose: Draw a rectangle.</p> <p>Description: This function will draw the frame of a rectangle using the stroke color. If <code>fill</code> is <code>true</code>, it will also fill the area using the fill color. To only fill a rectangle, set the stroke color to the same value as the fill color.</p> <p>[Note: The border radius is currently unimplemented.]</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-graph_move_rect","title":"Function Name: GRAPH_move_rect","text":"<p>Signature: void GRAPH_move_rect(word sx: r0, word sy: r1, word tx: r2, word ty: r3, word width: r4, word height: r5); Purpose: Copy a rectangular screen area to a different location</p> <p>Description: <code>GRAPH_move_rect</code> coll copy a rectangular area of the screen to a different location. The two areas may overlap.</p> <p>[Note: Support for overlapping is not currently implemented.]</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-graph_draw_oval","title":"Function Name: GRAPH_draw_oval","text":"<p>Signature: void GRAPH_draw_oval(word x: r0, word y: r1, word width: r2, word height: r3, bool fill: c); Purpose: Draw an oval or a circle</p> <p>Description: This function draws an oval filling the given bounding box. If width equals height, the resulting shape is a circle. The oval will be outlined by the stroke color. If <code>fill</code> is <code>true</code>, it will be filled using the fill color. To only fill an oval, set the stroke color to the same value as the fill color.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-graph_draw_image","title":"Function Name: GRAPH_draw_image","text":"<p>Signature: void GRAPH_draw_image(word x: r0, word y: r1, word ptr: r2, word width: r3, word height: r4); Purpose: Draw a rectangular image from data in memory</p> <p>Description: This function copies pixel data from memory onto the screen. The representation of the data in memory has to have one byte per pixel, with the pixels organized line by line top to bottom, and within the line left to right.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-graph_set_font","title":"Function Name: GRAPH_set_font","text":"<p>Signature: void GRAPH_set_font(void ptr: r0); Purpose: Set the current font</p> <p>Description: This function sets the current font to be used for the remaining font-related functions. The argument is a pointer to the font data structure in memory, which must be in the format of a single point size GEOS font (i.e. one GEOS font file VLIR chunk). An argument of 0 will activate the built-in system font.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-graph_get_char_size","title":"Function Name: GRAPH_get_char_size","text":"<p>Signature: (byte baseline: .A, byte width: .X, byte height_or_style: .Y, bool is_control: c) GRAPH_get_char_size(byte c: .A, byte format: .X); Purpose: Get the size and baseline of a character, or interpret a control code</p> <p>Description: This functionality of <code>GRAPH_get_char_size</code> depends on the type of code that is passed in: For a printable character, this function returns the metrics of the character in a given format. For a control code, it returns the resulting format. In either case, the current format is passed in .X, and the character in .A.</p> <ul> <li>The format is an opaque byte value whose value should not be relied upon, except for <code>0</code>, which is plain text.</li> <li>The resulting values are measured in pixels.</li> <li>The baseline is measured from the top.</li> </ul>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-graph_put_char","title":"Function Name: GRAPH_put_char","text":"<p>Signature: void GRAPH_put_char(inout word x: r0, inout word y: r1, byte c: .A); Purpose: Print a character onto the graphics screen</p> <p>Description: This function prints a single character at a given location on the graphics screen. The location is then updated. The following control codes are supported:</p> <ul> <li>$01: SWAP COLORS</li> <li>$04: ATTRIBUTES: UNDERLINE</li> <li>$06: ATTRIBUTES: BOLD</li> <li>$07: BELL</li> <li>$08: BACKSPACE</li> <li>$09: TAB</li> <li>$0A: LF</li> <li>$0B: ATTRIBUTES: ITALICS</li> <li>$0C: ATTRIBUTES: OUTLINE</li> <li>$0D/$8D: REGULAR/SHIFTED RETURN</li> <li>$11/$91: CURSOR: DOWN/UP</li> <li>$12: ATTRIBUTES: REVERSE</li> <li>$13/$93: HOME/CLEAR</li> <li>$14 DEL</li> <li>$92: ATTRIBUTES: CLEAR ALL</li> <li>all color codes</li> </ul> <p>Notes:</p> <ul> <li>CR ($0D) SHIFT+CR ($8D) and LF ($0A) all set the cursor to the beginning of the next line. The only difference is that CR and SHIFT+CR reset the attributes, and LF does not.</li> <li>BACKSPACE ($08) and DEL ($14) move the cursor to the beginning of the previous character but does not actually clear it. Multiple consecutive BACKSPACE/DEL characters are not supported.</li> <li>There is no way to individually disable attributes (underlined, bold, reversed, italics, outline). The only way to disable them is to reset the attributes using code $92, which switches to plain text.</li> <li>All 16 PETSCII color codes are supported. Code $01 to swap the colors will swap the stroke and fill colors.</li> <li>The stroke color is used to draw the characters, and the underline is drawn using the fill color. In reverse text mode, the text background is filled with the fill color.</li> <li>[BELL ($07), TAB ($09) and SHIFT+TAB ($18) are not yet implemented.]</li> </ul>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#console","title":"Console","text":"<p>$FEDB: <code>console_init</code> - initialize console mode $FEDE: <code>console_put_char</code> - print character to console $FED8: <code>console_put_image</code> - draw image as if it was a character $FEE1: <code>console_get_char</code> - get character from console $FED5: <code>console_set_paging_message</code> - set paging message or disable paging</p> <p>The console is a screen mode that allows text output and input in proportional fonts that support the usual styles. It is useful for rich text-based interfaces.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-console_init","title":"Function Name: console_init","text":"<p>Signature: void console_init(word x: r0, word y: r1, word width: r2, word height: r3); Purpose: Initialize console mode. Call address: $FEDB</p> <p>Description: This function initializes console mode. It sets up the window (text clipping area) passed into it, clears the window and positions the cursor at the top left. All 0 arguments create a full screen console. You have to switch to graphics mode using <code>screen_mode</code> beforehand.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-console_put_char","title":"Function Name: console_put_char","text":"<p>Signature: void console_put_char(byte char: .A, bool wrapping: c); Purpose: Print a character to the console. Call address: $FEDE</p> <p>Description: This function prints a character to the console. The c flag specifies whether text should be wrapped at character (c=0) or word (c=1) boundaries. In the latter case, characters will be buffered until a SPACE, CR or LF character is sent, so make sure the text that is printed always ends in one of these characters.</p> <p>Note: If the bottom of the screen is reached, this function will scroll its contents up to make extra room.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-console_put_image","title":"Function Name: console_put_image","text":"<p>Signature: void console_put_image(word ptr: r0, word width: r1, word height: r2); Purpose: Draw image as if it was a character. Call address: $FEE1</p> <p>Description: This function draws an image (in GRAPH_draw_image format) at the current cursor position and advances the cursor accordingly. This way, an image can be presented inline. A common example would be an emoji bitmap, but it is also possible to show full-width pictures if you print a newline before and after the image.</p> <p>Notes:</p> <ul> <li>If the bottom of the screen is reached, this function will scroll its contents up to make extra room.</li> <li>Subsequent line breaks will take the image height into account, so that the new cursor position is below the image.</li> </ul>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-console_get_char","title":"Function Name: console_get_char","text":"<p>Signature: (byte char: .A) console_get_char(); Purpose: Get a character from the console. Call address: $FEE1</p> <p>Description: This function gets a character to the console. It does this by collecting a whole line of character, i.e. until the user presses RETURN. Then, the line will be sent character by character.</p> <p>This function allows editing the line using BACKSPACE/DEL, but does not allow moving the cursor within the line, write more than one line, or using control codes.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-console_set_paging_message","title":"Function Name: console_set_paging_message","text":"<p>Signature: void console_set_paging_message(word message: r0); Purpose: Set the paging message or disable paging. Call address: $FED5</p> <p>Description: The console can halt printing after a full screen height worth of text has been printed. It will then show a message, wait for any key, and continue printing. This function sets this message. A zero-terminated text is passed in r0. To turn off paging, call this function with r0 = 0 - this is the default.</p> <p>Note: It is possible to use control codes to change the text style and color. Do not use codes that change the cursor position, like CR or LF. Also, the text must not overflow one line on the screen.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#other","title":"Other","text":"<p>$FF47: <code>enter_basic</code> - enter BASIC $FECF: <code>entropy_get</code> - get 24 random bits $FEAB: <code>extapi</code> - extended API $FECC: <code>monitor</code> - enter machine language monitor $FF5F: <code>screen_mode</code> - get/set screen mode $FF62: <code>screen_set_charset</code> - activate 8x8 text mode charset $FFED: <code>SCREEN</code> - get the text resolution</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-enter_basic","title":"Function Name: enter_basic","text":"<p>Purpose: Enter BASIC Call address: $FF47 Communication registers: .P Preparatory routines: None Error returns: Does not return</p> <p>Description: Call this to enter BASIC mode, either through a cold start (c=1) or a warm start (c=0).</p> <p>EXAMPLE:</p> <pre><code>CLC\nJMP enter_basic ; returns to the \"READY.\" prompt\n</code></pre>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-entropy_get","title":"Function Name: entropy_get","text":"<p>Purpose: Get 24 random bits Call address: $FECF Communication registers: .A .X .Y Preparatory routines: None Error returns: None Registers affected: .A .X .Y</p> <p>Description: This routine returns 24 somewhat random bits in registers .A, .X, and .Y. In order to get higher-quality random numbers, this data should be used to seed a pseudo-random number generator, as this is not a proper high quality pseudo-random number generator in and of itself.</p> <p>How to Use:</p> <p>1) Call this routine.</p> <p>EXAMPLE:</p> <pre><code>    ; throw a die\n    again:\n      JSR entropy_get\n      STX tmp   ; combine 24 bits\n      EOR tmp   ; using exclusive-or\n      STY tmp   ; to get a higher-quality\n      EOR tmp   ; 8 bit random value\n      STA tmp\n      LSR\n      LSR\n      LSR\n      LSR       ; combine resulting 8 bits\n      EOR tmp   ; to get 4 bits\n      AND #7    ; we're down to values 0-7\n      CMP #0\n      BEQ again ; 0 is illegal\n      CMP #7\n      BEQ again ; 7 is illegal\n      ORA #$30  ; convert to ASCII\n      JMP $FFD2 ; print character\n</code></pre>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-extapi","title":"Function Name: extapi","text":"<p>Purpose: Additional API functions Minimum ROM version: R47 Call address: $FEAB Communication registers: .A .X .Y .P Preparatory routines: None Error returns: Varies, but usually c=1 Registers affected: Varies</p> <p>Description: This API slot provides access to various extended calls. The call is selected by the .A register, and each call has its own register use and return behavior.</p> Call # Name Description Inputs Outputs Preserves <code>$01</code> <code>clear_status</code> resets the KERNAL IEC status to zero none none - <code>$02</code> <code>getlfs</code> getter counterpart to setlfs none .A .X .Y - <code>$03</code> <code>mouse_sprite_offset</code> get or set mouse sprite pixel offset r0 r1 .P r0 r1 - <code>$04</code> <code>joystick_ps2_keycodes</code> get or set joy0 keycode mappings r0L-r6H .P r0L-r6H - <code>$05</code> <code>iso_cursor_char</code> get or set the ISO mode cursor char .X .P .X - <code>$06</code> <code>ps2kbd_typematic</code> set the keyboard repeat delay and rate .X - - <code>$07</code> <code>pfkey</code> program macros for F1-F8 and the RUN key .X - - <code>$08</code> <code>ps2data_fetch</code> Polls the SMC for PS/2 keyboard and mouse data - - - <code>$09</code> <code>ps2data_raw</code> If the most recent <code>ps2data_fetch</code> received a mouse packet or keycode, returns its raw value - .A .Y .X .P r0L-r1H - <code>$0A</code> <code>cursor_blink</code> Blinks or un-blinks the KERNAL editor cursor if appropriate - - - <code>$0B</code> <code>led_update</code> Illuminates or clears the SMC activity LED based on disk activity or error status - - - <code>$0C</code> <code>mouse_set_position</code> Moves the mouse cursor to a specific X/Y location .X (.X)-(.X+3) - - <code>$0D</code> <code>scnsiz</code> Directly sets the kernal editor text dimensions .X .Y - -"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#extapi-function-name-clear_status","title":"extapi Function Name: clear_status","text":"<p>Purpose: Reset the IEC status byte to 0 Minimum ROM version: R47 Call address: $FEAB, .A=1 Communication registers: none Preparatory routines: none Error returns: none Registers affected: .A</p> <p>Description: This function explicitly clears the IEC status byte. This is the value which is returned by calling <code>readst</code>.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#extapi-function-name-getlfs","title":"extapi Function Name: getlfs","text":"<p>Purpose: Return the values from the last call to <code>setlfs</code> Minimum ROM version: R47 Call address: $FEAB, .A=2 Communication registers: .A .X .Y Preparatory routines: none Error returns: none Registers affected: .A .X .Y</p> <p>Description: This function returns the values from the most recent call to <code>setlfs</code>. This is most useful for fetching the most recently-used disk device.</p> <p>EXAMPLE:</p> <pre><code>LOADFILE:\n    ; getlfs returns the most recently used disk device (`fa`) in .X\n    ; Also returns `la` in .A and `sa` in .Y, but we ignore those\n    LDA #2    ; extapi:getlfs\n    JSR $FEAB ; extapi\n    LDA #1\n    LDY #2\n    JSR $FFBA ; SETLFS\n    LDA #FNEND-FN\n    LDX #&lt;FN\n    LDY #&gt;FN\n    JSR $FFBD ; SETNAM\n    LDA #1\n    STA $00   ; ram_bank\n    LDA #0\n    LDX #&lt;$A000\n    LDY #&gt;$A000\n    JSR $FFD5 ; LOAD\n    RTS\nFN:\n    .byte \"MYFILENAME.EXT\"\nFNEND = *\n</code></pre>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#extapi-function-name-mouse_sprite_offset","title":"extapi Function Name: mouse_sprite_offset","text":"<p>Purpose: Set the mouse sprite x/y offset Minimum ROM version: R47 Call address: $FEAB, .A=3 Communication registers: r0 r1 Preparatory routines: <code>mouse_config</code> Error returns: none Registers affected: .A .X .Y .P r0 r1</p> <p>Description: This function allows you to set or retrieve the display offset of the mouse sprite, relative to the calculated mouse position. Setting it negative can be useful for mouse sprites in which the locus is not the upper left corner. Combined with configuring a smaller X/Y with mouse_config, it can be set positive to confine the mouse pointer to a limited region of the screen.</p> <ul> <li>Set: If carry is clear when called, the X and Y sprite offsets are configured from the values in r0 and r1 respectively.</li> <li>Get: If carry is set when called, the X and Y sprite offsets are retrieved and placed in r0 and r1 respectively.</li> </ul> <p>How to Use:</p> <p>1) Set up your mouse sprite and call <code>mouse_config</code>. Any call to <code>mouse_config</code> resets this offset. 2) Load r0 with the 16-bit X offset and r1 with the 16-bit Y offset. Most of the time these values will be negative. For instance, a 16x16 sprite pointer in which the locus is near the center would have an offset of -8 ($FFF8) on both axes. 3) Clear carry and call <code>mouse_sprite_offset</code></p> <p>EXAMPLE:</p> <pre><code>  ; configure your mouse sprite here\n\n  ; configure mouse before setting offset\n  LDA #$FF\n  LDY #0\n  LDX #0\n  JSR $FF68 ; mouse_config (resets sprite offsets to zero)\n\n  LDA #&lt;(-8)\n  STA r0L\n  STA r1L\n  LDA #&gt;(-8)\n  STA r0H\n  STA r1H\n  LDA #3    ; mouse_sprite_offset\n  CLC\n  JSR $FEAB ; extapi\n</code></pre>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#extapi-function-name-joystick_ps2_keycodes","title":"extapi Function Name: joystick_ps2_keycodes","text":"<p>Purpose: Set or get the keyboard mapping for joystick 0 Minimum ROM version: R47 Call address: $FEAB, .A=4 Communication registers: .P r0L-r6H Preparatory routines: none Error returns: none Registers affected: .A .X .Y .P r0L-r6H</p> <p>Description: This function allows you to set or retrieve the list of keycodes that are mapped to joystick 0</p> <ul> <li>Set: If carry is clear when called, the current values are set based on the contents of the 14 registers r0L-r6H.</li> <li>Get: If carry is set when called, the current values are retrieved and placed in the 14 registers r0L-r6H.</li> </ul> Register Controller Input Default r0L D-pad Right KEYCODE_RIGHTARROW ($59) r0H D-pad Left KEYCODE_LEFTARROW ($4F) r1L D-pad Down KEYCODE_DOWNARROW ($54) r1H D-pad Up KEYCODE_UPARROW ($53) r2L Start KEYCODE_ENTER ($2B) r2H Select KEYCODE_LSHIFT ($2C) r3L Y KEYCODE_A ($1F) r3H B KEYCODE_Z ($2E) r4L B KEYCODE_LALT ($3C) r4H R KEYCODE_C ($30) r5L L KEYCODE_D ($21) r5H X KEYCODE_S ($20) r6L A KEYCODE_X ($2F) r6H A KEYCODE_LALT ($3C) <ul> <li>Note that there are two mappings for the controller button B, and two mappings for the controller button A. Both mapped keys will activate the controller button.</li> </ul> <p>How to Use:</p> <p>1) Unless you're replacing the entire set of mappings, call <code>joystick_ps2_keycodes</code> first with carry set to fetch the existing values into r0L-r6H. 2) Load your desired changes into r0L-r6H. The keycodes are enumerated here, and their names, similar to that of PS/2 codes, are based on their function in the US layout.  You can also disable a mapping entirely with the value 0.</p> <p>3) Clear carry and call <code>joystick_ps2_keycodes</code></p> <p>EXAMPLE:</p> <pre><code>  ; first fetch the original values\n  LDA #4    ; joystick_ps2_keycodes\n  SEC       ; get values\n  JSR $FEAB ; extapi\n  LDA #$10  ; KEYCODE_TAB\n  STA r2H   ; Tab is to be mapped to the select button\n  STZ r4L   ; Disable the secondary B button mapping\n  STZ r6H   ; Disable the secondary A button mapping\n  LDA #4    ; joystick_ps2_keycodes\n  CLC       ; set values\n  JSR $FEAB ; extapi (brings the new mapping into effect)\n</code></pre>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#extapi-function-name-iso_cursor_char","title":"extapi Function Name: iso_cursor_char","text":"<p>Purpose: get or set the ISO mode cursor character Minimum ROM version: R47 Call address: $FEAB, .A=5 Communication registers: .X .P Preparatory routines: none Error returns: none Registers affected: .A .X .Y .P</p> <p>Description: This function allows you to set or retrieve the cursor screen code which is used in ISO mode.</p> <ul> <li>Set: If carry is clear when called, the current value of .X is used as the blinking cursor character if the screen console is in ISO mode.</li> <li>Get: If carry is set when called, the current value of the blinking cursor character is returned in .X.</li> </ul> <p>When entering ISO mode, such as by sending a <code>$0F</code> to the screen via <code>BSOUT</code> or pressing Ctrl+O, the cursor character is reset to the default of <code>$9F</code>.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#extapi-function-name-ps2kbd_typematic","title":"extapi Function Name: ps2kbd_typematic","text":"<p>Purpose: set the PS/2 typematic delay and repeat rate Minimum ROM version: R47 Call address: $FEAB, .A=6 Communication registers: .X Preparatory routines: none Error returns: none Registers affected: .A .X .Y .P</p> <p>Description: This function allows you to set the delay and repeat rate of the PS/2 keyboard. Since the keyboard doesn't allow you to query the current value, there is no getter counterpart to this routine.</p> <p>NOTE: Since the SMC communicates with the keyboard using PS/2 scancode set 2, there is no way to instruct the keyboard to turn off typematic repeat entirely. However, with a very simple custom KERNAL key handler, you can suppress processing repeated key down events without an intervening key up.</p> <p>NOTE: This routine does not work with the emulator, as the key repeat rate is controlled by the operating system.</p> <p>This function takes 7 bits of input in .X, a bitfield composed of two parameter options.</p> <ul> <li>.X = 0ddrrrrr</li> </ul> <p>Where dd is the delay before repeating,</p> <ul> <li>dd = 00: 250 ms</li> <li>dd = 01: 500 ms</li> <li>dd = 10: 750 ms</li> <li>dd = 11: 1000 ms</li> </ul> <p>and rrrrr is the repeat rate, given this conversion to Hz.</p> <pre><code> $00 = 30.0 Hz, $01 = 26.7 Hz, $02 = 24.0 Hz, $03 = 21.8 Hz\n $04 = 20.7 Hz, $05 = 18.5 Hz, $06 = 17.1 Hz, $07 = 16.0 Hz\n $08 = 15.0 Hz, $09 = 13.3 Hz, $0a = 12.0 Hz, $0b = 10.9 Hz\n $0c = 10.0 Hz, $0d =  9.2 Hz, $0e =  8.6 Hz, $0f =  8.0 Hz\n $10 =  7.5 Hz, $11 =  6.7 Hz, $12 =  6.0 Hz, $13 =  5.5 Hz\n $14 =  5.0 Hz, $15 =  4.6 Hz, $16 =  4.3 Hz, $17 =  4.0 Hz\n $18 =  3.7 Hz, $19 =  3.3 Hz, $1a =  3.0 Hz, $1b =  2.7 Hz\n $1c =  2.5 Hz, $1d =  2.3 Hz, $1e =  2.1 Hz, $1f =  2.0 Hz\n</code></pre>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#extapi-function-name-pfkey","title":"extapi Function Name: pfkey","text":"<p>Purpose: Reprogram a function key macro Minimum ROM version: R47 Call address: $FEAB, .A=7 Communication registers: .X .Y r0 Preparatory routines: None Error returns: c=1 Registers affected: .A .X .Y .P r0</p> <p>Description: This routine can be called to replace an F-key macro in the KERNAL editor with a user-defined string. The maximum length of each macro is 10 bytes, matching the size of the X16 KERNAL's keyboard buffer. It can also replace the action of SHIFT+RUN with a user-defined action.</p> <p>These macros are only available in the KERNAL editor, which is usually while editing BASIC program, or during a BASIN from the screen. The BASIC statements INPUT and LINPUT also operate in this mode.</p> <p>Inputs: * r0 = pointer to string * .X = key number (1-9) * .Y = string length</p> <p>How to Use:</p> <p>1) Load r0L and r0H a pointer to the replacement macro string (ZP locations $02 and $03). 2) Load .X with the key number to replace. Values 1-8 correspond to F1-F8. A value of 9 corresponds to SHIFT+RUN. 3) Load .Y with the string length. This may be a range from 0-10 inclusive. A value of 0 disables the macro entirely. 4) Call <code>pfkey</code>. If carry is set when returning, an error occurred. The most likely reason is that one of the input parameters was out of range.</p> <p>EXAMPLE:</p> <p>Disable the SHIFT+RUN action, and replace the macro in F1 with \"HELP\" followed by a carriage return.</p> <pre><code>EXTAPI = $FEAB\n\nchange_fkeys:\n  lda #&lt;string1\n  sta $02\n  lda #&gt;string1\n  sta $03\n  lda #$02\n  ldx #1\n  ldy #&lt;(string1_end-string1)\n  jsr EXTAPI\n  lda #&lt;string9\n  sta $02\n  lda #&gt;string9\n  sta $03\n  lda #7\n  ldx #9\n  ldy #&lt;(string9_end-string9)\n  jsr EXTAPI\n  rts\n\nstring1: .byte \"HELP\",13\nstring1_end:\nstring9:\nstring9_end:\n</code></pre> <p>BASIC equivalent:</p> <pre><code>10 A$=\"HELP\"+CHR$(13)\n20 K=1\n30 GOSUB 100\n40 A$=\"\"\n50 K=9\n60 GOSUB 100\n70 END\n100 AL=LEN(A$)\n110 AP=STRPTR(A$)\n120 POKE $02,(AP-(INT(AP/256)*256))\n130 POKE $03,INT(AP/256)\n140 POKE $30C,7\n150 POKE $30D,K\n160 POKE $30E,AL\n170 SYS $FEAB\n180 RETURN\n</code></pre>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#extapi-function-name-ps2data_fetch","title":"extapi Function Name: ps2data_fetch","text":"<p>Purpose: Poll the SMC for PS/2 events Minimum ROM version: R47 Call address: $FEAB, .A=8 Communication registers: None Preparatory routines: None Error returns: None Registers affected: .A .X .Y .P</p> <p>Description: This routine is called from the default KERNAL interrupt service handler to fetch a queued keycode, and if the mouse is enabled, a mouse packet. The values are stored inside internal KERNAL state used by subsequent calls to <code>mouse_scan</code>, <code>kbd_scan</code>, or <code>ps2data_raw</code>.</p> <p>If the mouse has not been enabled via <code>mouse_config</code>, no mouse data is polled.</p> <p>This call is mainly useful when overriding the default KERNAL IRQ handler, and since this function is not re-entrant safe, it is unsafe to call outside of an interrupt handler if interrupts are enabled and the default KERNAL IRQ handler is in place.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#extapi-function-name-ps2data_raw","title":"extapi Function Name: ps2data_raw","text":"<p>Purpose: Return the most recently-fetched PS/2 mouse packet and keycode Minimum ROM version: R47 Call address: $FEAB, .A=9 Communication registers: .A .Y .X .P r0L-r1H Preparatory routines: <code>mouse_config</code>, <code>ps2data_fetch</code> Error returns: None Registers affected: .A .X .Y .P r0L-r1H</p> <p>Description: This routine returns the most-recently fetched mouse data packet and keycode. If a mouse packet exists, it sets .X to the length of the packet, either 3 or 4 depending on mouse type, and stores the values into r0L-r1H. If there's no mouse packet to return, .X is set to zero. If there's a keycode to return, .A is set to the keycode, otherwise .A is set to zero. If there's an extended keycode, .A will equal $7F for key down or $FF for key up, and .Y will contain the extended code.</p> <p>If .X = 0, no mouse packet was received, and r0L-r1H memory is unchanged.</p> <p>If the zero flag is set, neither the keyboard nor mouse had pending events.</p> <p>This call is mainly useful when overriding the default KERNAL ISR and implementing a fully custom mouse and keyboard routine.  It is also available when using the default ISR as these values are kept even after processing, until the next <code>ps2data_fetch</code> call.</p> <p>Return values:</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#keyboard_1","title":"Keyboard","text":"<ul> <li>.A = keycode</li> </ul> <p>If .A == $7F or .A == $FF</p> <ul> <li>.Y = extended keycode</li> </ul>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#mouse_1","title":"Mouse","text":"<ul> <li>.X = number of mouse bytes</li> </ul> <p>If .X == 0, memory is left unchanged.</p> <p>If .X &gt;= 3</p> <ul> <li>r0L = mouse byte 1</li> <li>r0H = mouse byte 2</li> <li>r1L = mouse byte 3</li> </ul> <p>If .X == 4</p> <ul> <li>r1H = mouse byte 4</li> </ul> <p>How to Use:</p> <p>1) Call <code>mouse_config</code> with a non-zero value to enable the mouse. 2) If you're overriding the default KERNAL IRQ handler entirely, call <code>ps2data_fetch</code>. If not, this will be called for you. 3) Call <code>ps2data_raw</code>. If .X is nonzero upon return, memory starting at r0L will contain the raw mouse packet.</p> <p>EXAMPLE:</p> <pre><code>CHROUT = $FFD2\nSTOP = $FFE1\nEXTAPI = $FEAB\nMOUSE_CONFIG = $FF68\nSCREEN_MODE = $FF5F\n\nTMP1 = $22\nr0 = $02\n\nstart:\n        sec\n        jsr SCREEN_MODE ; get the screen size to pass to MOUSE_CONFIG\n        lda #1\n        jsr MOUSE_CONFIG\nloop:\n        wai ; wait for interrupt\n        lda #9 ; ps2data_raw\n        jsr EXTAPI\n        beq aftermouse\n        stx TMP1\n        ora #0\n        beq afterkbd\n        jsr print_hex_byte\n        lda #13\n        jsr CHROUT\nafterkbd:\n        ldx TMP1\n        beq aftermouse\n        ldx #0\nprintloop:\n        lda r0,x\n        phx\n        jsr print_hex_byte\n        plx\n        inx\n        cpx TMP1\n        bne printloop\n        lda #13\n        jsr CHROUT\naftermouse:\n        jsr STOP\n        bne loop\ndone:\n        rts\n\nprint_hex_byte:\n        jsr byte_to_hex\n        jsr CHROUT\n        txa\n        jsr CHROUT\n        rts\n\nbyte_to_hex:\n        pha\n        and #$0f\n        tax\n        pla\n        lsr\n        lsr\n        lsr\n        lsr\n        pha\n        txa\n        jsr @hexify\n        tax\n        pla\n@hexify:\n        cmp #10\n        bcc @nothex\n        adc #$66\n@nothex:\n        eor #%00110000\n        rts\n</code></pre>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#extapi-function-name-cursor_blink","title":"extapi Function Name: cursor_blink","text":"<p>Purpose: Blink or un-blink the cursor in the KERNAL editor Minimum ROM version: R47 Call address: $FEAB, .A=10 Communication registers: None Preparatory routines: None Error returns: None Registers affected: .A .X .Y .P</p> <p>Description: This routine is called from the default KERNAL interrupt service handler to cause the text mode cursor to blink on or off as appropriate, depending on the number of times this function has been called since the last blink event. If the editor is not waiting for input, this function has no effect.</p> <p>This call is mainly useful when overriding the default KERNAL IRQ handler.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#extapi-function-name-led_update","title":"extapi Function Name: led_update","text":"<p>Purpose: Set the illumination status of the SMC's activity LED based on disk status Minimum ROM version: R47 Call address: $FEAB, .A=11 Communication registers: None Preparatory routines: None Error returns: None Registers affected: .A .X .Y .P</p> <p>Description: This routine is called from the default KERNAL IRQ handler to update the status of the SMC's activity LED based on CMDR-DOS's status flags. It is illuminated solid during DOS disk activity, and flashes when there was a disk error.</p> <p>This call is mainly useful when overriding the default KERNAL IRQ handler.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#extapi-function-name-mouse_set_position","title":"extapi Function Name: mouse_set_position","text":"<p>Purpose: Move the mouse pointer to an absolute X/Y position Minimum ROM version: R47 Call address: $FEAB, .A=12 Communication registers: .X (.X)-(.X+3) Preparatory routines: <code>mouse_config</code> Error returns: None Registers affected: .A .X .Y .P</p> <p>Description: This routine set the absolute position of the mouse pointer and updates the pointer sprite.</p> <p>Inputs: * .X = the zeropage location from which to read the new values * $00+X = X position low byte * $01+X = X position high byte * $02+X = Y position low byte * $03+X = Y position high byte</p> <p>For instance, if you want the function to read the values from memory locations $22 through $25, set .X to #$22.</p> <p>How to Use:</p> <p>1) Call <code>mouse_config</code> with a non-zero value to enable the mouse. 2) Store the new X/Y position in four contiguous zeropage locations as described above. Load .X with the starting zeropage location. 3) Call <code>mouse_set_position</code></p> <p>EXAMPLE:</p> <p>This demo program causes the mouse pointer to slowly drift down and to the right.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#r0l-02-r0h-03-r1l-04-r1h-05-extapi-feab-mouse_config-ff68-mouse_get-ff6b-screen_mode-ff5f-stop-ffe1-start-sec-jsr-screen_mode-lda-1-jsr-mouse_config-loop-ldx-r0l-starting-zp-location-for-mouse_get-jsr-mouse_get-inc-r0l-bne-inc-r0h-inc-r1l-bne-inc-r1h-ldx-r0l-starting-zp-location-for-mouse_set_position-lda-12-mouse_set_position-jsr-extapi-wai-delay-until-next-interrupt-jsr-stop-bne-loop-done-rts","title":"<pre><code>r0L = $02\nr0H = $03\nr1L = $04\nr1H = $05\n\nEXTAPI = $FEAB\nMOUSE_CONFIG = $FF68\nMOUSE_GET = $FF6B\nSCREEN_MODE = $FF5F\nSTOP = $FFE1\n\nstart:\n        sec\n        jsr SCREEN_MODE\n        lda #1\n        jsr MOUSE_CONFIG\nloop:\n        ldx #r0L ; starting ZP location for mouse_get\n        jsr MOUSE_GET\n        inc r0L\n        bne :+\n        inc r0H\n:       inc r1L\n        bne :+\n        inc r1H\n:\n        ldx #r0L ; starting ZP location for mouse_set_position\n        lda #12 ; mouse_set_position\n        jsr EXTAPI\n        wai ; delay until next interrupt\n        jsr STOP\n        bne loop\ndone:\n        rts\n</code></pre>","text":""},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#extapi-function-name-scnsiz","title":"extapi Function Name: scnsiz","text":"<p>Purpose: Set the number of text rows and columns for the kernal screen editor Minimum ROM version: R48 Call address: $FEAB, .A=13 Communication registers: .X .Y Preparatory routines: None Error returns: c=1 Registers affected: .A .X .Y .P</p> <p>Description: This routine is implicitly called by <code>screen_mode</code> to set the bounds of the kernal editor's screen, and can be used directly to change the row and column bounds of the screen editor. <code>scnsiz</code> does not change the screen scaling.</p> <p>This call is mainly useful to set custom row and column counts not available from any built-in screen mode.</p> <p>Due to limits within the KERNAL's editor and what screen sizes it expects to work with, this routine will error and return with carry set if: * .X &lt; 20 * .X &gt; 80 * .Y &lt; 4 * .Y &gt; 60</p> <p>If the requested size exceeds the allowed bounds (.X = 20-80, .Y = 4-60), the existing text resolution won't be changed.</p> <p>How to Use:</p> <p>1) Set .X to the number of desired columns and .Y to the desired number of rows. 2) Call <code>scnsiz</code> 3) The in-bounds area of the screen as defined by these new dimensions will be cleared and the cursor will be placed at the upper-left home position.</p> <p>EXAMPLE:</p> <p>This example assembly routine sets up an 80x25 region, also adding top and bottom border regions so that the viewable area only shows the 80x25 text region.</p> <pre><code>SCREEN_MODE = $FF5F\nEXTAPI = $FEAB\nE_SCNSIZ = $0D\nVERA_CTRL = $9F25\nVERA_DC_VSTART = $9F2B\nVERA_DC_VSTOP = $9F2C\n\nTOP = 20 ; 20 rows from the top\nBOTTOM = 480-20 ; 20 rows from the bottom\n\ndo_80x25:\n        lda #1\n        clc\n        jsr SCREEN_MODE ; set screen mode to 80x30, which also clears the screen\n        ldx #80\n        ldy #25\n        lda #E_SCNSIZ\n        jsr EXTAPI ; reset to 80x25\n        lda #(1 &lt;&lt; 1) ; DCSEL = 1\n        sta VERA_CTRL\n        lda #(TOP &gt;&gt; 1) ; each step in DC_VSTART is 2 pixel rows\n        sta VERA_DC_VSTART\n        lda #(BOTTOM &gt;&gt; 1) ; each step in DC_VSTOP is 2 pixel rows\n        sta VERA_DC_VSTOP\n        stz VERA_CTRL\n        rts\n</code></pre>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-monitor","title":"Function Name: monitor","text":"<p>Purpose: Enter the machine language monitor Call address: $FECC Communication registers: None Preparatory routines: None Error returns: Does not return Registers affected: Does not return</p> <p>Description: This routine switches from BASIC to machine language monitor mode. It does not return to the caller. When the user quits the monitor, it will restart BASIC.</p> <p>How to Use:</p> <p>1) Call this routine.</p> <p>EXAMPLE:</p> <pre><code>      JMP monitor\n</code></pre>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-screen","title":"Function Name: SCREEN","text":"<p>Purpose: Get the text resolution of the screen Call address: $FFED Communication registers: .X, .Y Preparatory routines: None Error returns: None Registers affected: .A, .X, .Y, .P</p> <p>Description: This routine returns the KERNAL screen editor's view of the text resolution. The column count is returned in .X and the row count is returned in .Y.</p> <p>In contrast to calling <code>screen_mode</code> with carry set, this function returns the configured resolution if ever it is updated by <code>scnsiz</code>. <code>screen_mode</code> only returns the text dimensions the currently configured mode would have configured, ignoring any changes made by calls to <code>scnsiz</code>.</p> <p>EXAMPLE:</p> <pre><code>SCREEN = $FFED\n\nget_res:\n        jsr SCREEN\n        sty my_rows\n        stx my_columns\n        rts\n</code></pre>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-screen_mode","title":"Function Name: screen_mode","text":"<p>Purpose: Get/Set the screen mode Call address: $FF5F Communication registers: .A, .X, .Y, .P Preparatory routines: None Error returns: c = 1 in case of error Registers affected: .A, .X, .Y</p> <p>Description: If c is set, a call to this routine gets the current screen mode in .A, the width (in tiles) of the screen in .X, and the height (in tiles) of the screen in .Y. If c is clear, it sets the current screen mode to the value in .A. For a list of possible values, see the basic statement <code>SCREEN</code>. If the mode is unsupported, c will be set, otherwise cleared.</p> <p>If you use this function to get the text resolution instead of calling <code>SCREEN</code>, this function only returns the text dimensions the currently configured mode would have set, ignoring any changes made by calls to <code>scnsiz</code>. If you want to fetch the KERNAL editor's text resolution, call <code>SCREEN</code> instead.</p> <p>EXAMPLE:</p> <pre><code>LDA #$80\nCLC\nJSR screen_mode ; SET 320x200@256C MODE\nBCS FAILURE\n</code></pre>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-screen_set_charset","title":"Function Name: screen_set_charset","text":"<p>Purpose: Activate a 8x8 text mode charset Call address: $FF62</p> <p>Communication registers: .A, .X, .Y Preparatory routines: None Registers affected: .A, .X, .Y</p> <p>Description: A call to this routine uploads a character set to the video hardware and activates it. The value of .A decides what charset to upload:</p> Value Description 0 use pointer in .X/.Y 1 ISO 2 PET upper/graph 3 PET upper/lower 4 PET upper/graph (thin) 5 PET upper/lower (thin) 6 ISO (thin) 7 CP437 (since r47) 8 Cyrillic ISO (since r47) 9 Cyrillic ISO (thin) (since r47) 10 Eastern Latin ISO (since r47) 11 Eastern ISO (thin) (since r47) <p>If .A is zero, .X (lo) and .Y (hi) contain a pointer to a 2 KB RAM area that gets uploaded as the new 8x8 character set. The data has to consist of 256 characters of 8 bytes each, top to bottom, with the MSB on the left, set bits (1) represent the foreground colored pixels.</p> <p>EXAMPLE:</p> <pre><code>LDA #0\nLDX #&lt;MY_CHARSET\nLDY #&gt;MY_CHARSET\nJSR screen_set_charset ; UPLOAD CUSTOM CHARSET \"MY_CHARSET\"\n</code></pre>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-jsrfar","title":"Function Name: JSRFAR","text":"<p>Purpose: Execute a routine on another RAM or ROM bank Call address: $FF6E Communication registers: None Preparatory routines: None Error returns: None Registers affected: None</p> <p>Description: The routine <code>JSRFAR</code> enables code to execute some other code located on a specific RAM or ROM bank. This works independently of which RAM or ROM bank the currently executing code is residing in. The 16 bit address and the 8 bit bank number have to follow the instruction stream. The <code>JSRFAR</code> routine will switch both the ROM and the RAM bank to the specified bank and restore it after the routine's <code>RTS</code>. Execution resumes after the 3 byte arguments. Note: The C128 also has a <code>JSRFAR</code> function at $FF6E, but it is incompatible with the X16 version.</p> <p>How to Use:</p> <p>1) Call this routine.</p> <p>EXAMPLE:</p> <pre><code>      JSR JSRFAR\n      .WORD $C000 ; ADDRESS\n      .BYTE 1     ; BANK\n</code></pre>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#65c816-support","title":"65C816 support","text":"<p>When writing native 65C816 code for the Commander X16, extra care must be given when using the KERNAL API. With the exception of <code>extapi16</code>, documented below, the entire kernal API must be called:</p> <ul> <li>With m=1, x=1 (accumulator and index are 8 bits)</li> <li>SP set to the KERNAL stack ($01xx). see</li> <li>DP=$0000 (must be set so that zeropage is the direct page)</li> </ul> <p>$FEA8: <code>extapi16</code> - 16-bit extended API for 65C816 native mode</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#function-name-extapi16","title":"Function Name: extapi16","text":"<p>Purpose: API functions for 65C816 Minimum ROM version: R47 Call address: $FEA8 Communication registers: .C, .X, .Y, .P Preparatory routines: None Error returns: Varies, but usually c=1 Registers affected: Varies</p> <p>Description: This API slot provides access to various native mode 65C816 calls. The call is selected by the .C register (accumulator), and each call has its own register use and return behavior.</p> <p>IMPORTANT * All of the calls behind this API must be called in native 65C816 mode, with m=0, .DP=$0000. * In addition, some of these must be called with <code>rom_bank</code> (zp address $01) set to bank 0 (the KERNAL bank) and not via KERNAL support in other ROM banks. If your program is launched from BASIC, the default bank is usually 4 until explicitly changed by your program.</p> Call # Name Description Inputs Outputs Additional Prerequisites <code>$00</code> <code>test</code> Used by unit tests .X .Y .C - <code>$01</code> <code>stack_push</code> Switches to a new stack context .X none x=0, $01=0 <code>$02</code> <code>stack_pop</code> Returns to the previous stack context none none x=0, $01=0 <code>$03</code> <code>stack_enter_kernal_stack</code> Switches to the $01xx stack none none x=0, $01=0 <code>$04</code> <code>stack_leave_kernal_stack</code> Returns to the previous stack context after <code>stack_enter_kernal_stack</code> none none x=0, $01=0"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#65c816-extapi16-function-name-test","title":"65C816 extapi16 Function Name: test","text":"<p>Purpose: Used by unit tests for jsrfar Minimum ROM version: R47 Call address: $FEA8, .C=0 Communication registers: .C .X .Y Preparatory routines: none Error returns: none Registers affected: .C</p> <p>Description: This API is used by unit tests and is not useful for applications.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#65c816-extapi16-function-name-stack_push","title":"65C816 extapi16 Function Name: stack_push","text":"<p>Purpose: Point the SP to a new stack Minimum ROM version: R47 Call address: $FEA8, .C=1 Communication registers: .X Preparatory routines: none Error returns: none Registers affected: .A .X .Y .P .SP</p> <p>Description: This function informs the KERNAL that you're moving the stack pointer to a new location so that it can preserve the previous SP, and then brings the new SP into effect. The main purpose of this call is to preserve the position of the $01xx stack pointer (AKA KERNAL stack), and to track the length of the chain of stacks in the case of multiple pushes. In order for the 65C02 code in the emulated mode IRQ handler to run properly, it must be able to temporarily switch to using the KERNAL stack, regardless of the SP in main code.</p> <p>How to Use:</p> <p>1) Ensure <code>rom_bank</code> (ZP $01) is set to <code>0</code>. This function will not work if it traverses through <code>jsrfar</code>. 2) Load .X with the new SP to switch to, then call the routine. Upon return, .SP will be set to the new stack value. If the stack chain depth is greater than 1, the new stack will also have the old stack's address pushed onto it. 3) To return to the previous stack context, call <code>stack_pop</code>.</p> <p>Notes:</p> <ul> <li>If you wish to preserve your current SP while temporarily switching back to the $01xx stack, for instance, to use the KERNAL API, begin that section of code with a call to <code>stack_enter_kernal_stack</code> and end with a call to <code>stack_leave_kernal_stack</code>.</li> </ul>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#65c816-extapi16-function-name-stack_pop","title":"65C816 extapi16 Function Name: stack_pop","text":"<p>Purpose: Point the SP to the previously-saved stack Minimum ROM version: R47 Call address: $FEA8, .C=2 Communication registers: none Preparatory routines: <code>stack_push</code> Error returns: none Registers affected: .A .X .Y .P .SP</p> <p>Description: This function informs the KERNAL that you're finished using the stack set previously by <code>stack_push</code>. It brings the previous SP into effect.</p> <p>How to Use:</p> <p>1) Ensure <code>rom_bank</code> (ZP $01) is set to <code>0</code>. This function will not work if it traverses through <code>jsrfar</code>. 2) Ensure the current SP is set to the same value that was set immediately after the return from <code>stack_push</code>. In other words, you cannot use this function to bail out early from a deep subroutine chain without taking care to reset the stack first. In addition, you cannot simply reset the stack to the value that you called <code>stack_push</code> with since the new stack may have had state pushed by the call to <code>stack_push</code>. 3) Call <code>stack_pop</code>.  The call will return to the address immediately after, but with the previously-pushed SP.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#65c816-extapi16-function-name-stack_enter_kernal_stack","title":"65C816 extapi16 Function Name: stack_enter_kernal_stack","text":"<p>Purpose: Point the SP to the previously-saved $01xx stack, preserving the current one Minimum ROM version: R47 Call address: $FEA8, .C=3 Communication registers: none Preparatory routines: <code>stack_push</code> Error returns: none Registers affected: .A .X .Y .P .SP</p> <p>Description: This function requests that the KERNAL temporarily bring the $01xx stack into effect during use a different stack. This is useful for applications which have moved the SP away from $01xx but need to call the KERNAL API or legacy code.</p> <p>How to Use:</p> <p>1) Ensure <code>rom_bank</code> (ZP $01) is set to <code>0</code>. This function will not work if it traverses through <code>jsrfar</code>. 2) A prior call to <code>stack_push</code> must be in effect that hasn't been undone by <code>stack_pop</code>, and the current SP must not be the default $01xx stack. 3) Call <code>stack_enter_kernal_stack</code>, call the legacy functions, then call <code>stack_leave_kernal_stack</code>.</p>"},{"location":"X16%20Reference%20-%2005%20-%20KERNAL/#65c816-extapi16-function-name-stack_leave_kernal_stack","title":"65C816 extapi16 Function Name: stack_leave_kernal_stack","text":"<p>Purpose: Point the SP to the previously-preserved stack Minimum ROM version: R47 Call address: $FEA8, .C=4 Communication registers: none Preparatory routines: <code>stack_enter_kernal_stack</code> Error returns: none Registers affected: .A .X .Y .P .SP</p> <p>Description: This function is the counterpart to <code>stack_enter_kernal_stack</code>, and restores the previously preserved stack.</p> <p>How to Use:</p> <p>1) Ensure <code>rom_bank</code> (ZP $01) is set to <code>0</code>. This function will not work if it traverses through <code>jsrfar</code>. 2) A prior call to <code>stack_enter_kernal_stack</code> must be in effect that hasn't been undone by this function. 3) Call <code>stack_leave_kernal_stack</code>.</p>"},{"location":"X16%20Reference%20-%2006%20-%20Math%20Library/","title":"6: Math Library","text":"<p>The Commander X16 contains a floating point Math library with a precision of 40 bits, which corresponds to 9 decimal digits. It is a stand-alone derivative of the library contained in Microsoft BASIC. Except for the different base address, it is compatible with the C128 and C65 libraries.</p> <p>The full documentation of these functions can be found in the book C128 Developers Package for Commodore 6502 Development. The Math Library documentation starts in Chapter 13. (PDF page 257)</p> <p>The following functions are available from machine language code after setting the ROM bank to 4, which is the default.</p>"},{"location":"X16%20Reference%20-%2006%20-%20Math%20Library/#format-conversions","title":"Format Conversions","text":"Address Symbol Description $FE00 <code>AYINT</code> convert floating point to integer (signed word) $FE03 <code>GIVAYF</code> convert integer (signed word) to floating point $FE06 <code>FOUT</code> convert floating point to ASCII string $FE09 <code>VAL_1</code> convert ASCII string in .X:.Y length in .A, to floating point in FACC. Caveat! Read below! $FE0C <code>GETADR</code> convert floating point to an address (unsigned word) $FE0F <code>FLOATC</code> convert address (unsigned word) to floating point <p>Important caveat ragarding the <code>VAL_1</code> routine in its current implementation:</p> <p>Unlike the other routines in the math library, this routine calls into the VAL implementation that is inside BASIC, and so it requires much of the BASIC zeropage to be intact to function correctly. The reason is that that routine ultimately relies on some internal BASIC routines that use a lot of BASIC zero page space. Ideally in the future, the <code>VAL_1</code> routine gets a new implementation that doesn't rely on the code in BASIC, thereby removing this restriction.</p> <p>X16 Additions</p> <p>The following calls are new to the X16 and were not part of the C128 math library API:</p> Address Symbol Description $FE87 <code>FLOAT</code> FACC = (s8).A   convert signed byte to float $FE8A <code>FLOATS</code> FACC = (s16)facho+1:facho $FE8D <code>QINT</code> facho:facho+1:facho+2:facho+3 = u32(FACC) $FE93 <code>FOUTC</code> Convert FACC to ASCIIZ string at fbuffr - 1 + .Y"},{"location":"X16%20Reference%20-%2006%20-%20Math%20Library/#movement","title":"Movement","text":"<p><code>PACK</code> indicates a conversion from a normalized floating-point number in FACC to its packed format in memory; <code>UNPACK</code> indicates a conversion from the packed format in memory to the normalized format in the destination.</p> Address Symbol Description $FE5A <code>CONUPK</code> ARG = UNPACK(RAM MEM) $FE5D <code>ROMUPK</code> ARG = UNPACK(ROM MEM) (use <code>CONUPK</code>) $FE60 <code>MOVFRM</code> FACC = UNPACK(RAM MEM) (use <code>MOVFM</code>) $FE63 <code>MOVFM</code> FACC = UNPACK(ROM MEM) $FE66 <code>MOVMF</code> MEM = PACK(ROUND(FACC)) $FE69 <code>MOVFA</code> FACC = ARG $FE6C <code>MOVAF</code> FACC = ROUND(FACC); ARG = FACC <p>X16 Additions</p> <p>The following calls are new to the X16 and were not part of the C128 math library API:</p> Address Symbol Description $FE81 <code>MOVEF</code> ARG = FACC"},{"location":"X16%20Reference%20-%2006%20-%20Math%20Library/#math-functions","title":"Math Functions","text":"Address Symbol Description $FE12 <code>FSUB</code> FACC = MEM - FACC $FE15 <code>FSUBT</code> FACC = ARG - FACC $FE18 <code>FADD</code> FACC = MEM + FACC $FE1B <code>FADDT</code> FACC = ARG + FACC $FE1E <code>FMULT</code> FACC = MEM * FACC $FE21 <code>FMULTT</code> FACC = ARG * FACC $FE24 <code>FDIV</code> FACC = MEM / FACC $FE27 <code>FDIVT</code> FACC = ARG / FACC $FE2A <code>LOG</code> FACC = natural log of FACC $FE2D <code>INT</code> FACC = INT() truncate of FACC $FE30 <code>SQR</code> FACC = square root of FACC $FE33 <code>NEGOP</code> negate FACC (switch sign) $FE36 <code>FPWR</code> FACC = raise ARG to the MEM power $FE39 <code>FPWRT</code> FACC = raise ARG to the FACC power $FE3C <code>EXP</code> FACC = EXP of FACC $FE3F <code>COS</code> FACC = COS of FACC $FE42 <code>SIN</code> FACC = SIN of FACC $FE45 <code>TAN</code> FACC = TAN of FACC $FE48 <code>ATN</code> FACC = ATN of FACC $FE4B <code>ROUND</code> FACC = round FACC $FE4E <code>ABS</code> FACC = absolute value of FACC $FE51 <code>SIGN</code> .A = test sign of FACC $FE54 <code>FCOMP</code> .A = compare FACC with MEM $FE57 <code>RND_0</code> FACC = random floating point number <p>X16 Additions to math functions</p> <p>The following calls are new to the X16 and were not part of the C128 math library API:</p> Address Symbol Description $FE6F <code>FADDH</code> FACC += .5 $FE72 <code>ZEROFC</code> FACC = 0 $FE75 <code>NORMAL</code> Normalize FACC $FE78 <code>NEGFAC</code> FACC = -FACC   (just use NEGOP) $FE7B <code>MUL10</code> FACC *= 10 $FE7E <code>DIV10</code> FACC /= 10 $FE84 <code>SGN</code> FACC = sgn(FACC) $FE90 <code>FINLOG</code> FACC += (s8).A   add signed byte to float $FE96 <code>POLYX</code> Polynomial Evaluation 1 (SIN/COS/ATN/LOG) $FE99 <code>POLY</code> Polynomial Evaluation 2 (EXP)"},{"location":"X16%20Reference%20-%2006%20-%20Math%20Library/#how-to-use-the-routines","title":"How to use the routines","text":"<p>Concepts:</p> <ul> <li>FACC (sometimes abbreviated to FAC): the floating point accumulator. You can compare this to the 6502 CPU's .A register,   which is the accumulator for most integer operations performed by the CPU.   FACC is the primary floating point register. Calculations are done on the value in this register,   usually combined with ARG. After the operation, usually the original value in FACC has been replaced by the result of the calculation.</li> <li>ARG: the second floating point register, used in most calculation functions. Often the value in this register will be lost after a calculation.</li> <li>MEM: means a floating point value stored in system memory somewhere.  The format is 40 bits (5 bytes) Microsoft binary format.   To be able to work with given values in calculations, they need to be stored in memory somewhere in this format.   To do this you'll likely need to use a separate program to pre-convert floating point numbers to this format, unless you are using a compiler that   directly supports it.</li> </ul> <p>Note that FACC and ARG are just a bunch of zero page locations. This means you can poke around in them. But that's not good practice because their locations aren't guaranteed/public, and the format is slightly different than how the 5-byte floats are normally stored into memory. Just use one of the Movement routines to copy values into or out of FACC and ARG.</p> <p>To perform a floating point calculation, follow the following pattern:</p> <ol> <li>load a value into FACC. You can convert an integer, or move a MEM float number into FACC.</li> <li>do the same but for ARG, the second floating point register.</li> <li>call the required floating point calculation routine that will perform a calculation on FACC with ARG.</li> <li>repeat the previous 2 steps if required.</li> <li>the result is in FACC, move it into MEM somewhere or convert it to another type or string.</li> </ol> <p>An example program that calculates and prints the distance an object has fallen over a certain period using the formula  $d = \\dfrac{1}{2} g {t}^{2}$</p> <pre><code>; calculate how far an object has fallen:  d = 1/2 * g * t^2.\n; we set g = 9.81 m/sec^2, time = 5 sec -&gt; d = 122.625 m.\n\nCHROUT = $ffd2\nFOUT   = $fe06\nFMULTT = $fe21\nFDIV   = $fe24\nCONUPK = $fe5a\nMOVFM  = $fe63\n\n    lda  #4\n    sta  $01         ; rom bank 4 (BASIC) contains the fp routines.\n    lda  #&lt;flt_two\n    ldy  #&gt;flt_two\n    jsr  MOVFM\n    lda  #&lt;flt_g\n    ldy  #&gt;flt_g\n    jsr  FDIV        ; FACC= g/2\n    lda  #&lt;flt_time\n    ldy  #&gt;flt_time\n    jsr  CONUPK      ; ARG = time\n    jsr  FMULTT      ; FACC = g/2 * time\n    lda  #&lt;flt_time\n    ldy  #&gt;flt_time\n    jsr  CONUPK      ; again ARG = time\n    jsr  FMULTT      ; FACC = g/2 * time * time\n    jsr  FOUT        ; to string\n    ; print string in AY\n    sta  $02\n    sty  $03\n    ldy  #0\nloop:\n    lda  ($02),y\n    beq  done\n    jsr  CHROUT\n    iny\n    bne  loop\ndone:\n    rts\n\nflt_g:      .byte  $84, $1c, $f5, $c2, $8f  ; float 9.81\nflt_time:   .byte  $83, $20, $00, $00, $00  ; float 5.0\nflt_two:    .byte  $82, $00, $00, $00, $00  ; float 2.0\n</code></pre>"},{"location":"X16%20Reference%20-%2006%20-%20Math%20Library/#notes","title":"Notes","text":"<ul> <li><code>RND_0</code>: For .Z=1, the X16 behaves differently than the C128 and C65 versions. The X16 version takes entropy from .A/.X/.Y instead of from a CIA timer. So in order to get a \"real\" random number, you would use code like this:</li> </ul> <pre><code>LDA #$00\nPHP\nJSR entropy_get ; KERNAL call to get entropy into .A/.X/.Y\nPLP             ; restore .Z=1\nJSR RND_0\n</code></pre> <ul> <li>The calls <code>FADDT</code>, <code>FMULTT</code>, <code>FDIVT</code> and <code>FPWRT</code> were broken on the C128/C65. They are fixed on the X16.</li> <li>For more information on the additional calls, refer to Mapping the Commodore 64 by Sheldon Leemon, ISBN 0-942386-23-X, but note these errata:</li> <li><code>FMULT</code> adds mem to FACC, not ARG to FACC</li> </ul>"},{"location":"X16%20Reference%20-%2007%20-%20Machine%20Language%20Monitor/","title":"7: Machine Language Monitor","text":"<p>The built-in machine language monitor can be started with the <code>MON</code> BASIC command. It is based on the monitor of the Final Cartridge III and supports most of its features.</p> <p>If you invoke the monitor by mistake, you can exit with by typing <code>X</code>, followed by the <code>RETURN</code> key.</p> <p>Some features specific to this monitor are:</p> <ul> <li>The <code>I</code> command prints a PETSCII/ISO-encoded memory dump.</li> <li>The <code>EC</code> command prints a binary memory dump. This is also useful for character sets.</li> <li>Scrolling the screen with the cursor keys or F3/F5 will continue memory dumps and disassemblies, and even disassemble backwards.</li> </ul> <p>The following commands are used to dump memory contents in various formats:</p> Dump Prefix description <code>M</code> <code>:</code> 8 hex bytes <code>I</code> <code>'</code> 32 PETSCII/ISO characters <code>EC</code> <code>[</code> 1 binary byte (character data) <code>ES</code> <code>]</code> 3 binary bytes (sprite data) <code>D</code> <code>,</code> disassemble <code>R</code> <code>;</code> registers <p>Except for <code>R</code>, these commands take a start address and an optional end address (inclusive). The dumps are prefixed with one of the \"Prefix\" characters in the table above, so they can be edited by navigating the cursor over a printed line, changing the data and pressing RETURN.</p> <p>Note that editing a disassembled line (prefix <code>,</code>) only allows changing the 1-3 opcode bytes. To edit the assembly, change the prefix to <code>A</code> (see below).</p> <p>These are the remaining commands:</p> Command Syntax Description <code>F</code> start end byte fill <code>H</code> start end byte [byte...] hunt <code>C</code> start end start compare <code>T</code> start end start transfer <code>A</code> address instruction assemble <code>G</code> [address] run code <code>J</code> [address] run subroutine <code>$</code> value convert hex to decimal <code>#</code> value convert decimal to hex <code>X</code> exit monitor <code>O</code> bank set ROM bank <code>K</code> bank set RAM/VRAM bank/I2C <code>L</code> [\"filename\"[,dev[,start]]] load file <code>S</code> \"filename\",dev,start,end save file <code>@</code> command send drive command <ul> <li>All addresses have to be 4 digits.</li> <li>All bytes have to be 2 digits (including device numbers).</li> <li>The end address of <code>S</code> is exclusive.</li> <li>The bank argument for <code>K</code> is</li> <li><code>00</code>-<code>FF</code>: switch to main RAM, set RAM bank</li> <li><code>V0</code>-<code>V1</code>: switch to Video RAM, set VRAM bank</li> <li><code>I</code>: switch to the I2C address space</li> <li>The bank argument for <code>O</code> is</li> <li><code>00</code>-<code>FF</code>: set ROM bank</li> <li><code>@</code> takes:</li> <li><code>8</code>, <code>9</code> to change the default drive (also for <code>L</code>)</li> <li><code>$</code> to display the disk directory</li> <li>anything else as a disk command</li> </ul>"},{"location":"X16%20Reference%20-%2008%20-%20Memory%20Map/","title":"8: Memory Map","text":"<p>The Commander X16 has 512 KB of ROM and 2,088 KB (2 MB[^1] + 40 KB) of RAM with up to 3.5MB of RAM or ROM available to cartridges.</p> <p>Some of the ROM/RAM is always visible at certain address ranges, while the remaining ROM/RAM is banked into one of two address windows.</p> <p>This is an overview of the X16 memory map:</p> Addresses Description $0000-$9EFF Fixed RAM (40 KB minus 256 bytes) $9F00-$9FFF I/O Area (256 bytes) $A000-$BFFF Banked RAM (8 KB window into one of 256 banks for a total of 2 MB) $C000-$FFFF Banked System ROM and Cartridge ROM/RAM (16 KB window into one of 256 banks, see below)"},{"location":"X16%20Reference%20-%2008%20-%20Memory%20Map/#banked-memory","title":"Banked Memory","text":"<p>Writing to the following zero-page addresses sets the desired RAM or ROM bank:</p> Address Description $0000 Current RAM bank (0-255) $0001 Current ROM/Cartridge bank (ROM is 0-31, Cartridge is 32-255) <p>The currently set banks can also be read back from the respective memory locations. Both settings default to 0 on RESET.</p>"},{"location":"X16%20Reference%20-%2008%20-%20Memory%20Map/#rom-allocations","title":"ROM Allocations","text":"<p>Here is the ROM/Cartridge bank allocation:</p> Bank Name Description 0 KERNAL KERNAL operating system and drivers 1 KEYBD Keyboard layout tables 2 CBDOS The computer-based CMDR-DOS for FAT32 SD cards 3 FAT32 The FAT32 driver itself 4 BASIC BASIC interpreter 5 MONITOR Machine Language Monitor 6 CHARSET PETSCII and ISO character sets (uploaded into VRAM) 7 DIAG Memory diagnostic 8 GRAPH Kernal graph and font routines 9 DEMO Demo routines 10 AUDIO Audio API routines 11 UTIL System Configuration (Date/Time, Display Preferences) 12 BANNEX BASIC Annex (code for some added BASIC functions) 13-14 X16EDIT The built-in text editor 15 BASLOAD A transpiler that converts BASLOAD dialect to BASIC V2 16-31 \u2013 [Currently unused] 32-255 \u2013 Cartridge RAM/ROM <p>Important: The layout of the banks may still change.</p>"},{"location":"X16%20Reference%20-%2008%20-%20Memory%20Map/#cartridge-allocation","title":"Cartridge Allocation","text":"<p>Cartridges can use the remaining 32-255 banks in any combination of ROM, RAM, Memory-Mapped IO, etc. See Kevin's reference cartridge design for ideas on how this may be used. This provides up to 3.5MB of additional RAM or ROM.</p> <p>Important: The layout of the banks is not yet final.</p>"},{"location":"X16%20Reference%20-%2008%20-%20Memory%20Map/#ram-contents","title":"RAM Contents","text":"<p>This is the allocation of fixed RAM in the KERNAL/BASIC environment.</p> Addresses Description $0000-$00FF Zero page $0100-$01FF CPU stack $0200-$03FF KERNAL and BASIC variables, vectors $0400-$07FF Available for machine code programs or custom data storage $0800-$9EFF BASIC program/variables; available to the user <p>The <code>$0400-$07FF</code> can be seen as the equivalent of <code>$C000-$CFFF</code> on a C64. A typical use would be for helper machine code called by BASIC.</p>"},{"location":"X16%20Reference%20-%2008%20-%20Memory%20Map/#zero-page","title":"Zero Page","text":"Addresses Description $0000-$0001 Banking registers $0002-$0021 16 bit registers r0-r15 for KERNAL API $0022-$007F Available to the user $0080-$009C Used by KERNAL and DOS $009D-$00A8 Reserved for DOS/BASIC $00A9-$00D3 Used by the Math library (and BASIC) $00D4-$00FF Used by BASIC <p>Machine code applications are free to reuse the BASIC area, and if they don't use the Math library, also that area.</p>"},{"location":"X16%20Reference%20-%2008%20-%20Memory%20Map/#banking","title":"Banking","text":"<p>This is the allocation of banked RAM in the KERNAL/BASIC environment.</p> Bank Description 0 Used for KERNAL/CMDR-DOS variables and buffers 1-255 Available to the user <p>(On systems with only 512 KB RAM, banks 64-255 are unavailable.)</p> <p>During startup, the KERNAL activates RAM bank 1 as the default for the user.</p>"},{"location":"X16%20Reference%20-%2008%20-%20Memory%20Map/#bank-0","title":"Bank 0","text":"Addresses Description $A000-$BEFF System Reserved $BF00-$BFFF Parameter passing space <p>You can use the space at $0:BF00-0:$BFFF to pass parameters between programs. This space is initalized to zeroes, so you may use it however you wish.</p> <p>The suggested use is to store a PETSCII string in this space and use semicolons to separate parameters. The string should be null terminated:</p> <p>Example:</p> <p><code>FRANK;3;BLUE\\x00</code></p> <p>A program that reads the parameters is responsible for resetting the data to zeroes, so that another program does not see unexpected data and malfunction.</p>"},{"location":"X16%20Reference%20-%2008%20-%20Memory%20Map/#io-area","title":"I/O Area","text":"<p>This is the memory map of the I/O Area:</p> Addresses Description Speed $9F00-$9F0F VIA I/O controller #1 8 MHz $9F10-$9F1F VIA I/O controller #2 8 MHz $9F20-$9F3F VERA video controller 8 MHz $9F40-$9F41 YM2151 audio controller 2 MHz $9F42-$9F5F Unavailable --- $9F60-$9F7F Expansion Card Memory Mapped IO3 8 MHz $9F80-$9F9F Expansion Card Memory Mapped IO4 8 MHz $9FA0-$9FBF Expansion Card Memory Mapped IO5 2 MHz $9FC0-$9FDF Expansion Card Memory Mapped IO6 2 MHz $9FE0-$9FFF Cartidge/Expansion Memory Mapped IO7 2 MHz"},{"location":"X16%20Reference%20-%2008%20-%20Memory%20Map/#expansion-cards-cartridges","title":"Expansion Cards &amp; Cartridges","text":"<p>Expansion cards can be accessed via memory-mapped I/O (MMIO), as well as I2C. Cartridges are essentially expansion cards which are housed in an external enclosure and may contain RAM, ROM and an I2C EEPOM (for save data). Internal expansion cards may also use the RAM/ROM space, though this could cause conflicts.</p> <p>While they may be uncomon, since cartridges are essentially external expansion cards in a shell, that means they can also use MMIO. This is only necessary when a cartridge includes some sort of hardware expansion and MMIO was desired (as opposed to using the I2C bus). In that case, it is recommended cartridges use the IO7 range and that range should be the last option used by expansion cards in the system. MMIO is unneeded for cartridges which simply have RAM/ROM.</p> <p>For more information, consult the Hardware section of the manual.</p> <p>[^1]: Current development systems have 2 MB of bankable RAM. Actual hardware is currently planned to have an option of either 512 KB or 2 MB of RAM.</p>"},{"location":"X16%20Reference%20-%2009%20-%20VERA%20Programmer%27s%20Reference/","title":"9: VERA Programmer's Reference","text":"<p>This document describes the Versatile Embedded Retro Adapter or VERA. Which was originally written and conceived by Frank van den Hoef.</p> <p>The VERA video chip supports resolutions up to 640x480 with up to 256 colors from a palette of 4096, two layers of either a bitmap or tiles, 128 sprites of up to 64x64 pixels in size. It can output VGA as well as a 525 line interlaced signal, either as NTSC or as RGB (Amiga-style).</p> <p>The FPGA core used in the Commander X16 has been forked from Version 0.9 of the VERA. The original documentation can be found here.</p> <p>The Commander X16 uses a modified version of VERA which includes extra functionality, notably the FX Aid additions. See Chapter 10 for more information on the FX additions.</p> <p>The VERA consists of:</p> <ul> <li>Video generator featuring:</li> <li>Multiple output formats (VGA, NTSC Composite, NTSC S-Video, RGB video) at a fixed resolution of 640x480@60Hz</li> <li>Support for 2 layers, both supporting either tile or bitmap mode.</li> <li>Support for up to 128 sprites.</li> <li>Embedded video RAM of 128kB.</li> <li>Palette with 256 colors selected from a total range of 4096 colors.</li> <li>16-channel Programmable Sound Generator with multiple waveforms (Pulse, Sawtooth, Triangle, Noise)</li> <li>High quality PCM audio playback from an 4kB FIFO buffer featuring up to 48kHz 16-bit stereo sound.</li> <li>SPI controller for SecureDigital storage.</li> </ul>"},{"location":"X16%20Reference%20-%2009%20-%20VERA%20Programmer%27s%20Reference/#registers","title":"Registers","text":"Addr Name Bit\u00a07 Bit\u00a06 Bit\u00a05  Bit\u00a04 Bit\u00a03  Bit\u00a02 Bit\u00a01  Bit\u00a00 $9F20 ADDRx_L (x=ADDRSEL) VRAM Address (7:0) $9F21 ADDRx_M (x=ADDRSEL) VRAM Address (15:8) $9F22 ADDRx_H (x=ADDRSEL) Address Increment DECR Nibble Increment Nibble Address VRAM Address (16) $9F23 DATA0 VRAM Data port 0 $9F24 DATA1 VRAM Data port 1 $9F25 CTRL Reset DCSEL ADDRSEL $9F26 IEN IRQ line (8) Scan line (8) - AFLOW SPRCOL LINE VSYNC $9F27 ISR Sprite collisions AFLOW SPRCOL LINE VSYNC $9F28 IRQLINE_L (Write only) IRQ line (7:0) $9F28 SCANLINE_L (Read only) Scan line (7:0) $9F29 DC_VIDEO (DCSEL=0) Current Field Sprites Enable Layer1 Enable Layer0 Enable NTSC/RGB: 240P NTSC: Chroma Disable / RGB: HV Sync  Output Mode $9F2A DC_HSCALE(DCSEL=0) Active Display H-Scale $9F2B DC_VSCALE(DCSEL=0) Active Display V-Scale $9F2C DC_BORDER(DCSEL=0) Border Color $9F29 DC_HSTART(DCSEL=1) Active Display H-Start (9:2) $9F2A DC_HSTOP(DCSEL=1) Active Display H-Stop (9:2) $9F2B DC_VSTART(DCSEL=1) Active Display V-Start (8:1) $9F2C DC_VSTOP(DCSEL=1) Active Display V-Stop (8:1) $9F29 FX_CTRL(DCSEL=2) Transp. Writes Cache Write Enable Cache Fill Enable One-byte Cache Cycling 16-bit Hop 4-bit Mode Addr1 Mode $9F2A FX_TILEBASE(DCSEL=2)(Write only) FX Tile Base Address (16:11) Affine Clip Enable 2-bit Polygon $9F2B FX_MAPBASE(DCSEL=2)(Write only) FX Map Base Address (16:11) Map Size $9F2C FX_MULT(DCSEL=2)(Write only) Reset Accum. Accumulate Subtract Enable Multiplier Enable Cache Byte Index Cache Nibble Index Two-byte Cache Incr. Mode $9F29 FX_X_INCR_L(DCSEL=3)(Write only) X Increment (-2:-9) (signed) $9F2A FX_X_INCR_H(DCSEL=3)(Write only) X Incr. 32x X Increment (5:-1) (signed) $9F2B FX_Y_INCR_L(DCSEL=3)(Write only) Y/X2 Increment (-2:-9) (signed) $9F2C FX_Y_INCR_H(DCSEL=3)(Write only) Y/X2 Incr. 32x Y/X2 Increment (5:-1) (signed) $9F29 FX_X_POS_L(DCSEL=4)(Write only) X Position (7:0) $9F2A FX_X_POS_H(DCSEL=4)(Write only) X Pos. (-9) - X Position (10:8) $9F2B FX_Y_POS_L(DCSEL=4)(Write only) Y/X2 Position (7:0) $9F2C FX_Y_POS_H(DCSEL=4)(Write only) Y/X2 Pos. (-9) - Y/X2 Position (10:8) $9F29 FX_X_POS_S(DCSEL=5)(Write only) X Postion (-1:-8) $9F2A FX_Y_POS_S(DCSEL=5)(Write only) Y/X2 Postion (-1:-8) $9F2B FX_POLY_FILL_L(DCSEL=5, 4-bit Mode=0)(Read only) Fill Len &gt;= 16 X Position (1:0) Fill Len (3:0) 0 $9F2B FX_POLY_FILL_L(DCSEL=5, 4-bit Mode=1, 2-bit Polygon=0)(Read only) Fill Len &gt;= 8 X Position (1:0) X Pos. (2) Fill Len (2:0) 0 $9F2B FX_POLY_FILL_L(DCSEL=5, 4-bit Mode=1, 2-bit Polygon=1)(Read only) X2 Pos. (-1) X Position (1:0) X Pos. (2) Fill Len (2:0) X Pos. (-1) $9F2C FX_POLY_FILL_H(DCSEL=5)(Read only) Fill Len (9:3) 0 $9F29 FX_CACHE_L(DCSEL=6)(Write only) Cache (7:0) | Multiplicand (7:0) (signed) $9F29 FX_ACCUM_RESET(DCSEL=6)(Read only) Reset Accumulator $9F2A FX_CACHE_M(DCSEL=6)(Write only) Cache (15:8) | Multiplicand (15:8) (signed) $9F2A FX_ACCUM(DCSEL=6)(Read only) Accumulate $9F2B FX_CACHE_H(DCSEL=6)(Write only) Cache (23:16) | Multiplier (7:0) (signed) $9F2C FX_CACHE_U(DCSEL=6)(Write only) Cache (31:24) | Multiplier (15:8) (signed) $9F29 DC_VER0(DCSEL=63)(Read only) The ASCII character \"V\" $9F2A DC_VER1(DCSEL=63)(Read only) Major release $9F2B DC_VER2(DCSEL=63)(Read only) Minor release $9F2C DC_VER3(DCSEL=63)(Read only) Minor build number $9F2D L0_CONFIG Map Height Map Width T256C Bitmap Mode Color Depth $9F2E L0_MAPBASE Map Base Address (16:9) $9F2F L0_TILEBASE Tile Base Address (16:11) Tile Height Tile Width $9F30 L0_HSCROLL_L H-Scroll (7:0) $9F31 L0_HSCROLL_H - H-Scroll (11:8) $9F32 L0_VSCROLL_L V-Scroll (7:0) $9F33 L0_VSCROLL_H - V-Scroll (11:8) $9F34 L1_CONFIG Map Height Map Width T256C Bitmap Mode Color Depth $9F35 L1_MAPBASE Map Base Address (16:9) $9F36 L1_TILEBASE Tile Base Address (16:11) Tile Height Tile Width $9F37 L1_HSCROLL_L H-Scroll (7:0) $9F38 L1_HSCROLL_H - H-Scroll (11:8) $9F39 L1_VSCROLL_L V-Scroll (7:0) $9F3A L1_VSCROLL_H - V-Scroll (11:8) $9F3B AUDIO_CTRL FIFO Full / FIFO Reset FIFO Empty(read-only) 16-Bit Stereo PCM Volume FIFO Loop (write-only) $9F3C AUDIO_RATE PCM Sample Rate $9F3D AUDIO_DATA Audio FIFO data (write-only) $9F3E SPI_DATA Data $9F3F SPI_CTRL Busy - Slow clock Select"},{"location":"X16%20Reference%20-%2009%20-%20VERA%20Programmer%27s%20Reference/#vram-address-space-layout","title":"VRAM address space layout","text":"Address range Description $0:0000 - $1:F9BF Video RAM $1:F9C0 - $1:F9FF PSG registers $1:FA00 - $1:FBFF Palette $1:FC00 - $1:FFFF Sprite attributes <p>The X16 KERNAL uses the following video memory layout:</p> Addresses Description $0:0000-$1:2BFF 320x240@256c Bitmap $1:2C00-$1:2FFF unused (1024 bytes) $1:3000-$1:AFFF Sprite Image Data (up to $1000 per sprite at 64x64 8-bit) $1:B000-$1:EBFF Text Mode $1:EC00-$1:EFFF unused (1024 bytes) $1:F000-$1:F7FF Charset $1:F800-$1:F9BF unused (448 bytes) $1:F9C0-$1:F9FF VERA PSG Registers (16 x 4 bytes) $1:FA00-$1:FBFF VERA Color Palette (256 x 2 bytes) $1:FC00-$1:FFFF VERA Sprite Attributes (128 x 8 bytes) <p>This memory map is not fixed: All of the address space between $0:0000 and $1:F9BF is available for any use in your programs, if you do not need text displayed by KERNAL or BASIC. This includes allocating multiple text or graphic buffers, or simply re-arranging the buffers to allow for certain tile set layouts. Just be aware that once you move things around, you'll have to fully manage your bitmaps, tiles, and text/tile buffers.</p> <p>To restore the standard text mode, call <code>CINT</code> ($FF81). This will reset the screen to the default screen mode. If you have configured custom settings in your NVRAM, these will be used.</p> <p>Also, the registers in $1:F9C0-$1:FFFF are actually write-only. However, they share the same address as part of the video RAM. Be aware that when you read back the register data, you are actually reading the last value sent by the host system, which is not necessarily the value in the register. To make sure this data is filled with known values, we recommend fully initializng the registers before use. Normally, the X16 KERNAL handles this for you, but if you are writing a cartridge program, using the system with a custom ROM, or even running VERA on another computer, then you'll need to make sure this block gets initialized to known values.</p>"},{"location":"X16%20Reference%20-%2009%20-%20VERA%20Programmer%27s%20Reference/#video-ram-access","title":"Video RAM access","text":"<p>The video RAM (VRAM) isn't directly accessible on the CPU bus. VERA only exposes an address space of 32 bytes to the CPU as described in the section Registers. To access the VRAM (which is 128kB in size) an indirection mechanism is used. First the address to be accessed needs to be set (ADDRx_L/ADDRx_M/ADDRx_H) and then the data on that VRAM address can be read from or written to via the DATA0/1 register. To make accessing the VRAM more efficient an auto-increment mechanism is present.</p> <p>There are 2 data ports to the VRAM. Which can be accessed using DATA0 and DATA1. The address and increment associated with the data port is specified in ADDRx_L/ADDRx_M/ADDRx_H. These 3 registers are multiplexed using the ADDR_SEL in the CTRL register. When ADDR_SEL = 0, ADDRx_L/ADDRx_M/ADDRx_H become ADDR0_L/ADDR0_M/ADDR0_H. When ADDR_SEL = 1, ADDRx_L/ADDRx_M/ADDRx_H become ADDR1_L/ADDR1_M/ADDR1_H.</p> <p>By setting the 'Address Increment' field in ADDRx_H, the address will be increment after each access to the data register. The increment register values and corresponding increment amounts are shown in the following table:</p> Register value Increment amount 0 0 1 1 2 2 3 4 4 8 5 16 6 32 7 64 8 128 9 256 10 512 11 40 12 80 13 160 14 320 15 640 <p>Setting the DECR bit, will decrement instead of increment by the value set by the 'Address Increment' field.</p>"},{"location":"X16%20Reference%20-%2009%20-%20VERA%20Programmer%27s%20Reference/#reset","title":"Reset","text":"<p>When RESET in CTRL is set to 1, the FPGA will reconfigure itself. All registers will be reset. The palette RAM will be set to its default values.</p>"},{"location":"X16%20Reference%20-%2009%20-%20VERA%20Programmer%27s%20Reference/#interrupts","title":"Interrupts","text":"<p>Interrupts will be generated for the interrupt sources set in the lower 4 bits of IEN. ISR will indicate the interrupts that have occurred. Writing a 1 to one of the lower 3 bits in ISR will clear that interrupt status. AFLOW can only be cleared by filling the audio FIFO for at least 1/4.</p> <p>IRQ_LINE (write-only) specifies at which line the LINE interrupt will be generated. Note that bit 8 of this value is present in the IEN register. For interlaced modes the interrupt will be generated each field and the bit 0 of IRQ_LINE is ignored.</p> <p>SCANLINE (read-only) indicates the current scanline being sent to the screen. Bit 8 of this value is present in the IEN register. The value is 0 during the first visible line and 479 during the last. This value continues to count beyond the last visible line, but returns $1FF for lines 512-524 that are beyond its 9-bit resolution. SCANLINE is not affected by interlaced modes and will return either all even or all odd values during an even or odd field, respectively. Note that VERA renders lines ahead of scanout such that line 1 is being rendered while line 0 is being scanned out. Visible changes may be delayed one scanline because of this.</p> <p>The upper 4 (read-only) bits of the ISR register contain the sprite collisions as determined by the sprite renderer.</p>"},{"location":"X16%20Reference%20-%2009%20-%20VERA%20Programmer%27s%20Reference/#display-composer","title":"Display composer","text":"<p>The display composer is responsible of combining the output of the 2 layer renderers and the sprite renderer into the image that is sent to the video output.</p> <p>The video output mode can be selected using OUT_MODE in DC_VIDEO.</p> OUT_MODE Description 0 Video disabled 1 VGA output 2 NTSC (composite/S-Video) 3 RGB 15KHz, composite or separate H/V sync, via VGA connector <p>Setting 'Chroma Disable' disables output of chroma in NTSC composite mode and will give a better picture on a monochrome display. (Setting this bit will also disable the chroma output on the S-video output.)</p> <p>Setting 'HV Sync' enables separate HSync/VSync signals in RGB output mode. Clearing the bit will enable the default of composite sync over RGB.</p> <p>Setting '240P' enables 240P progressive mode over NTSC or RGB. It has no effect if the VGA output mode is active. Instead of 262.5 scanlines per field, this mode outputs 263 scanlines per field.  On CRT displays, the scanlines from both the even and odd fields will be displayed on even scanlines.</p> <p>'Current Field' is a read-only bit which reflects the active interlaced field in composite and RGB modes. In non-interlaced modes, this reflects if the current line is even or odd. (0: even, 1: odd)</p> <p>Setting 'Layer0 Enable' / 'Layer1 Enable' / 'Sprites Enable' will respectively enable output from layer0 / layer1 and the sprites renderer.</p> <p>DC_HSCALE and DC_VSCALE will set the fractional scaling factor of the active part of the display. Setting this value to 128 will output 1 output pixel for every input pixel. Setting this to 64 will output 2 output pixels for every input pixel.</p> <p>DC_BORDER determines the palette index which is used for the non-active area of the screen.</p> <p>DC_HSTART/DC_HSTOP and DC_VSTART/DC_VSTOP determines the active part of the screen. The values here are specified in the native 640x480 display space. HSTART=0, HSTOP=640, VSTART=0, VSTOP=480 will set the active area to the full resolution. Note that the lower 2 bits of DC_HSTART/DC_HSTOP and the lower 1 bit of DC_VSTART/DC_VSTOP isn't available. This means that horizontally the start and stop values can be set at a multiple of 4 pixels, vertically at a multiple of 2 pixels.</p> <p>DC_VER0, DC_VER1, DC_VER2, and DC_VER3 can be queried for the version number of the VERA bitstream.  If reading DC_VER0 returns <code>$56</code>, the remaining registers returns values forming the major, minor, and build numbers respectively.  If DC_VER0 returns a value other than <code>$56</code>, the VERA bitstream version number is undefined.</p>"},{"location":"X16%20Reference%20-%2009%20-%20VERA%20Programmer%27s%20Reference/#layer-01-registers","title":"Layer 0/1 registers","text":"<p>'Map Base Address' specifies the base address of the tile map. Note that the register only specifies bits 16:9 of the address, so the address is always aligned to a multiple of 512 bytes.</p> <p>'Tile Base Address' specifies the base address of the tile data. Note that the register only specifies bits 16:11 of the address, so the address is always aligned to a multiple of 2048 bytes.</p> <p>'H-Scroll' specifies the horizontal scroll offset. A value between 0 and 4095 can be used. Increasing the value will cause the picture to move left, decreasing will cause the picture to move right.</p> <p>'V-Scroll' specifies the vertical scroll offset. A value between 0 and 4095 can be used. Increasing the value will cause the picture to move up, decreasing will cause the picture to move down.</p> <p>'Map Width', 'Map Height' specify the dimensions of the tile map:</p> Value Map width / height 0 32 tiles 1 64 tiles 2 128 tiles 3 256 tiles <p>'Tile Width', 'Tile Height' specify the dimensions of a single tile:</p> Value Tile width / height 0 8 pixels 1 16 pixels <p>In bitmap modes, the 'H-Scroll (11:8)' register is used to specify the palette offset for the bitmap.</p>"},{"location":"X16%20Reference%20-%2009%20-%20VERA%20Programmer%27s%20Reference/#layer-display-modes","title":"Layer display modes","text":"<p>The features of the 2 layers are the same. Each layer supports a few different modes which are specified using T256C / 'Bitmap Mode' / 'Color Depth' in Lx_CONFIG.</p> <p>'Color Depth' specifies the number of bits used per pixel to encode color information:</p> Color Depth Description 0 1 bpp 1 2 bpp 2 4 bpp 3 8 bpp <p>The layer can either operate in tile mode or bitmap mode. This is selected using the 'Bitmap Mode' bit; 0 selects tile mode, 1 selects bitmap mode.</p> <p>The handling of 1 bpp tile mode is different from the other tile modes. Depending on the T256C bit the tiles use either a 16-color foreground and background color or a 256-color foreground color. Other modes ignore the T256C bit.</p>"},{"location":"X16%20Reference%20-%2009%20-%20VERA%20Programmer%27s%20Reference/#tile-mode-1-bpp-16-color-text-mode","title":"Tile mode 1 bpp (16 color text mode)","text":"<p>T256C should be set to 0.</p> <p>MAP_BASE points to a tile map containing tile map entries, which are 2 bytes each:</p> Offset Bit\u00a07 Bit\u00a06 Bit\u00a05 Bit\u00a04 Bit\u00a03 Bit\u00a02 Bit\u00a01 Bit\u00a00 0 Character index 1 Background color Foreground color <p>TILE_BASE points to the tile data.</p> <p>Each bit in the tile data specifies one pixel. If the bit is set the foreground color as specified in the map data is used, otherwise the background color as specified in the map data is used.</p>"},{"location":"X16%20Reference%20-%2009%20-%20VERA%20Programmer%27s%20Reference/#tile-mode-1-bpp-256-color-text-mode","title":"Tile mode 1 bpp (256 color text mode)","text":"<p>T256C should be set to 1.</p> <p>MAP_BASE points to a tile map containing tile map entries, which are 2 bytes each:</p> Offset Bit\u00a07 Bit\u00a06 Bit\u00a05 Bit\u00a04 Bit\u00a03 Bit\u00a02 Bit\u00a01 Bit\u00a00 0 Character index 1 Foreground color <p>TILE_BASE points to the tile data.</p> <p>Each bit in the tile data specifies one pixel. If the bit is set the foreground color as specified in the map data is used, otherwise color 0 is used (transparent).</p>"},{"location":"X16%20Reference%20-%2009%20-%20VERA%20Programmer%27s%20Reference/#tile-mode-248-bpp","title":"Tile mode 2/4/8 bpp","text":"<p>MAP_BASE points to a tile map containing tile map entries, which are 2 bytes each:</p> Offset Bit\u00a07 Bit\u00a06 Bit\u00a05 Bit\u00a04 Bit\u00a03 Bit\u00a02 Bit\u00a01 Bit\u00a00 0 Tile index (7:0) 1 Palette offset V-flip H-flip Tile index (9:8) <p>TILE_BASE points to the tile data.</p> <p>Each pixel in the tile data gives a color index of either 0-3 (2bpp), 0-15 (4bpp), 0-255 (8bpp). This color index is modified by the palette offset in the tile map data using the following logic:</p> <ul> <li>Color index 0 (transparent) and 16-255 are unmodified.</li> <li>Color index 1-15 is modified by adding 16 x palette offset.</li> <li>T256C causes bit 7 of the color index to become 1.</li> </ul> <p>Note that 2bpp mode packs 4 pixels per byte and 4bpp mode packs 2 pixels per byte. For packed pixels, bit 7 refers to the leftmost pixel and bit 0 refers to the rightmost pixel.</p>"},{"location":"X16%20Reference%20-%2009%20-%20VERA%20Programmer%27s%20Reference/#bitmap-mode-1248-bpp","title":"Bitmap mode 1/2/4/8 bpp","text":"<p>MAP_BASE isn\u2019t used in these modes. TILE_BASE points to the bitmap data.</p> <p>TILEW specifies the bitmap width. TILEW=0 results in 320 pixels width and TILEW=1 results in 640 pixels width.</p> <p>The palette offset (in 'H-Scroll (11:8)'), as well as T256C in non-1bpp mode modifies the color indexes of the bitmap in the same way as in the tile modes.</p>"},{"location":"X16%20Reference%20-%2009%20-%20VERA%20Programmer%27s%20Reference/#spi-controller","title":"SPI controller","text":"<p>The SPI controller is connected to the SD card connector. The speed of the clock output of the SPI controller can be controlled by the 'Slow Clock' bit. When this bit is 0 the clock is 12.5MHz, when 1 the clock is about 390kHz. The slow clock speed is to be used during the initialization phase of the SD card. Some SD cards require a clock less than 400kHz during part of the initialization.</p> <p>A transfer can be started by writing to SPI_DATA. While the transfer is in progress the BUSY bit will be set. After the transfer is done, the result can be read from the SPI_DATA register.</p> <p>The chip select can be controlled by writing the SELECT bit. Writing 1 will assert the chip-select (logic-0) and writing 0 will release the chip-select (logic-1).</p>"},{"location":"X16%20Reference%20-%2009%20-%20VERA%20Programmer%27s%20Reference/#palette","title":"Palette","text":"<p>The palette translates 8-bit color indexes into 12-bit output colors. The palette has 256 entries, each with the following format:</p> Offset Bit\u00a07 Bit\u00a06 Bit\u00a05 Bit\u00a04 Bit\u00a03 Bit\u00a02 Bit\u00a01 Bit\u00a00 0 Green Blue 1 - Red <p>At reset, the palette will contain a predefined palette:</p> <p></p> <ul> <li>Color indexes 0-15 contain a palette somewhat similar to the C64 color palette.</li> <li>Color indexes 16-31 contain a grayscale ramp.</li> <li>Color indexes 32-255 contain various hues, saturation levels, brightness levels.</li> </ul>"},{"location":"X16%20Reference%20-%2009%20-%20VERA%20Programmer%27s%20Reference/#sprite-attributes","title":"Sprite attributes","text":"<p>128 entries of the following format:</p> Offset Bit\u00a07 Bit\u00a06 Bit\u00a05 Bit\u00a04 Bit\u00a03 Bit\u00a02 Bit\u00a01 Bit\u00a00 0 Address (12:5) 1 Mode - Address (16:13) 2 X (7:0) 3 - X (9:8) 4 Y (7:0) 5 - Y (9:8) 6 Collision mask Z-depth V-flip H-flip 7 Sprite height Sprite width Palette offset Mode Description 0 4 bpp 1 8 bpp Z-depth Description 0 Sprite disabled 1 Sprite between background and layer 0 2 Sprite between layer 0 and layer 1 3 Sprite in front of layer 1 Sprite width / height Description 0 8 pixels 1 16 pixels 2 32 pixels 3 64 pixels <p>Rendering Priority The sprite memory location dictates the order in which it is rendered. The sprite whose attributes are at the lowest location will be rendered in front of all other sprites; the sprite at the highest location will be rendered behind all other sprites, and so forth.</p> <p>Palette offset works in the same way as with the layers.</p>"},{"location":"X16%20Reference%20-%2009%20-%20VERA%20Programmer%27s%20Reference/#sprite-collisions","title":"Sprite collisions","text":"<p>At the start of the vertical blank Collisions in ISR is updated. This field indicates which groups of sprites have collided. If the field is non-zero the SPRCOL interrupt will be set. The interrupt is generated once per field / frame and can be cleared by making sure the sprites no longer collide.</p> <p>Note that collisions are only detected on lines that are actually rendered. This can result in subtle differences between non-interlaced and interlaced video modes.</p>"},{"location":"X16%20Reference%20-%2009%20-%20VERA%20Programmer%27s%20Reference/#vera-fx","title":"VERA FX","text":"<p>The FX feature set is available in VERA firmware version v0.3.1 or later. The Commander X16 emulators also have this feature officially as of R44.</p> <p>FX is a set of mainly addressing mode changes. VERA FX does not accelerate rendering, but it merely assists the CPU with some of the slower tasks, and when used cleverly, can allow for the programmer to perform some limited perspective transforms or basic 3D effects.</p> <p>FX features are controlled mainly by registers $9F29-$9F2C with DCSEL set to 2 through 6.  FX_CTRL ($9F29 w/ DCSEL=2) is the master switch for enabling or disabling FX behaviors.  When writing an application that uses FX, it is important that the FX mode be preserved and disabled in interrupt handlers in cases where the handler accesses VERA registers or VRAM, including the PSG sound registers. Reading from FX_CTRL returns the current state, and writing 0 to FX_CTRL suspends the FX behaviors so that the VERA can be accessed normally without mutating other FX state.</p> <p>Preliminary documentation for the feature can be found in Chapter 10, but as this is a brand new  feature, examples and documentation still need to be written.</p>"},{"location":"X16%20Reference%20-%2009%20-%20VERA%20Programmer%27s%20Reference/#programmable-sound-generator-psg","title":"Programmable Sound Generator (PSG)","text":"<p>The audio functionality contains of 2 independent systems. The first is the PSG or Programmable Sound Generator. The second is the PCM (or Pulse-Code Modulation) playback system.</p> <p>16 entries (channels) of the following format:</p> Offset Bit\u00a07 Bit\u00a06 Bit\u00a05 Bit\u00a04 Bit\u00a03 Bit\u00a02 Bit\u00a01 Bit\u00a00 0 Frequency word (7:0) 1 Frequency word (15:8) 2 Right Left Volume 3 Waveform Pulse width <p>Frequency word sets the frequency of the sound. The formula for calculating the output frequency is:</p> <pre><code>sample_rate = 25MHz / 512 = 48828.125 Hz\n\noutput_frequency = sample_rate / (2^17) * frequency_word\n</code></pre> <p>Thus the output frequency can be set in steps of about 0.373 Hz.</p> <p>Example: to output a frequency of 440Hz (note A4) the Frequency word should be set to  440 / (48828.125 / (2^17)) = 1181</p> <p>Volume controls the volume of the sound with a logarithmic curve; 0 is silent, 63 is the loudest. The Left and Right bits control to which output channels the sound should be output.</p> <p>Waveform controls the waveform of the sound:</p> Waveform Description 0 Pulse 1 Sawtooth 2 Triangle 3 Noise <p>Pulse width controls the duty cycle of the pulse waveform. A value of 63 will give a 50% duty cycle or square wave, 0 will give a very narrow pulse.</p> <p>Just like the other waveform types, the frequency of the noise waveform can be controlled using frequency. In this case a higher frequency will give brighter noise and a lower value will give darker noise.</p>"},{"location":"X16%20Reference%20-%2009%20-%20VERA%20Programmer%27s%20Reference/#pcm-audio","title":"PCM audio","text":"<p>For PCM playback, VERA contains a 4kB FIFO buffer. This buffer needs to be filled in a timely fashion by the CPU. To facilitate this an AFLOW (Audio FIFO low) interrupt can be generated when the FIFO is less than 1/4 filled.</p>"},{"location":"X16%20Reference%20-%2009%20-%20VERA%20Programmer%27s%20Reference/#audio-registers","title":"Audio registers","text":""},{"location":"X16%20Reference%20-%2009%20-%20VERA%20Programmer%27s%20Reference/#audio_ctrl-9f3b","title":"<code>AUDIO_CTRL ($9F3B)</code>","text":"<p>FIFO Full (bit 7) is a read-only flag that indicates whether the FIFO is full. Any writes to the FIFO while this flag is 1 will be ignored. Writing a 1 to this register (FIFO Reset) will perform a FIFO reset, which will clear the contents of the FIFO buffer, except when written in combination with a 1 in bit 6.</p> <p>FIFO Loop (bit 6+7): If a 1 is written to both bit 6 and 7 (at the same time), the FIFO will loop when played. Any other write to AUDIO_CTRL clears this loop flag.  Note: this feature is currently only available in x16-emulator and is not in any released VERA firmware.</p> <p>FIFO Empty (bit 6) is a read-only flag that indicates whether the FIFO is empty.</p> <p>16-bit (bit 5) sets the data format to 16-bit. If this bit is 0, 8-bit data is expected.</p> <p>Stereo (bit 4) sets the data format to stereo. If this bit is 0 (mono), the same audio data is send to both channels.</p> <p>PCM Volume (bits 0..3)controls the volume of the PCM playback, this has a logarithmic curve. A value of 0 is silence, 15 is the loudest.</p>"},{"location":"X16%20Reference%20-%2009%20-%20VERA%20Programmer%27s%20Reference/#audio_rate-9f3c","title":"<code>AUDIO_RATE ($9F3C)</code>","text":"<p>PCM sample rate controls the speed at which samples are read from the FIFO. A few example values:</p> PCM sample rate Description 128 normal speed   (25MHz / 512 = 48828.125 Hz) 64 half speed     (24414 Hz) 32 quarter speed  (12207 Hz) 0 stop playback &gt;128 invalid <p>Using a value of 128 will give the best quality (lowest distortion); at this value for every output sample, an input sample from the FIFO is read. Lower values will output the same sample multiple times to the audio DAC. Input samples are always read as a complete set (being 1/2/4 bytes).</p>"},{"location":"X16%20Reference%20-%2009%20-%20VERA%20Programmer%27s%20Reference/#audio_data-9f3d","title":"<code>AUDIO_DATA ($9F3D)</code>","text":"<p>Audio FIFO data Writes to this register add one byte to the PCM FIFO. If the FIFO is full, the write will be ignored.</p> <p>NOTE: When setting up for PCM playback it is advised to first set the sample rate at 0 to stop playback. First fill the FIFO buffer with some initial data and then set the desired sample rate. This can prevent undesired FIFO underruns.</p>"},{"location":"X16%20Reference%20-%2009%20-%20VERA%20Programmer%27s%20Reference/#audio-data-formats","title":"Audio data formats","text":"<p>Audio data is two's complement signed. Depending on the selected mode the data needs to be written to the FIFO in the following order:</p> Mode Order in which to write data to FIFO 8-bit mono &lt;mono sample&gt; 8-bit stereo &lt;left sample&gt; &lt;right sample&gt; 16-bit mono &lt;mono sample (7:0)&gt; &lt;mono sample (15:8)&gt; 16-bit stereo &lt;left sample (7:0)&gt; &lt;left sample (15:8)&gt; &lt;right sample (7:0)&gt; &lt;right sample (15:8)&gt;"},{"location":"X16%20Reference%20-%2010%20-%20VERA%20FX%20Reference/","title":"10: VERA FX Reference","text":"<p>Author: MooingLemur, based on documentation written by JeffreyH</p> <p>This is preliminary documentation and the specification can still change at any point.</p>"},{"location":"X16%20Reference%20-%2010%20-%20VERA%20FX%20Reference/#introduction","title":"Introduction","text":"<p>This is a reference for the VERA FX features.  It is meant to be a complement to the tutorial, currently found here.</p> <p>The FX Update mainly adds \"helpers\" inside of VERA that can be used by the CPU. There is no \"magic button\" that allows you to do 3D graphics for example. It mainly helps at certain CPU time-consuming tasks, most notably the ones that are present in the (deep) inner-loop of a game/graphics engine. The FX Update does therefore not fundamentally change the architecture or nature of VERA, it extends and improves it.</p> <p>In other words: the CPU is still the orchestrator of all that is done, but it is alleviated from certain operations where it is not (very) good at or does not have direct access to.</p> <p>FX Update extends addressing modes, it does not add or extend renderers.</p>"},{"location":"X16%20Reference%20-%2010%20-%20VERA%20FX%20Reference/#usage","title":"Usage","text":""},{"location":"X16%20Reference%20-%2010%20-%20VERA%20FX%20Reference/#dcsel","title":"DCSEL","text":"<p>VERA is mapped as 32 8-bit registers in the memory space of the Commander X16, starting at address $9F20 and ending at $9F3F. Many of these are (fully) used, but some bits remain unused. The DCSEL bits in register $9F25 (also called CTRL) has been extended to 6-bits to allow for the 4 registers $9F29-$9F2C to have additional meanings.</p> Addr Name Bit\u00a07 Bit\u00a06 Bit\u00a05 Bit\u00a04 Bit\u00a03 Bit\u00a02 Bit\u00a01 Bit\u00a00 $9F25 CTRL Reset DCSEL ADDRSEL <p>The FX features use DCSEL values 2, 3, 4, 5, and 6. This effectively gives FX 20 8-bit registers. Note that 15 of these registers are write-only, 2 of them are read-only and 3 are both readable and writable,</p> <p>Important: unless DCSEL values of 2-6 are used, the behavior of VERA is exactly the same as it was before the FX update. This ensures that the FX update is backwards compatible with traditional non-FX uses of VERA.</p>"},{"location":"X16%20Reference%20-%2010%20-%20VERA%20FX%20Reference/#addr1-mode","title":"Addr1 Mode","text":"<p>When DCSEL=2, the main FX configuration register becomes available (FX_CTRL/$9F29), which is both readable and writable. The 2 lower bits are the addr1 mode bits, which will change the behavior of how and when ADDR1 is updated. This puts the FX helpers in a certain \"role\".</p> Addr Name Bit\u00a07 Bit\u00a06 Bit\u00a05 Bit\u00a04 Bit\u00a03 Bit\u00a02 Bit\u00a01 Bit\u00a00 $9F29 FX_CTRL(DCSEL=2) Transp. Writes Cache Write Enable Cache Fill Enable One-byte Cache Cycling 16-bit Hop 4-bit Mode Addr1 Mode Addr1 Mode Description 0 Traditional VERA behavior 1 Line draw helper 2 Polygon filler helper 3 Affine helper <p>By default, Addr1 Mode is set to 0 (=00b), which is the normal and already-known behavior of <code>ADDR1</code>.</p>"},{"location":"X16%20Reference%20-%2010%20-%20VERA%20FX%20Reference/#line-draw-helper","title":"Line draw helper","text":"<p>When Addr1 Mode is set to 1 (=01b) the line draw helper is enabled.</p>"},{"location":"X16%20Reference%20-%2010%20-%20VERA%20FX%20Reference/#setting-up-the-line-draw-helper","title":"Setting up the line draw helper","text":"<ul> <li>Set <code>ADDR1</code> to the address of the starting pixel</li> <li>Determine the octant (see below) you are going to draw in, which will inform your <code>ADDR0</code> and <code>ADDR1</code> increments.<ul> <li>Set <code>ADDR1</code> increment in the direction you will always increment each step<ul> <li>For 8-bit mode: (+1, -1, -320, or +320)</li> <li>For 4-bit mode: (-0.5, +0.5, -160, or +160)</li> </ul> </li> <li>Set <code>ADDR0</code> increment in the direction you will sometimes increment. Even though this is the increment for <code>ADDR0</code>, we are using it in line draw mode as an incrementer for <code>ADDR1</code>.<ul> <li>For 8-bit mode: (+1, -1, -320, or +320).</li> <li>For 4-bit mode: (-0.5, +0.5, -160, or +160)</li> </ul> </li> <li>For 4-bit mode, the half increments are set via the Nibble Increment bit and optionally the DECR bit in <code>ADDRx_H</code>. For the Nibble Increment bit to have effect, the main Address Increment must be set to 0, and the 4-bit Mode bit must be set in FX_CTRL ($9F29, DCSEL=2).</li> </ul> </li> </ul> Addr Name Bit\u00a07 Bit\u00a06 Bit\u00a05 Bit\u00a04 Bit\u00a03 Bit\u00a02 Bit\u00a01 Bit\u00a00 $9F22 ADDRx_H (x=ADDRSEL) Address Increment DECR Nibble Increment Nibble Address VRAM Address (16) Octant 8-bit <code>ADDR1</code> increment 8-bit <code>ADDR0</code> increment 4-bit <code>ADDR1</code> increment 4-bit <code>ADDR0</code> increment 0 +1 -320 +0.5 -160 1 -320 +1 -160 +0.5 2 -320 -1 -160 -0.5 3 -1 -320 -0.5 -160 4 -1 +320 -0.5 +160 5 +320 -1 +160 -0.5 6 +320 +1 +160 +0.5 7 +1 +320 +0.5 +160 <ul> <li>Set your slope into the two \"X Increment\" registers (DCSEL=3, see below). Note that increment registers are 15-bit signed fixed-point numbers, and for this mode, the range should be 0.0 to 1.0 inclusive, so you'll either want to store the value of 1, or you'll want to set only the fractional part.</li> </ul> Addr Name Bit\u00a07 Bit\u00a06 Bit\u00a05 Bit\u00a04 Bit\u00a03 Bit\u00a02 Bit\u00a01 Bit\u00a00 $9F29 FX_X_INCR_L(DCSEL=3)(Write only) X Increment (-2:-9) (signed) $9F2A FX_X_INCR_H(DCSEL=3)(Write only) X Incr. 32x X Increment (5:1) (signed) X Incr. (0) X Incr. (-1) <p>Note: Of the two incrementers, the line draw helper uses only the X incrementer. However depending on the octant you are drawing in, this incrementer will be used to depict either x or y pixel increments. So the \"X\" should not be taken literally here, it just means the first of the two incrementers.</p> <ul> <li>As a side effect of in line draw mode, by setting <code>FX_X_INCR_H</code> ($9F2A, DCSEL=3), the fractional part (the lower 9 bits) of X Position are automatically set to half a pixel. Furthermore, the lowest bit of the pixel position (which acts as an overflow bit) is set to 0 as well. This effectively sets the starting X-position to 0.5 (the center) of a pixel.</li> </ul> <p>Note: There is no need to set the higher bits of the X position, since the FX X position (accumulator) is only used to track the fractional (subpixel) part of the line draw.</p>"},{"location":"X16%20Reference%20-%2010%20-%20VERA%20FX%20Reference/#polygon-filler-helper","title":"Polygon filler helper","text":"<p>When Addr1 Mode is set to 2 (=10b) the polygon filler helper is enabled.</p>"},{"location":"X16%20Reference%20-%2010%20-%20VERA%20FX%20Reference/#setting-up-the-polygon-filler-helper","title":"Setting up the polygon filler helper","text":"<p>Assuming a 320 pixel-wide screen * Set <code>ADDR0</code> to the address of the y-position of the top point of the triangle and x=0 (so on the left of the screen). Set its increment to +320 (for 8-bit mode) or +160 (for 4-bit mode).     * Note: <code>ADDR0</code> is used as \"base address\" for calculating <code>ADDR1</code> for each horizontal line of the triangle. <code>ADDR0</code> should therefore start at the top of the triangle and increment exactly one line each time.     * There is no need to set <code>ADDR1</code>. This is done by VERA. * Calculate your slopes (dx/dy) for both the left and right point. Unlike the line draw helper, these slopes can be negative and can exceed 1.0. They are not dependent on octant, but cover the whole 180 degrees downwards. Below is an illustration of some (not-to-scale) examples of increments:  * Set <code>ADDR1</code> increment to +1 (for 8-bit mode) or +0.5 (for 4-bit mode)     * <code>ADDR1</code> increment can also be +4 if you use 32-bit cache writes, explained later) * Set your left slope into the two \"X increment\" registers and your right slope into the two \"Y increment\" registers (DCSEL=3, see below).     * Important: They should be set to half the increment (or decrement) per horizontal line! This is because the polygon filler increments in two steps per line. * Note that increment registers are 15-bit signed fixed-point numbers: * 6 bits for the integer pixel increment * 9 bits for the fractional (subpixel) increment * 1 additional bit that indicates the actual value should be multiplied by 32</p> Addr Name Bit\u00a07 Bit\u00a06 Bit\u00a05 Bit\u00a04 Bit\u00a03 Bit\u00a02 Bit\u00a01 Bit\u00a00 $9F29 FX_X_INCR_L(DCSEL=3)(Write only) X Increment (-2:-9) (signed) $9F2A FX_X_INCR_H(DCSEL=3)(Write only) X Incr. 32x X Increment (5:0) (signed) X Incr. (-1) $9F2B FX_Y_INCR_L(DCSEL=3)(Write only) Y/X2 Increment (-2:-9) (signed) $9F2C FX_Y_INCR_H(DCSEL=3)(Write only) Y/X2 Incr. 32x Y/X2 Increment (5:0) (signed) Y/X2 Incr. (-1) <ul> <li>Due to the fact that we are in \"polygon fill\"-mode, by setting the high bits of the \"X increment\" ($9F2A, DCSEL=3), the \"X position\" (the lower 9 bits of the position in DCSEL=4 and DCSEL=5) are automatically set to half a pixel. The same goes for the high bits of the Y/X2 increment ($9F2C, DCSEL=3) and Y/X2 position.</li> <li>Set the \"X position\" and \"Y/X2 position\u201d to the x-pixel-position of the top triangle point.</li> </ul> Addr Name Bit\u00a07 Bit\u00a06 Bit\u00a05 Bit\u00a04 Bit\u00a03 Bit\u00a02 Bit\u00a01 Bit\u00a00 $9F29 FX_X_POS_L(DCSEL=4)(Write only) X Position (7:0) $9F2A FX_X_POS_H(DCSEL=4)(Write only) X Pos. (-9) - X Position (10:8) $9F2B FX_Y_POS_L(DCSEL=4)(Write only) Y/X2 Position (7:0) $9F2C FX_Y_POS_H(DCSEL=4)(Write only) Y/X2 Pos. (-9) - Y/X2 Position (10:8) <p>Steps that are needed for filling a triangle part with lines: * Read from <code>DATA1</code>     * This will not return any useful data but will do two things in the background:         * Increment/decrement the X1 and X2 positions by their corresponding increment values.         * Set <code>ADDR1</code> to <code>ADDR0</code> + X1</p> <ul> <li>Then read the \u201cFill length (low)\u201d-register.  Its output depends on whether you're in 4 or 8-bit mode.</li> </ul> Addr Name Bit\u00a07 Bit\u00a06 Bit\u00a05 Bit\u00a04 Bit\u00a03 Bit\u00a02 Bit\u00a01 Bit\u00a00 $9F2B FX_POLY_FILL_L(DCSEL=5, 4-bit Mode=0)(Read only) Fill Len &gt;= 16 X Position (1:0) Fill Len (3:0) 0 $9F2B FX_POLY_FILL_L(DCSEL=5, 4-bit Mode=1, 2-bit Polygon=0)(Read only) Fill Len &gt;= 8 X Position (1:0) X Pos. (2) Fill Len (2:0) 0 <ul> <li>If fill_len &gt;= 16 (or &gt;= 8 in 4-bit mode) then also read the \u201cFill length (high)\u201d-register:</li> </ul> Addr Name Bit\u00a07 Bit\u00a06 Bit\u00a05 Bit\u00a04 Bit\u00a03 Bit\u00a02 Bit\u00a01 Bit\u00a00 $9F2C FX_POLY_FILL_H(DCSEL=5)(Read only) Fill Len (9:3) 0 <p>Important: when the two highest bits of Fill Len (bits 8 and 9) are both 1, it means there is a negative fill length. The line should not be drawn!</p> <ul> <li>Together they give you 10-bits of fill length (ignore the other bits for now). Since <code>ADDR1</code> is already set properly you can immediately start drawing this number of pixels (given by Fill Len).<ul> <li><code>sta DATA1</code> ; as many times as Fill Len states</li> </ul> </li> <li>Then read from <code>DATA0</code>: this will (also) increment X1 and X2</li> <li>Check if all lines of this triangle part have been drawn, if not go to the first step.</li> </ul> <p>There is also a 2-bit polygon mode, which is better explained in the tutorial</p>"},{"location":"X16%20Reference%20-%2010%20-%20VERA%20FX%20Reference/#affine-helper","title":"Affine helper","text":"<p>When Addr1 Mode is set to 3 (=11b) the affine (transformation) helper is enabled.</p> <p>When reading from ADDR1 in this mode, the affine helper reads tile data from a special tile area defined by two new FX registers: * FX_TILEBASE is pointed to a set of 8x8 tiles in either 4-bit or 8-bit depth. FX can support up to 256 tile definitions, and can overlap the traditional layer tile bases. * FX_MAPBASE points to a square-shaped tile map, one byte per tile. This tile map has no attribute bytes. unlike the traditional layer 0/1 tile maps.</p> Addr Name Bit\u00a07 Bit\u00a06 Bit\u00a05 Bit\u00a04 Bit\u00a03 Bit\u00a02 Bit\u00a01 Bit\u00a00 $9F2A FX_TILEBASE(DCSEL=2)(Write only) FX Tile Base Address (16:11) Affine Clip Enable 2-bit Polygon $9F2B FX_MAPBASE(DCSEL=2)(Write only) FX Map Base Address (16:11) Map Size <ul> <li>Affine Clip Enable changes the behavior when the X/Y positions are outside of the tile map such that it always reads data from tile 0. The default behavior is to wrap the X/Y position to the opposite side of the map.</li> <li>Map Size is a 2 bit value that affects both the width and height of the tile map.</li> </ul> Map Size Dimensions 0 2\u00d72 1 8\u00d78 2 32\u00d732 3 128\u00d7128 <ul> <li>The Transparent Writes toggle in FX_CTRL is especially useful in Affine helper mode.  Setting this toggle causes a write of zero to leave the byte (or the nibble) at the target address intact.  This toggle is not limited to affine helper mode, and it affects writes to both DATA0 and DATA1.</li> </ul> Addr Name Bit\u00a07 Bit\u00a06 Bit\u00a05 Bit\u00a04 Bit\u00a03 Bit\u00a02 Bit\u00a01 Bit\u00a00 $9F29 FX_CTRL(DCSEL=2) Transp. Writes Cache Write Enable Cache Fill Enable One-byte Cache Cycling 16-bit Hop 4-bit Mode Addr1 Mode <p>When using the affine helper, the X and Y position registers (DCSEL=4) are used to set ADDR1 to the source pixel indirectly in the aforementioned tile map, while the X and Y increments determine the step after each read of ADDR1.</p> Addr Name Bit\u00a07 Bit\u00a06 Bit\u00a05 Bit\u00a04 Bit\u00a03 Bit\u00a02 Bit\u00a01 Bit\u00a00 $9F29 FX_X_POS_L(DCSEL=4)(Write only) X Position (7:0) $9F2A FX_X_POS_H(DCSEL=4)(Write only) X Pos. (-9) - X Position (10:8) $9F2B FX_Y_POS_L(DCSEL=4)(Write only) Y/X2 Position (7:0) $9F2C FX_Y_POS_H(DCSEL=4)(Write only) Y/X2 Pos. (-9) - Y/X2 Position (10:8) <p>The affine helper supports the full range of X and Y increment values, including negative values.</p> Addr Name Bit\u00a07 Bit\u00a06 Bit\u00a05 Bit\u00a04 Bit\u00a03 Bit\u00a02 Bit\u00a01 Bit\u00a00 $9F29 FX_X_INCR_L(DCSEL=3)(Write only) X Increment (-2:-9) (signed) $9F2A FX_X_INCR_H(DCSEL=3)(Write only) X Incr. 32x X Increment (5:0) (signed) X Incr. (-1) $9F2B FX_Y_INCR_L(DCSEL=3)(Write only) Y/X2 Increment (-2:-9) (signed) $9F2C FX_Y_INCR_H(DCSEL=3)(Write only) Y/X2 Incr. 32x Y/X2 Increment (5:0) (signed) Y/X2 Incr. (-1)"},{"location":"X16%20Reference%20-%2010%20-%20VERA%20FX%20Reference/#32-bit-cache","title":"32-bit cache","text":"<p>When the CPU reads a byte via DATA0 or DATA1, and \"cache fill enable\" is set, the value read will be copied into an indexed location inside the 32-bit cache.</p> Addr Name Bit\u00a07 Bit\u00a06 Bit\u00a05 Bit\u00a04 Bit\u00a03 Bit\u00a02 Bit\u00a01 Bit\u00a00 $9F29 FX_CTRL(DCSEL=2) Transp. Writes Cache Write Enable Cache Fill Enable One-byte Cache Cycling 16-bit Hop 4-bit Mode Addr1 Mode <p>In 8-bit mode, a byte is cached, but in 4-bit mode, a nibble is cached instead. Afterwards, by default, the index into the cache is incremented, and loops back around to 0 after the last index.  The index can be set explicitly via the FX_MULT register.  8-bit mode uses bits 3:2 and ranges from 0-3.  4-bit mode uses bits 3:1 and ranges from 0-7.</p> Addr Name Bit\u00a07 Bit\u00a06 Bit\u00a05 Bit\u00a04 Bit\u00a03 Bit\u00a02 Bit\u00a01 Bit\u00a00 $9F2C FX_MULT(DCSEL=2)(Write only) Reset Accum. Accumulate Subtract Enable Multiplier Enable Cache Byte Index Cache Nibble Index Two-byte Cache Incr. Mode <p>Alternatively, the cache index can cycle between two adjacent bytes: 0, 1, and back to 0; or 2, 3, and back to 2. This option only has effect in 8-bit mode.</p> Addr Name Bit\u00a07 Bit\u00a06 Bit\u00a05 Bit\u00a04 Bit\u00a03 Bit\u00a02 Bit\u00a01 Bit\u00a00 $9F2C FX_MULT(DCSEL=2)(Write only) Reset Accum. Accumulate Subtract Enable Multiplier Enable Cache Byte Index Cache Nibble Index Two-byte Cache Incr. Mode"},{"location":"X16%20Reference%20-%2010%20-%20VERA%20FX%20Reference/#setting-the-cache-data-directly","title":"Setting the cache data directly","text":"<p>Instead of filling the cache by reading from DATA0 or DATA1, the cache data can also be set directly by writing to the FX_CACHE* registers. Setting the cache directly does not affect the cache index.</p> Addr Name Bit\u00a07 Bit\u00a06 Bit\u00a05 Bit\u00a04 Bit\u00a03 Bit\u00a02 Bit\u00a01 Bit\u00a00 $9F29 FX_CACHE_L(DCSEL=6)(Write only) Cache (7:0) | Multiplicand (7:0) (signed) $9F2A FX_CACHE_M(DCSEL=6)(Write only) Cache (15:8) | Multiplicand (15:8) (signed) $9F2B FX_CACHE_H(DCSEL=6)(Write only) Cache (23:16) | Multiplier (7:0) (signed) $9F2C FX_CACHE_U(DCSEL=6)(Write only) Cache (31:24) | Multiplier (15:8) (signed)"},{"location":"X16%20Reference%20-%2010%20-%20VERA%20FX%20Reference/#writing-the-cache-to-vram","title":"Writing the cache to VRAM","text":"<p>If \"Cache write enabled\" is set, the cache contents are written to VRAM when writing to DATA0 or DATA1.  The primary use is to write all or part of the 32-bit cache to the 4-byte-aligned region of memory at the current address.</p> <p>Control over which parts are written are chosen by the value written to DATA0 or DATA1. The value written is treated as a nibble mask where a 0-bit writes the data and a 1-bit masks the data from being written.In other words, writing a 0 will flush the entire 32-bit cache. Writing <code>#%00001111</code> will write the second and third byte in the cache to VRAM in the second and third memory locations in the 4-byte-aligned region.</p> Addr Name Bit\u00a07 Bit\u00a06 Bit\u00a05 Bit\u00a04 Bit\u00a03 Bit\u00a02 Bit\u00a01 Bit\u00a00 $9F29 FX_CTRL(DCSEL=2) Transp. Writes Cache Write Enable Cache Fill Enable One-byte Cache Cycling 16-bit Hop 4-bit Mode Addr1 Mode"},{"location":"X16%20Reference%20-%2010%20-%20VERA%20FX%20Reference/#transparency-writes","title":"Transparency writes","text":"<p>Transparent writes, when enabled, also applies to cache writes. If enabled, zero bytes (or zero nibbles in 4-bit mode) in the cache, which are treated as transparency pixels, are not written.</p> Addr Name Bit\u00a07 Bit\u00a06 Bit\u00a05 Bit\u00a04 Bit\u00a03 Bit\u00a02 Bit\u00a01 Bit\u00a00 $9F29 FX_CTRL(DCSEL=2) Transp. Writes Cache Write Enable Cache Fill Enable One-byte Cache Cycling 16-bit Hop 4-bit Mode Addr1 Mode <p>When \"one-byte cache cycling\" is turned on and DATA0 or DATA1 is written to, the byte at the current cache index is written to VRAM. When \"Cache write enable\" is set as well, the byte is duplicated 4 times when writing to VRAM.</p> <p>Usually the incrementing of the cache index is only triggered by reading from DATA0 or DATA1 when cache filling is enabled. However it can also be triggered by reading from DATA0 in polygon mode when cache filling is not enabled and \"one-byte cache cycling\" is enabled.</p> Addr Name Bit\u00a07 Bit\u00a06 Bit\u00a05 Bit\u00a04 Bit\u00a03 Bit\u00a02 Bit\u00a01 Bit\u00a00 $9F29 FX_CTRL(DCSEL=2) Transp. Writes Cache Write Enable Cache Fill Enable One-byte Cache Cycling 16-bit Hop 4-bit Mode Addr1 Mode"},{"location":"X16%20Reference%20-%2010%20-%20VERA%20FX%20Reference/#multiplier-and-accumulator","title":"Multiplier and accumulator","text":"<p>The 32-bit cache also doubles as an input to the hardware multiplier when Multiplier Enable is set.</p> Addr Name Bit\u00a07 Bit\u00a06 Bit\u00a05 Bit\u00a04 Bit\u00a03 Bit\u00a02 Bit\u00a01 Bit\u00a00 $9F2C FX_MULT(DCSEL=2)(Write only) Reset Accum. Accumulate Subtract Enable Multiplier Enable Cache Byte Index Cache Nibble Index Two-byte Cache Incr. Mode <p>To do a single multiplication, put the two 16-bit inputs into the two halves of the 32-bit cache.</p> <pre><code>    lda #(2 &lt;&lt; 1)\n    sta VERA_CTRL        ; $9F25\n    stz VERA_FX_CTRL     ; $9F29 (mainly to reset Addr1 Mode to 0)\n    lda #%00010000\n    sta VERA_FX_MULT     ; $9F2C\n    lda #(6 &lt;&lt; 1)\n    sta VERA_CTRL        ; $9F25\n    lda #&lt;69\n    sta VERA_FX_CACHE_L  ; $9F29\n    lda #&gt;69\n    sta VERA_FX_CACHE_M  ; $9F2A\n    lda #&lt;420\n    sta VERA_FX_CACHE_H  ; $9F2B\n    lda #&gt;420\n    sta VERA_FX_CACHE_U  ; $9F2C\n</code></pre> <p>The accumulator can be used to accumulate the sum of several multiplications.  Before doing this single multiplication, ensure this is reset this to zero, otherwise the output will be added to the value of the accumulator before being written.  There are two methods to do this. The first is to write a 1 into bit 7 of FX_MULT ($9F2C, DCSEL=2).  The other, more conveniently, is to read FX_ACCUM_RESET (the same register location as VERA_FX_CACHE_L).</p> <pre><code>    lda FX_ACCUM_RESET   ; $9F29 (DCSEL=6)\n</code></pre> <p>To perform the multiplication, it must be written to VRAM first.  This is done via the cache write mechanism. Usually the cache itself is written to VRAM if \"Cache Write Enable\" is set.  However, if the \"Multiplier Enable\" bit is also enabled, the multiplier result is written to VRAM instead.</p> <pre><code>    ; Set the ADDR0 pointer to $00000 and write our multiplication result there\n    lda #(2 &lt;&lt; 1)\n    sta VERA_CTRL        ; $9F25\n    lda #%01000000       ; Cache Write Enable\n    sta VERA_FX_CTRL     ; $9F29\n    stz VERA_ADDRx_L     ; $9F20 (ADDR0)\n    stz VERA_ADDRx_M     ; $9F21\n    stz VERA_ADDRx_H     ; $9F22 ; no increment\n    stz VERA_DATA0       ; $9F23 ; multiply and write out result\n    lda #%00010000       ; Increment 1\n    sta VERA_ADDRx_H     ; $9F22 ; so we can read out the result\n    lda VERA_DATA0\n    sta $0400\n    lda VERA_DATA0\n    sta $0401\n    lda VERA_DATA0\n    sta $0402\n    lda VERA_DATA0\n    sta $0403\n</code></pre> <p>Note: the VERA works by pre-fetching the contents from VRAM whenever the address pointer is changed or incremented. This happens even when the address increment is 0. Due to this behavior, it is possible to have stale data latched in one of the two data ports if the underlying VRAM is changed via the other data port. This example avoids this scenario by only using ADDR0/DATA0. This potential gotcha was not introduced by the FX update, but rather has always been how VERA behaves.</p>"},{"location":"X16%20Reference%20-%2010%20-%20VERA%20FX%20Reference/#accumulation","title":"Accumulation","text":"<p>One can also trigger the multiplication and add it to (or subtract it from) the multiplication accumulator by calling \"accumulate\" in one of two different ways. We could write a 1 into bit 6 of FX_MULT ($9F2C, DCSEL=2), but more conveniently, we can read FX_ACCUM (the same register location as VERA_FX_CACHE_M)</p> <pre><code>    lda FX_ACCUM         ; $9F2A (DCSEL=6)\n</code></pre> <p>Once the accumulation is triggered, the result of the operation is stored back into the accumulator.</p> <p>The default accumulation operation is (multiply then) add. This can be switched to subtraction by setting the Subtract Enable bit in FX_MULT</p> Addr Name Bit\u00a07 Bit\u00a06 Bit\u00a05 Bit\u00a04 Bit\u00a03 Bit\u00a02 Bit\u00a01 Bit\u00a00 $9F2C FX_MULT(DCSEL=2)(Write only) Reset Accum. Accumulate Subtract Enable Multiplier Enable Cache Byte Index Cache Nibble Index Two-byte Cache Incr. Mode <p>If the multiplication accumulator has a nonzero value, any multiplications carried out via a VRAM Cache write will be offset by the value of the accumulator (either added to or subtracted from the accumulator), but they will not change the value of the accumulator.</p>"},{"location":"X16%20Reference%20-%2010%20-%20VERA%20FX%20Reference/#16-bit-hop","title":"16-bit hop","text":"<p>There is a special address increment mode that can be used to read pairs of bytes via ADDR1.</p> Addr Name Bit\u00a07 Bit\u00a06 Bit\u00a05 Bit\u00a04 Bit\u00a03 Bit\u00a02 Bit\u00a01 Bit\u00a00 $9F29 FX_CTRL(DCSEL=2) Transp. Writes Cache Write Enable Cache Fill Enable One-byte Cache Cycling 16-bit Hop 4-bit Mode Addr1 Mode <p>In this mode, setting ADDR1's increment to +4 will result in alternating increments of +1 and +3. Setting it to +320 will result in alternating increments of +1 and +319. All other increment values, including negative increments, lack this special hop property.</p> <p>After this bit is set, writing to ADDRx_L resets the hop alignment such that the first increment is +1.</p> <p>This mode is useful for reading out a series of 16-bit values after a series of multiplications.</p> <p>For a more detailed explanation of chained math operations, see the tutorial.</p>"},{"location":"X16%20Reference%20-%2011%20-%20Sound%20Programming/","title":"11: Sound Programming","text":""},{"location":"X16%20Reference%20-%2011%20-%20Sound%20Programming/#audio-bank-api","title":"Audio bank API","text":"<p>The Commander X16 provides many convenience routines for controlling the YM2151 and VERA PSG. These are called similarly to how KERNAL API calls are done in machine language.</p> <p>In order to gain access to these routines, you must either use <code>jsrfar</code> from the KERNAL API:</p> <pre><code>AUDIO_BANK = $0A\n\njsr jsrfar  ; $FF6E\n.word ym_init ; $C063\n.byte AUDIO_BANK\n</code></pre> <p>or switch to ROM bank <code>$0A</code> directly:</p> <pre><code>lda #$0A ; Audio bank number\nsta $01  ; ROM bank register\n</code></pre> <p>Conveniently, the KERNAL API still exists in this bank, and calling a KERNAL API routine will automatically switch your ROM bank back to the KERNAL bank to perform the routine and then switch back right before returning, so there's usually no need for your audio-centric program to switch away from the audio bank to perform the occasional KERNAL API call.</p>"},{"location":"X16%20Reference%20-%2011%20-%20Sound%20Programming/#audio-api-routines","title":"Audio API routines","text":"<p>For the audio chips, some of the documentation uses the words channel and voice interchangeably. This table of API routines uses channel for the 8 on the YM2151, and voice for the 16 on the PSG.</p> Label Address Class Description Inputs Returns Preserves <code>audio_init</code> <code>$C09F</code> - Wrapper routine that calls both <code>psg_init</code> and <code>ym_init</code> followed by <code>ym_loaddefpatches</code>. This is the routine called by the KERNAL at reset. none none none <code>bas_fmchordstring</code> <code>$C08D</code> BASIC Starts playing all of notes specified in a string. This uses the same parser as <code>bas_fmplaystring</code> but instead of playing the notes in sequence, it starts playback of each note in the string, on many channels as is necessary, then returns to the caller without delay. The first FM channel that is used is the one specified by calling <code>bas_playstringvoice</code> prior to calling this routine. The string pointer must point to low RAM (<code>$0000</code>-<code>$9EFF</code>). .A = string length  .X .Y = pointer to string none none <code>bas_fmfreq</code> <code>$C000</code> BASIC Plays a note specified in Hz on an FM channel .A = channel  .X .Y = 16-bit frequency in Hz  c clear = normal  c set = no retrigger c clear = success  c set = error none <code>bas_fmnote</code> <code>$C003</code> BASIC Plays a note specified in BASIC format on an FM channel .A = channel  .X = note (BASIC format)  .Y = fractional semitone  c clear = normal  c set = no retrigger c clear = success  c set = error none <code>bas_fmplaystring</code> <code>$C006</code> BASIC Plays a note script using the FM channel which was specified on a previous call to <code>bas_playstringvoice</code>. This string pointer must point to low RAM (<code>$0000</code>-<code>$9EFF</code>). This routine depends on interrupts being enabled. In particular, it uses <code>WAI</code> as a delay for timing, so it expects IRQ to be asserted and acknowledged once per video frame, which is the case by default on the system. Stops playback and returns control if the STOP key is pressed. .A = string length  .X .Y = pointer to string none none <code>bas_fmvib</code> <code>$C009</code> BASIC Sets the LFO speed and both amplitude and frequency depth based on inputs. Also sets the LFO waveform to triangle. .A = speed  .X = PMD/AMD depth c clear = success  c set = error none <code>bas_playstringvoice</code> <code>$C00C</code> BASIC Preparatory routine for <code>bas_fmplaystring</code> and <code>bas_psgplaystring</code> to set the voice/channel number for playback .A = PSG/YM voice/channel none .A .X <code>bas_psgchordstring</code> <code>$C090</code> BASIC Starts playing all of notes specified in a string. This uses the same parser as <code>bas_psgplaystring</code> but instead of playing the notes in sequence, it starts playback of each note in the string, on many voices as is necessary, then returns to the caller without delay. The first PSG voice that is used is the one specified by calling <code>bas_playstringvoice</code> prior to calling this routine. The string pointer must point to low RAM (<code>$0000</code>-<code>$9EFF</code>). .A = string length  .X .Y = pointer to string none none <code>bas_psgfreq</code> <code>$C00F</code> BASIC Plays a note specified in Hz on a PSG voice .A = voice  .X .Y = 16-bit frequency c clear = success  c set = error none <code>bas_psgnote</code> <code>$C012</code> BASIC Plays a note specified in BASIC format on a PSG voice .A = voice  .X = note (BASIC format)  .Y = fractional semitone c clear = success  c set = error none <code>bas_psgwav</code> <code>$C015</code> BASIC Sets a waveform and duty cycle for a PSG voice .A = voice  .X 0-63 = Pulse, 1/128 - 64/128 duty cycle  .X 64-127 = Sawtooth  .X 128-191 = Triangle  .X 192-255 = Noise c clear = success  c set = error none <code>bas_psgplaystring</code> <code>$C018</code> BASIC Plays a note script using the PSG voice which was specified on a previous call to <code>bas_playstringvoice</code>. This string pointer must point to low RAM (<code>$0000</code>-<code>$9EFF</code>). This routine depends on interrupts being enabled. In particular, it uses <code>WAI</code> as a delay for timing, so it expects IRQ to be asserted and acknowledged once per video frame, which is the case by default on the system. Stops playback and returns control if the STOP key is pressed. .A = string length  .X .Y = pointer to string none none <code>notecon_bas2fm</code> <code>$C01B</code> Conversion Convert a note in BASIC format to a YM2151 KC code .X = note (BASIC format) .X = note (YM2151 KC)  c clear = success  c set = error .Y <code>notecon_bas2midi</code> <code>$C01E</code> Conversion Convert a note in BASIC format to a MIDI note number .X = note (BASIC format) .X = MIDI note  c clear = success  c set = error .Y <code>notecon_bas2psg</code> <code>$C021</code> Conversion Convert a note in BASIC format to a PSG frequency .X = note (BASIC format)  .Y = fractional semitone .X .Y = PSG frequency  c clear = success  c set = error none <code>notecon_fm2bas</code> <code>$C024</code> Conversion Convert a note in YM2151 KC format to a note in BASIC format .X = YM2151 KC .X = note (BASIC format)  c clear = success  c set = error .Y <code>notecon_fm2midi</code> <code>$C027</code> Conversion Convert a note in YM2151 KC format to a MIDI note number .X = YM2151 KC .X = MIDI note  c clear = success  c set = error .Y <code>notecon_fm2psg</code> <code>$C02A</code> Conversion Convert a note in YM2151 KC format to a PSG frequency .X = YM2151 KC  .Y = fractional semitone .X .Y = PSG frequency  c clear = success  c set = error none <code>notecon_freq2bas</code> <code>$C02D</code> Conversion Convert a frequency in Hz to a note in BASIC format and a fractional semitone .X .Y = 16-bit frequency in Hz .X = note (BASIC format)  .Y = fractional semitone  c clear = success  c set = error none <code>notecon_freq2fm</code> <code>$C030</code> Conversion Convert a frequency in Hz to YM2151 KC and a fractional semitone (YM2151 KF) .X .Y = 16-bit frequency in Hz .X = YM2151 KC  .Y = fractional semitone (YM2151 KF)  c clear = success  c set = error none <code>notecon_freq2midi</code> <code>$C033</code> Conversion Convert a frequency in Hz to a MIDI note and a fractional semitone .X .Y = 16-bit frequency in Hz .X = MIDI note  .Y = fractional semitone  c clear = success  c set = error none <code>notecon_freq2psg</code> <code>$C036</code> Conversion Convert a frequency in Hz to a VERA PSG frequency .X .Y = 16-bit frequency in Hz .X .Y = 16-bit frequency in VERA PSG format  c clear = success  c set = error none <code>notecon_midi2bas</code> <code>$C039</code> Conversion Convert a MIDI note to a note in BASIC format .X = MIDI note .X = note (BASIC format)  c clear = success  c set = error .Y <code>notecon_midi2fm</code> <code>$C03C</code> Conversion Convert a MIDI note to a YM2151 KC. Fractional semitone is unneeded as it is identical to KF already. .X = MIDI note. .X = YM2151 KC  c clear = success  c set = error .Y <code>notecon_midi2psg</code> <code>$C03F</code> Conversion Convert a MIDI note and fractional semitone to a PSG frequency .X = MIDI note  .Y = fractional semitone .X .Y = 16-bit frequency in VERA PSG format  c clear = success  c set = error none <code>notecon_psg2bas</code> <code>$C042</code> Conversion Convert a frequency in VERA PSG format to a note in BASIC format and a fractional semitone .X .Y = 16-bit frequency in VERA PSG format .X = note (BASIC format)  .Y = fractional semitone  c clear = success  c set = error none <code>notecon_psg2fm</code> <code>$C045</code> Conversion Convert a frequency in VERA PSG format to YM2151 KC and a fractional semitone (YM2151 KF) .X .Y = 16-bit frequency in VERA PSG format .X = YM2151 KC  .Y = fractional semitone (YM2151 KF)  c clear = success  c set = error none <code>notecon_psg2midi</code> <code>$C048</code> Conversion Convert a frequency in VERA PSG format to a MIDI note and a fractional semitone .X .Y = 16-bit frequency in VERA PSG format .X = MIDI note  .Y = fractional semitone  c clear = success  c set = error none <code>psg_getatten</code> <code>$C093</code> VERA PSG Retrieve the attenuation value for a voice previously set by <code>psg_setatten</code> .A = voice .X = attenuation value .A <code>psg_getpan</code> <code>$C096</code> VERA PSG Retrieve the simple panning value that is currently set for a voice. .A = voice .X = pan value .A <code>psg_init</code> <code>$C04B</code> VERA PSG Initialize the state of the PSG. Silence all voices. Reset the attenuation levels to 0. Set \"playstring\" defaults including <code>O4</code>, <code>T120</code>, <code>S1</code>, and <code>L4</code>. Set all PSG voices to the pulse waveform at 50% duty with panning set to both L+R none none none <code>psg_playfreq</code> <code>$C04E</code> VERA PSG Turn on a PSG voice at full volume (factoring in attenuation) and set its frequency .A = voice  .X .Y = 16 bit frequency in VERA PSG format none none <code>psg_read</code> <code>$C051</code> VERA PSG Read a value from one of the VERA PSG registers. If the selected register is a volume register, return either the cooked value (attenuation applied) or the raw value (as received by <code>psg_write</code> or <code>psg_setvol</code>, or as set by <code>psg_playfreq</code>) depending on the state of the carry flag .X = PSG register address (offset from <code>$1F9C0</code>)  c clear = if volume, return raw  c set = if volume, return cooked .A = register value .X <code>psg_setatten</code> <code>$C054</code> VERA PSG Set the attenuation value for a PSG voice. The valid range is from <code>$00</code> (full volume) to <code>$3F</code> (fully muted). API routines which affect volume will deduct the attenuation value from the intended volume before setting it. Calls to this routine while a note is playing will change the output volume of the voice immediately. This control can be considered a \"master volume\" for the voice. .A = voice  .X = attenuation none none <code>psg_setfreq</code> <code>$C057</code> VERA PSG Set the frequency of a PSG voice without changing any other attributes of the voice .A = voice  .X .Y = 16 bit frequency in VERA PSG format none none <code>psg_setpan</code> <code>$C05A</code> VERA PSG Set the simple panning for the voice. A value of <code>0</code> will silence the voice entirely until another pan value is set. .A = voice  .X 0 = none  .X 1 = left  .X 2 = right  .X 3 = both none none <code>psg_setvol</code> <code>$C05D</code> VERA PSG Set the volume for the voice. The volume that's written to the VERA has attenuation applied. Valid volumes range from <code>$00</code> to <code>$3F</code> inclusive .A = voice  .X = volume none none <code>psg_write</code> <code>$C060</code> VERA PSG Write a value to one of the VERA PSG registers. If the selected register is a volume register, attenuation will be applied before the value is written to the VERA .A = value .X = PSG register address (offset from <code>$1F9C0</code>) none .A .X <code>psg_write_fast</code> <code>$C0A2</code> VERA PSG Same effect as <code>psg_write</code> but does not preserve the state of the VERA CTRL and ADDR registers. It also assumes VERA_CTRL bit 0 is clear, VERA_ADDR0_H = $01 (auto increment 0 recommended), and VERA_ADDR0_M = $F9.  This routine is meant for use by sound engines that typically write out multiple PSG registers in a loop. .A = value .X = PSG register address (offset from <code>$1F9C0</code>) none .A .X <code>ym_getatten</code> <code>$C099</code> YM2151 Retrieve the attenuation value for a channel previously set by <code>ym_setatten</code> .A = channel .X = attenuation value .A <code>ym_getpan</code> <code>$C09C</code> YM2151 Retrieve the simple panning value that is currently set for a channel. .A = channel .X = pan value .A <code>ym_init</code> <code>$C063</code> YM2151 Initialize the state of the YM chip. Silence all channels by setting the release part of the ADSR envelope to max and then setting all channels to released. Reset all attenuation levels to 0. Set \"playstring\" defaults including <code>O4</code>, <code>T120</code>, <code>S1</code>, and <code>L4</code>. Set panning for all channels set to both L+R. Reset LFO state. Set all of the other registers to <code>$00</code> none c clear = success  c set = error none <code>ym_loaddefpatches</code> <code>$C066</code> YM2151 Load a default set of patches into the 8 channels. <code>C0: Piano (0)</code><code>C1: E. Piano (5)</code><code>C2: Vibraphone (11)</code><code>C3: Fretless (35)</code> <code>C4: Violin (40)</code><code>C5: Trumpet (56)</code><code>C6: Blown Bottle (76)</code><code>C7: Fantasia (88)</code> none c clear = success  c set = error none <code>ym_loadpatch</code> <code>$C069</code> YM2151 Load into a channel a patch preset by number (0-161) from the audio bank, or from an arbitrary memory location. High RAM addresses (<code>$A000</code>-<code>$BFFF</code>) are accepted in this mode. .A = channelc clear = .X .Y = patch addressc set = .X = patch number c clear = success  c set = error none <code>ym_loadpatchlfn</code> <code>$C06C</code> YM2151 Load patch into a channel by way of an open logical file number. This routine will read 26 bytes from the open file, or possibly fewer bytes if there's an error condition. The routine will leave the file open on return. On return if c is set, check .A for the error code. .A = channel.X = Logical File Number c clear = success  c set .A=0 = YM error  c set .A&amp;3=2 = read timeout  c set .A&amp;3=3 = file not open c set .A&amp;64=64 = EOF c set .A&amp;128=128 = device not present none <code>ym_playdrum</code> <code>$C06F</code> YM2151 Load a patch associated with a MIDI drum note number and trigger it on a channel. Valid drum note numbers mirror the General MIDI percussion standard and range from 25 (Snare Roll) through 87 (Open Surdo). Note 0 will release the note. After the drum is played, the channel will still contain the patch for the drum sound and thus may not sound musical if you attempt to play notes on it before loading another instrument patch. .A = channel.X = drum note c clear = success  c set = error none <code>ym_playnote</code> <code>$C072</code> YM2151 Set a KC/KF on a channel and optionally trigger it. .A = channel.X = KC.Y = KF (fractional semitone)c clear = triggerc set = no trigger c clear = success  c set = error none <code>ym_setatten</code> <code>$C075</code> YM2151 Set the attenuation value for a channel. The valid range is from <code>$00</code> (full volume) to <code>$7F</code> (fully muted). API routines which affect TL or CON will add the attenuation value to the intended TL on operators that are carriers before setting it. Calls to this routine will change the TL of the channel's carriers immediately. This control can be considered a \"master volume\" for the channel. .A = channel  .X = attenuation c clear = success  c set = error .A .X <code>ym_setdrum</code> <code>$C078</code> YM2151 Load a patch associated with a MIDI drum note number and set the KC/KF for it on a channel. Called by <code>ym_playdrum</code>. .A = channel.X = drum note c clear = success  c set = error none <code>ym_setnote</code> <code>$C07B</code> YM2151 Set a KC/KF on a channel. Called by <code>ym_playnote</code>. .A = channel.X = KC.Y = KF (fractional semitone) c clear = success  c set = error none <code>ym_setpan</code> <code>$C07E</code> YM2151 Set the simple panning for the channel. A value of <code>0</code> will silence the channel entirely until another pan value is set. .A = channel  .X 0 = none  .X 1 = left  .X 2 = right  .X 3 = both c clear = success  c set = error none <code>ym_read</code> <code>$C081</code> YM2151 Read a value from the in-RAM shadow of one of the YM2151 registers. The YM2151's internal registers cannot be read from, but this API keeps state of what was written, so this routine will be able to retrieve chip values for you. If the selected register is a TL register, return either the cooked value (attenuation applied) or the raw value (as received by <code>ym_write</code>) depending on the state of the carry flag .X = YM2151 register address  c clear = if TL, return raw  c set = if TL, return cooked .A = register valuec clear = success  c set = error .X <code>ym_release</code> <code>$C084</code> YM2151 Release a note on a channel. If a note is not playing, this routine has no tangible effect .A = channel c clear = success  c set = error none <code>ym_trigger</code> <code>$C087</code> YM2151 Trigger the currently configured note on a channel, optionally releasing the channel first depending on the state of the carry flag. .A = channel c clear = release first c set = no release c clear = success  c set = error none <code>ym_write</code> <code>$C08A</code> YM2151 Write a value to one of the YM2151 registers and to the in-RAM shadow copy. If the selected register is a TL register, attenuation will be applied before the value is written. Writes which affect which operators are carriers will have TL values for that channel appropriately recalculated and rewritten .A = value .X = YM register address c clear = success  c set = error .A .X"},{"location":"X16%20Reference%20-%2011%20-%20Sound%20Programming/#a-note-on-semitones-get-it","title":"A note on semitones (get it?)","text":"<p>It may be advantageous to consider storing note data internally as the MIDI representation with a fractional component if you want things like pitch slides to behave the same way between the PSG and YM2151.</p> <p>Essentially, it can be thought of as an 8.8 fixed point 16-bit number.</p> <p>The YM2151 handles semitones differently than the PSG and requires converting the MIDI note to the appropriate KC value using <code>notecon_midi2fm</code>. KF is the fractional semitone (albeit with only the top 6-bits used) and requires no conversion.</p> <p>The PSG, by contrast, operates with linear pitch which is why <code>notecon_midi2psg</code> also takes the fractional component (y) as input.</p> <p>Thus, if you manage all your pitch slides using MIDI notes along with a fractional component, you can then convert this directly over to PSG or YM2151 as required and end up with the same pitch (or close enough to it).</p>"},{"location":"X16%20Reference%20-%2011%20-%20Sound%20Programming/#direct-communication-with-the-ym2151-and-vera-psg-vs-api","title":"Direct communication with the YM2151 and VERA PSG vs API","text":"<p>Use of the API routines above is not required to access the capabilities of the sound chips. However, mixing raw writes to a chip and API access for the same chip is not recommended, particularly where PSG volumes and YM2151 TL and RLFBCON registers are concerned. The API processes volumes, calculating attenuation and adjusting the output volume accordingly, and the API will be oblivious to direct manipulation of the sound chips.</p> <p>The sections below describe how to do raw access to the sound chips outside of the API.</p>"},{"location":"X16%20Reference%20-%2011%20-%20Sound%20Programming/#vera-psg-and-pcm-programming","title":"VERA PSG and PCM Programming","text":"<ul> <li>For VERA PSG and PCM, refer to Chapter 9.</li> </ul>"},{"location":"X16%20Reference%20-%2011%20-%20Sound%20Programming/#ym2151-opm-fm-synthesis","title":"YM2151 (OPM) FM Synthesis","text":"<p>The Yamaha YM2151 (OPM) sound chip is an FM synthesizer ASIC in the Commander X16. It is connected to the system bus at I/O address <code>0x9F40</code> (address register) and at <code>0x9F41</code> (data register). It has 8 independent voices with 4 FM operators each. Each voice is capable of left/right/both audio channel output. The four operators of each channel may be connected in one of 8 pre-defined \"connection algorithms\" in order to produce a wide variety of timbres.</p>"},{"location":"X16%20Reference%20-%2011%20-%20Sound%20Programming/#ym2151-communication","title":"YM2151 Communication","text":"<p>There are 3 basic operations to communicate with the YM chip: Reading its status, address select, and data write. These are performed by reading from or writing to one of the two I/O addresses as follows:</p> Address Name Read Action Write Action 0x9F40 <code>YM_address</code> Undefined (returns ?) Selects the internal register address where data is written. 0x9F41 <code>YM_data</code> Returns the <code>YM_status</code> byte Writes the value into the currently-selected internal address. <p>The values stored in the YM's internal registers are write-only. If you need to know the values in the registers, you must store a copy of the values somewhere in memory as you write updates to the YM.</p>"},{"location":"X16%20Reference%20-%2011%20-%20Sound%20Programming/#ym-write-procedure","title":"YM Write Procedure","text":"<ol> <li>Ensure YM is not busy (see Write Timing below).</li> <li>Select the desired internal register address by writing it into <code>YM_address</code>.</li> <li>Write the new value for this register into <code>YM_data</code>.</li> </ol> <p>Note: You may write into the same register multiple times without repeating a write to <code>YM_address</code>. The same register will be updated with each data write.</p>"},{"location":"X16%20Reference%20-%2011%20-%20Sound%20Programming/#write-timing","title":"Write Timing","text":"<p>The YM2151 is sensitive to the speed at which you write data into it. If you make writes when it is not ready to receive them, they will be dropped and the sound output will be corrupted.</p> <p>You must include a delay between writes to the address select register ($9F40) and the subsequent data write. 10 CPU cycles is the recommended minimum delay.</p> <p>The YM becomes <code>BUSY</code> for approximately 150 CPU cycles' (at 8Mhz) whenever it receives a data write. Any writes into YM_data during this <code>BUSY</code> period will be ignored!</p> <p>In order to avoid this, you can use the <code>BUSY</code> flag which is bit 7 of the <code>YM status</code> byte. Read the status byte from <code>YM_data</code> (0x9F41). If the top bit (7) is set, the YM may not be written into at this time. Note that it is not required that you read <code>YM_status</code>, only that writes occur no less than ~150 CPU cycles apart. For instance, BASIC executes slowly enough that you are in no danger of writing into the YM too quickly, so BASIC programs may skip checking <code>YM_status</code>.</p> <p>Lastly, the <code>BUSY</code> flag sometimes takes a (very) short period before it goes high. This has only been observed when IMMEDIATELY polling the flag after a write into <code>YM_data.</code> As long as your code does not do so, this quirk should not be an issue.</p>"},{"location":"X16%20Reference%20-%2011%20-%20Sound%20Programming/#example-code","title":"Example Code","text":"<p>Assembly Language:</p> <pre><code>check_busy:\n    BIT YM_data      ; check busy flag\n    BMI check_busy   ; wait until busy flag is clear\n    LDA #$08         ; Select YM register $08 (Key-Off/On)\n    STA YM_addr      ;\n    NOP              ;&lt;-+\n    NOP              ;  |\n    NOP              ;  +--slight pause before writing data\n    NOP              ;  |\n    NOP              ;&lt;-+\n    LDA #$04         ; Write $04 (Release note on channel 4).\n    STA YM_data\n    RTS\n</code></pre> <p>BASIC:</p> <pre><code>10 YA=$9F40      : REM YM_ADDRESS\n20 YD=$9F41      : REM YM_DATA\n30 POKE YA,$29   : REM CHANNEL 1 NOTE SELECT\n40 POKE YD,$4A   : REM SET NOTE = CONCERT A\n50 POKE YA,$08   : REM SELECT THE KEY ON/OFF REGISTER\n60 POKE YD,$00+1 : REM RELEASE ANY NOTE ALREADY PLAYING ON CHANNEL 1\n70 POKE YD,$78+1 : REM KEY-ON VOICE 1 TO PLAY THE NOTE\n80 FOR I=1 TO 100 : NEXT I : REM DELAY WHILE NOTE PLAYS\n90 POKE YD,$00+1 : REM RELEASE THE NOTE\n</code></pre>"},{"location":"X16%20Reference%20-%2011%20-%20Sound%20Programming/#ym2151-internal-addressing","title":"YM2151 Internal Addressing","text":"<p>The YM register address space can be thought of as being divided into 3 ranges:</p> Range Type Description 00 .. 1F Global Values Affect individual global parameters such as LFO frequency, noise enable, etc. 20 .. 3F Channel CFG Parameters in groups of 8, one per channel. These affect the whole channel. 40 .. FF Operator CFG Parameters in groups of 32 - these map to individual operators of each voice."},{"location":"X16%20Reference%20-%2011%20-%20Sound%20Programming/#ym2151-register-map","title":"YM2151 Register Map","text":""},{"location":"X16%20Reference%20-%2011%20-%20Sound%20Programming/#global-settings","title":"Global Settings","text":"Addr Register Bit 7 Bit 6 Bit 5 Bit 4 Bit 3 Bit 2 Bit 1 Bit 0 Description $01 Test Register ! ! ! ! ! ! LR !        Bit 1 is the LFO reset bit. Setting it disables the LFO and holds the oscillator at 0. Clearing it enables the LFO.       All other bits control various test functions and should not be written into.      $08 Key Control . C2 M2 C1 M1 CHA        Starts and Releases notes on the 8 channels.       Setting/Clearing bits for M1,C1,M2,C2 controls the key state       for those operators on channel CHA.       NOTE: The operator order is different than the order they       appear in the Operator configuration registers!      $0F Noise Control NE . . NFRQ        NE = Noise Enable       NFRQ = Noise Frequency       When eabled, C2 of channel 7 will use a noise waveform instead       of a sine waveform.      $10 Ta High CLKA1 Top 8 bits of Timer A period setting $11 Ta Low . . . . . . CLKA2 Bottom 2 bits of Timer A period setting $12 Timer B CLKB Timer B period setting $14 IRQ Control CSM . Clock ACK IRQ EN Clock Start        CSM: When a timer expires, trigger note key-on for all channels.       For the other 3 fields, lower bit = Timer A, upper bit = Timer B.       Clock ACK: clears the timer's bit in the YM_status byte and acknowledges the IRQ. $18 LFO Freq. LFRQ Sets LFO frequency.     $00 = ~0.008Hz     $FF = ~32.6Hz $19 LFO Amplitude 0 AMD        AMD = Amplitude Modulation Depth       PMD = Phase Modulation (vibrato) Depth       Bit 7 determines which parameter is being set when writing into       this register.      1 PMD $1B CT / LFO Waveform CT . . . . W        CT: sets output pins CT1 and CT1 high or low. (not connected to anything in X16)       W: LFO Waveform: 0-4 = Saw, Square, Triange, Noise       For sawtooth: PM-&gt;////  AM-&gt;\\\\\\\\"},{"location":"X16%20Reference%20-%2011%20-%20Sound%20Programming/#channel-cfg-registers","title":"Channel CFG Registers","text":"Register Range Bit 7 Bit 6 Bit 5 Bit 4 Bit 3 Bit 2 Bit 1 Bit 0 Description $20 + channel RL FB CON RLRight/Left Output Enable FBM1 Feedback Level CONOperator connection algorithm KCKey Code KFKey Fraction PMSPhase Modulation Sensitivity AMSAmplitude Modulation Sensitivity $28 + channel . KC $30 + channel KF . . $38 + channel . PMS . . AMS"},{"location":"X16%20Reference%20-%2011%20-%20Sound%20Programming/#operator-cfg-registers","title":"Operator CFG Registers","text":"Register Range Operator Bit 7 Bit 6 Bit 5 Bit 4 Bit 3 Bit 2 Bit 1 Bit 0 Description $40 M1: $40+channel . DT1 MUL DT1Detune Amount (fine) MULFrequency Multiplier M2: $48+channel C1: $50+channel C2: $58+channel $60 M1: $60+channel . TL TLTotal Level (volume attenuation)                        (0=max, $7F=min)          M2: $68+channel C1: $70+channel C2: $78+channel $80 M1: $80+channel KS . AR KSKey Scaling (ADSR rate scaling) ARAttack Rate M2: $88+channel C1: $90+channel C2: $98+channel $A0 M1: $A0+channel AMEna . . D1R AM-EnaAmplitude Modulation Enable D1RDecay Rate 1                         (From peak down to sustain level)          M2: $A8+channel C1: $B0+channel C2: $B8+channel $C0 M1: $C0+channel DT2 . D2R DT2Detune Amount (coarse) D2RDecay Rate 2                         (During sustain phase)          M2: $C8+channel C1: $D0+channel C2: $D8+channel $E0 M1: $E0+channel D1L RR D1LDecay 1 Level (Sustain level)                         Level at which decay switches from D1R to D2R          RRRelease Rate M2: $E8+channel C1: $F0+channel C2: $F8+channel"},{"location":"X16%20Reference%20-%2011%20-%20Sound%20Programming/#ym2151-register-details","title":"YM2151 Register Details","text":""},{"location":"X16%20Reference%20-%2011%20-%20Sound%20Programming/#global-parameters","title":"Global Parameters","text":"<p>LR (LFO Reset)</p> <p>Register $01, bit 1</p> <p>Setting this bit will disable the LFO and hold it at level 0. Clearing this bit allows the LFO to operate as normal. (See LFRQ for further info)</p> <p>KON (KeyON)</p> <p>Register $08</p> <ul> <li> <p>Bits 0-2: Channel_Number</p> </li> <li> <p>Bits 3-6: Operator M1, C1, M2, C2 control bits:</p> </li> <li>0: Releases note on operator</li> <li>0-&gt;1: Triggers note attack on operator</li> <li>1-&gt;1: No effect</li> </ul> <p>Use this register to start/stop notes. Typically, all 4 operators are triggered/released together at once. Writing a value of $78+channel_number will start a note on all 4 OPs, and writing a value of $00+channel_number will stop a note on all 4 OPs.</p> <p>NE (Noise Enable)</p> <p>Register $0F, Bit 7</p> <p>When set, the C2 operator of channel 7 will use a noise waveform instead of a sine.</p> <p>NFRQ (Noise Frequency)</p> <p>Register $0F, Bits 0-4</p> <p>Sets the noise frequency, $00 is the lowest and $1F is the highest. NE bit must be set in order for this to have any effect. Only affects operator C2 on channel 7.</p> <p>CLKA1 (Clock A, high order bits)</p> <p>Register $10, Bits 0-7</p> <p>This is the high-order value for Clock A (a 10-bit value).</p> <p>CLKA2 (Clock A, low order bits)</p> <p>Register $11, Bits 0-1</p> <p>Sets the 2 low-order bits for Clock A (a 10-bit value).</p> <p>Timer A's period is Computed as (64*(1024-ClkA)) / PhiM ms.  (PhiM = 3579.545Khz)</p> <p>CLKB (Clock B)</p> <p>Register $12, Bits 0-7</p> <p>Sets the Clock B period. The period for Timer B is computed as (1024*(256-CLKB)) / PhiM ms. (PhiM = 3579.545Khz)</p> <p>CSM</p> <p>Register $14, Bit 7</p> <p>When set, the YM2151 will generate a KeyON attack on all 8 channels whenever TimerA overflows.</p> <p>Clock ACK</p> <p>Register $14, Bits 4-5</p> <p>Clear (acknowledge) IRQ status generated by TimerA and TimerB (respectively).</p> <p>IRQ EN</p> <p>Register $14, Bits 2-3</p> <p>When set, enables IRQ generation when TimerA or TimerB (respectively) overflow. The IRQ status of the two timers is checked by reading from the YM2151_STATUS byte. Bit 0 = Timer A IRQ status, and Bit 1 = Timer B IRQ status. Note that these status bits are only active if the timer has overflowed AND has its IRQ_EN bit set.</p> <p>Clock Start</p> <p>Register $14, Bits 0-1</p> <p>When set, these bits clear the TimerA and TimerB (respectively) counters and starts it running.</p> <p>LFRQ (LFO Frequency)</p> <p>Register $18, Bits 0-7</p> <p>Sets the LFO frequency.</p> <ul> <li>$00 = ~0.008Hz</li> <li>$FF = ~32.6Hz</li> </ul> <p>Note that even setting the value zero here results in a positive LFO frequency. Any channels sensitive to the LFO will still be affected by the LFO unless the <code>LR</code> bit is set in register $01 to completely disable it.</p> <p>AMD (Amplitude Modulation Depth)</p> <p>Register $19 Bits 0-6, Bit 7 clearParameters</p> <p>Sets the peak strength of the LFO's Amplitude Modulation effect. Note that bit 7 of the value written into $19 must be clear in order to set the AMD. If bit 7 is set, the write will be interpreted as PMD.</p> <p>PMD (Phase Modulation Depth)</p> <p>Register $19 Bits 0-6, Bit 7 set</p> <p>Sets the peak strength of the LFO's Phase Modulation effect. Note that bit 7 of the value written into $19 must be set in order to set the PMD. If bit 7 is clear, the value is interpreted as AMD.</p> <p>CT (Control pins)</p> <p>Register $1B, Bits 6-7</p> <p>These bits set the electrical state of the two CT pins to on/off. These pins are not connected to anything in the X16 and have no effect.</p> <p>W (LFO Waveform)</p> <p>Register $1B, Bits 0-1</p> <p>Sets the LFO waveform: 0: Sawtooth, 1: Square (50% duty cycle), 2: Triangle, 3: Noise</p>"},{"location":"X16%20Reference%20-%2011%20-%20Sound%20Programming/#channel-control-parameters","title":"Channel Control Parameters","text":"<p>RL (Right/Left output enable)</p> <p>Register $20 (+ channel), Bits 6-7</p> <p>Setting/Clearing these bits enables/disables audio output for the selected channel. (bit6=left, bit7=right)</p> <p>FB (M1 Self-Feedback)</p> <p>Register $20 (+ channel), bits 3-5</p> <p>Sets the amount of self feedback on operator M1 for the selected channel. 0=none, 7=max</p> <p>CON (Connection Algorithm)</p> <p>Register $20 (+ channel), bits 0-2</p> <p>Sets the selected channel to connect the 4 operators in one of 8 arrangements.</p> <p>[insert picture here]</p> <p>KC (Key Code - Note selection)</p> <p>Register $28 + channel, bits 0-6</p> <p>Sets the octave and semitone for the selected channel. Bits 4-6 specify the octave (0-7) and bits 0-3 specify the semitone:</p> 0 1 2 4 5 6 8 9 A C D E C\u266f D D\u266f E F F\u266f G G\u266f A A\u266f B C <p>Note that natural C is at the TOP of the selected octave, and that each 4th value is skipped. Thus if concert A (A-4, 440hz) is KC=$4A, then middle C is KC=$3E</p> <p>KF (Key Fraction)</p> <p>Register $30 + channel, Bits 2-7</p> <p>Raises the pitch by 1/64th of a semitone * the KF value.</p> <p>PMS (Phase Modulation Sensitivity)</p> <p>Register $38 + channel, Bits 4-6</p> <p>Sets the Phase Modulation (vibrato) sensitivity of the selected channel. The resulting vibrato depth is determined by the combination of the global PMD setting (see above) modified by each channel's PMS.</p> <p>Sensitivity values: (+/- cents)</p> 0 1 2 3 4 5 6 7 0 5 10 20 50 100 400 700 <p>AMS (Amplitude Modulation Sensitivity)</p> <p>Register $38 + channel, Bits 0-1</p> <p>Sets the Amplitude Modulation sensitivity of the selected channel. Note that each operator may individually enable or disable this effect on its output by setting/clearing the AMS-Ena bit (see below). Operators acting as outputs will exhibit a tremolo effect (varying volume) and operators acting as modulators will vary their effectiveness on the timbre when enabled for amplitude modulation.</p> <p>Sensitivity values: (dB)</p> 0 1 2 3 0 23.90625 47.8125 95.625"},{"location":"X16%20Reference%20-%2011%20-%20Sound%20Programming/#operator-control-parameters","title":"Operator Control Parameters","text":"<p>Operators are arranged as follows:</p> name M1 M2 C1 C2 index 0 1 2 3 <p>These are the names used throughout this document for consistency, but they may function as either modulators or carriers, depending on which <code>CON</code> ALG is used.</p> <p>The Operator Control parameters are mapped to channels/operators as follows: Register + 8*op + channel. You may also choose to think of these register addresses as using bits 0-2 = channel, bits 3-4 = operator, and bits 5-7 = parameter. This reference will refer to them using the address range, e.g. $60-$7F = TL. To set TL for channel 2, operator 1, the register address would be $6A ($60 + 1*8 + 2).</p> <p>DT1 (Detune 1 - fine detune)</p> <p>Registers $40-$5F, Bits 4-6</p> <p>Detunes the operator from the channel's main pitch. Values 0 and 4=no detuning. Values 1-3=detune up, 5-7 = detune down. The amount of detuning varies with pitch. It decreases as the channel's pitch increases.</p> <p>MUL (Frequency Multiplier)</p> <p>Registers $40-$5F, Bits 0-3</p> <p>If MUL=0, it multiplies the operator's frequency by 0.5 Otherwise, the frequency is multiplied by the value in MUL (1,2,3...etc)</p> <p>TL (Total Level - attenuation)</p> <p>Registers $60-$7F, Bits 0-6</p> <p>This is essentially \"volume control\" - It is an attenuation value, so $00 = maximum level and $7F is minimum level. On output operators, this is the volume output by that operator. On modulating operators, this affects the amount of modulation done to other operators.</p> <p>KS (Key Scaling)</p> <p>Registers $80-$9F, Bits 6-7</p> <p>Controls the speed of the ADSR progression. The KS value sets four different levels of scaling. Key scaling increases along with the pitch set in KC. 0=min, 3=max</p> <p>AR (Attack Rate)</p> <p>Registers $80-$9F, Bits 0-4</p> <p>Sets the attack rate of the ADSR envelope. 0=slowest, $1F=fastest</p> <p>AMS-Enable (Amplitude Modulation Sensitivity Enable)</p> <p>Registers $A0-$BF, Bit 7</p> <p>If set, the operator's output level will be affected by the LFO according to the channel's AMS setting. If clear, the operator will not be affected.</p> <p>D1R (Decay Rate 1)</p> <p>Registers $A0-$BF, Bits 0-4</p> <p>Controls the rate at which the level falls from peak down to the sustain level (D1L). 0=none, $1F=fastest.</p> <p>DT2 (Detune 2 - coarse)</p> <p>Registers $C0-$DF, Bits 6-7</p> <p>Sets a strong detune amount to the operator's frequency. Yamaha suggests that this is most useful for sound effects. 0=off,</p> <p>D2R (Decay Rate 2)</p> <p>Registers $C0-$DF, Bits 0-4</p> <p>Sets the Decay2 rate, which takes effect once the level has fallen from peak down to the sustain level (D1L). This rate continues until the level reaches zero or until the note is released.</p> <p>0=none, $1F=fastest</p> <p>D1L</p> <p>Registers $E0-$FF, Bits 4-7</p> <p>Sets the level at which the ADSR envelope changes decay rates from D1R to D2R. 0=minimum (no D2R), $0F=maximum (immediately at peak, which effectively disables D1R)</p> <p>RR</p> <p>Registers $E0-$FF, Bitst 0-3</p> <p>Sets the rate at which the level drops to zero when a note is released. 0=none, $0F=fastest</p> <p></p>"},{"location":"X16%20Reference%20-%2011%20-%20Sound%20Programming/#getting-sound-out-of-the-ym2151-a-brief-tutorial","title":"Getting sound out of the YM2151 (a brief tutorial)","text":"<p>While there is a large number of parameters that affect the sound of the YM2151, its operation can be thought of in simplified terms if you consider that there are basically three components to deal with: Instrument configuration (patch), voice pitch selection, and \"pressing/releasing\" the \"key\" to trigger (begin) and release (end) notes. It's essentially the same as using a music keyboard. Pressing an instrument button (e.g. Marimba) makes the keyboard sound like a Marimba. Once this is done, you press a key on the keyboard to play a note, and release it to stop the note. With the YM, loading a patch (pressing the Marimba button) entails setting all of the various operators' registers on the voice(s) you want the instrument to be used on. On the music keyboard, pitch and note stop/start are done with a single piano key. In the YM2151, these are two distinct actions.</p> <p>For this tutorial, we will start with the simplest operation, (triggering notes) and proceed to note selection, and finally patch configuration.</p>"},{"location":"X16%20Reference%20-%2011%20-%20Sound%20Programming/#triggering-and-releasing-notes","title":"Triggering and Releasing Notes","text":"<p>Key On/Off (KON) Register ($08):</p> <p>This is probably the most important single register in the YM2151. It is used to trigger and release notes. It controls the key on/off state for all 8 channels. A note is triggered whenever its key state changes from off to on, and is released whenever the state changes from on to off. Repeated writes of the same state (off-&gt;off or on-&gt;on) have no effect.</p> <p>Whenever an operator is triggered, it progresses through the states of attack, decay1, and sustain/decay2. Whenever an active note is released, it enters the release state where the volume decreases until reaching zero. It then remains silent until the next time the operator is triggered. If you are familiar with the C64 SID chip, this is the same behavior as the \"gate\" bit on that chip.</p> <p>Key state and voice selection are both contained in the value written into the KON register as follows:</p> <ul> <li>Key ON = $78 + channel number</li> <li>Key OFF = $0 + channel number</li> </ul> <p>Simple Examples:</p> <p>To release the note in channel 4: write $08 to <code>YM_address</code> ($9F40) and then write $04 ($00+4) to <code>YM_data</code> ($9F41).</p> <p>To begin a note on channel 7, write $08 into <code>YM_address</code> to select the KON register. Then write $7F ($78+7) into <code>YM_data</code></p> <p>If the current key state of a channel is not known, you can write key off and then key on immediately (after waiting for the YM busy period to end, of course):</p> <pre><code>POKE $9F40,$08 : REM SELECT KEY ON/OFF REGISTER\nPOKE $9F41,$07 : REM KEY OFF FOR VOICE 7\nPOKE $9F41,$7F : REM KEY ON  FOR VOICE 7\n</code></pre> <p>Remember: BASIC is slow enough that you do not need to poll the <code>YM_status</code> byte, but assembly and other languages will need to do so.</p> <p>The ADSR parameters will be discussed in more detail later.</p> <p>Advanced:</p> <p>Each channel (voice) of the YM2151 uses 4 operators which can be gated together or independently. Independent triggering gives lots of advanced possibilities. To trigger and release operators independently, you use different values than $78 or $00. These values are composed by 4 bits which signal the on/off state for each operator.</p> <p>Suppose a note is playing on channel 2 with all 4 operators active. You can release only the M1 operator by writing $72 into register $08.</p> <p>The KON value format:</p> 7 6 5 4 3 2 1 0  -  C2 M2 C1 M1 Channel"},{"location":"X16%20Reference%20-%2011%20-%20Sound%20Programming/#pitch-control","title":"Pitch Control","text":""},{"location":"X16%20Reference%20-%2011%20-%20Sound%20Programming/#ym-registers","title":"YM Registers","text":"<ul> <li><code>KC</code> = $28 + channel number</li> <li><code>KF</code> = $30 + channel number</li> </ul> <p>For note selection, each voice has two parameters: <code>KC</code> (Key Code) and <code>KF</code> (Key Fraction). These are set in register ranges $28 and $30, respectively. The KC codes correspond directly to the notes of the chromatic scale. Each value maps to a specific octave &amp; semitone. The <code>KF</code> value can even be ignored for basic musical playback. It is mostly useful for vibrato or pitch bend effects. <code>KF</code> raises the pitch selected in <code>KC</code> in 1/64th increments of the way up to the next semitone.</p> <p>Like all registers in the YM, whenever a channel's <code>KC</code> or <code>KF</code> value is written, it takes effect immediately. If a note is playing, its pitch immediately changes. When triggering new notes, it is not important whether you write the pitch or key the note first. This happens quickly in real-time and you will not hear any real difference. Changing the pitch without re-triggering the ADSR envelope is how to achieve pitch slides or a legato effect.</p>"},{"location":"X16%20Reference%20-%2011%20-%20Sound%20Programming/#key-code-kc","title":"Key Code (KC)","text":"<p><code>KC</code> codes are \"conveniently\" arranged so that the upper nybble is the octave (0-7) and the lower nybble is the pitch. The pitches are arranged as follows within an octave:</p> Note C\u266f D D\u266f E F F\u266f G G\u266f A A\u266f B C Low Nybble (hex) 0 1 2 4 5 6 8 9 A C D E <p>(Note that every 4th value is skipped.)</p> <p>Combine the above with an octave to get a note's <code>KC</code> value. For instance: concert A (440hz) is (by sheer coincidence) <code>$4A</code>. Middle C is <code>$3E</code>, and so forth.</p>"},{"location":"X16%20Reference%20-%2011%20-%20Sound%20Programming/#key-fraction-kf","title":"Key Fraction (KF)","text":"<p><code>KF</code> values are written into the top 6 bits of the voice's <code>KF</code> register. Basically the value is <code>0, 1&lt;&lt;2, 2&lt;&lt;2, .. 63&lt;&lt;2</code></p>"},{"location":"X16%20Reference%20-%2011%20-%20Sound%20Programming/#loading-a-patch","title":"Loading a patch","text":"<p>The patch configuration is by far the most complicated aspect of using the YM. If you take as given that a voice has a patch loaded, then playing notes on it is fairly straightforward. For the moment, we will assume a pre-patched voice.</p> <p>To get started quickly, here is some BASIC code to patch voice 0 with a marimba tone:</p> <pre><code>5 YA=$9F40 : YD=$9F41 : V=0\n10 REM: MARIMBA PATCH FOR YM VOICE 0 (SET V=0..7 FOR OTHER VOICES)\n20 DATA $DC,$00,$1B,$67,$61,$31,$21,$17,$1F,$0A,$DF,$5F,$DE\n30 DATA $DE,$0E,$10,$09,$07,$00,$05,$07,$04,$FF,$A0,$16,$17\n40 READ D\n50 POKE YA,$20+V : POKE YD,D\n60 FOR A=$38 TO $F8 STEP 8\n70 READ D : POKE YA,A+V : POKE YD,D\n80 NEXT A\n</code></pre> <p>Once a voice has been patched as above, you can now POKE notes into it with very few commands for each note.</p> <p>Patches consist mostly of ADSR envelope parameters. A complete patch contains values for the $20 range register (LR|FB|CON), for the $38 range register (AMS|PMS), and 4 values for each of the parameter ranges starting at $40. (4 operators per voice means 4 values per parameter). Since this is a huge amount of flexibility, it is recommended to experiment with instrument creation in an application such as a chip tracker or VST, as the creative process of instrument design is very hands-on and subjective.</p>"},{"location":"X16%20Reference%20-%2011%20-%20Sound%20Programming/#using-the-lfo","title":"Using the LFO","text":"<p>There is a single global LFO in the YM2151 which can affect the level (volume) and/or pitch of all 8 channels simultaneously. It has a single frequency and waveform setting which must be shared among all channels, and shared between both phase and amplitude modulation. The global parameters <code>AMD</code> and <code>PMD</code> act as modifiers to the sensitivity settings of the channels. While the frequency and waveform of the LFO pattern must be shared, the depths of the two types of modulation are independent of each other.</p> <p>You can re-trigger the LFO by setting and then clearing the <code>LR</code> bit in the test register ($01).</p>"},{"location":"X16%20Reference%20-%2011%20-%20Sound%20Programming/#vibrato","title":"Vibrato","text":"<p>Use Phase Modulation on the desired channels. The <code>PMS</code> parameter for each channel allows them to vary their vibrato depths individually. Channels with <code>PMS</code> set to zero will have no vibrato. The values given earlier in the <code>PMS</code> parameter description represent their maximum amount of affect. These values are modified by the global <code>PMD.</code> A <code>PMD</code> valie of $7F means 100% effectiveness, $40 means all channels' vibrato depths will be reduced by half, etc.</p> <p>The vibrato speed is global, depending solely on the value set to <code>LFRQ.</code></p>"},{"location":"X16%20Reference%20-%2011%20-%20Sound%20Programming/#amplitude-modulation","title":"Amplitude Modulation","text":"<p>Amplitude modulation works similarly to phase modulation, except that the intensity is a combination of the per-channel <code>AMS</code> value modified by the global <code>AMD</code> value. Additionally, within channels having non-zero amplitude modulation sensitivity, individual operators must have their <code>AMS-en</code> bit enabled in order to be affected by the modulation.</p> <p>If the active operators are acting as carriers (generating output directly), then amplitude modulation will vary the volume of the sound being produced by that operator. This can be described as a \"tremolo\" effect. If the operators are acting as modulators, then the timbre of the voice will vary as the output level of the affected operators increases and decreases. You may simultaneously enable amplitude modulation on both types of operators.</p> <p>The amplitude modulation speed is global, depending solely on the value set to <code>LFRQ.</code></p>"},{"location":"X16%20Reference%20-%2012%20-%20IO%20Programming/","title":"12: I/O Programming","text":"<p>There are two 65C22 \"Versatile Interface Adapter\" (VIA) I/O controllers in the system, VIA#1 at address $9F00 and VIA#2 at address $9F10. The IRQ out lines of VIA#1 is connected to the CPU's NMI line, while the IRQ out line of VIA#2 is connected to the CPU's IRQ line.</p> <p>The-following tables describe the connections of the I/O pins:</p> <p>VIA#1</p> Pin Name Description PA0 I2CDATA I2C Data PA1 I2CCLK I2C Clock PA2 NESLATCH NES LATCH (for all controllers) PA3 NESCLK NES CLK   (for all controllers) PA4 NESDAT3 NES DATA  (controller 3) PA5 NESDAT2 NES DATA  (controller 2) PA6 NESDAT1 NES DATA  (controller 1) PA7 NESDAT0 NES DATA  (controller 0) PB0 Unused PB1 Unused PB2 Unused PB3 SERATNO Serial ATN  out PB4 SERCLKO Serial CLK  out PB5 SERDATAO Serial DATA out PB6 SERCLKI Serial CLK  in PB7 SERDATAI Serial DATA in CA1 Unused CA2 Unused CB1 IECSRQ CB2 Unused <p>The KERNAL uses Timer 2 for timing transmissions on the Serial Bus.</p> <p>VIA#2</p> <p>The second VIA is completely unused by the system. All its 16 GPIOs and 4 handshake I/Os can be freely used.</p>"},{"location":"X16%20Reference%20-%2012%20-%20IO%20Programming/#i2c-bus","title":"I2C Bus","text":"<p>The Commander X16 contains an I2C bus, which is implemented through two pins of VIA#1. The system management controller (SMC) and the real-time clock (RTC) are connected through this bus. The KERNAL APIs <code>i2c_read_byte</code> and <code>i2c_write_byte</code> allow talking to these devices.</p>"},{"location":"X16%20Reference%20-%2012%20-%20IO%20Programming/#system-management-controller","title":"System Management Controller","text":"<p>The system management controller (SMC) is device $42 on the I2C bus. It controls the activity LED, and can be used to power down the system or inject RESET and NMI signals. It also handles communication with the PS/2 keyboard and mouse.</p> Register Value Description $01 $00 Power off $01 $01 Hard reboot $02 $00 Inject RESET $03 $00 Inject NMI $05 $00/$FF Activity LED off/on $07 - Read from keyboard buffer $08 $00..$FF Echo $18 - Read ps2 status $19 $00..$FF Send ps2 command $1A $0000..$FFFF Send ps2 command (2 bytes) $20 $00 Set mouse device ID, standard mouse $20 $03 Set mouse device ID, Intellimouse with scroll wheel $20 $04 Set mouse device ID, Intellimouse with scroll wheel+extra buttons $21 - Read from mouse buffer $22 - Get mouse device ID $30 - Get SMC firmware version, major $31 - Get SMC firmware version, minor $32 - Get SMC firmare version, patch $8F $31 Start bootloader, if present"},{"location":"X16%20Reference%20-%2012%20-%20IO%20Programming/#real-time-clock","title":"Real-Time-Clock","text":"<p>The Commander X16 contains a battery-backed Microchip MCP7940N real-time-clock (RTC) chip as device $6F. It provide a real-time clock/calendar, two alarms and 64 bytes of RAM.</p> Register Description $00 Clock seconds $01 Clock minutes $02 Clock hours $03 Clock weekday $04 Clock day $05 Clock month $06 Clock year $07 Control $08 Oscillator trim $09 reserved $0A Alarm 0 seconds $0B Alarm 0 minutes $0C Alarm 0 hours $0D Alarm 0 weekday $0E Alarm 0 day $0F Alarm 0 month $10 reserved $11 Alarm 1 seconds $12 Alarm 1 minutes $13 Alarm 1 hours $14 Alarm 1 weekday $15 Alarm 1 day $16 Alarm 1 month $17 reserved $18 Power-fail minutes $19 Power-fail hours $1A Power-fail day $1B Power-fail month $1C Power-up minutes $1D Power-up hours $1E Power-up day $1F Power-up month $20-$5F 64 Bytes SRAM <p>The second half of the RTC's SRAM (NVRAM) is reserved for use by the KERNAL.  $20-$3F is available for use by user programs.</p> <p>For more information, please refer to this device's datasheet.</p>"},{"location":"X16%20Reference%20-%2013%20-%20Working%20with%20CMDR-DOS/","title":"13: Working With CMDR-DOS","text":"<p>This manual describes Commodore DOS on FAT32, aka CMDR-DOS.</p>"},{"location":"X16%20Reference%20-%2013%20-%20Working%20with%20CMDR-DOS/#cmdr-dos","title":"CMDR-DOS","text":"<p>Commander X16 duplicates and extends the programming interface used by Commodore's line of disk drives, including the famous (or infamous) VIC-1541. CMDR-DOS uses the industry-standard FAT-32 format. Partitions can be 32MB up to (in theory) 2TB and supports CMD-style partitions, subdirectories, timestamps and filenames up to 255 characters. It is the DOS built into the Commander X16.</p> <p>There are three basic interfaces for CMDR-DOS: the binary interface (LOAD, SAVE, etc.), the data file interface (OPEN, PRINT#, INPUT#, GET#), and the command interface. We will give a brief summary of BASIC commands here, but please refer to  Chapter 4: BASIC Programming for full syntax of each command.</p> <p>If you are familiar with the SD2IEC or the CMD hard drive, navigating partitions and subdirectories is similar, with \"CD\", \"MD\", and \"RD\" commands to navigate directories.</p>"},{"location":"X16%20Reference%20-%2013%20-%20Working%20with%20CMDR-DOS/#binary-loadsave","title":"Binary Load/Save","text":"<p>The primary use of the binary interface is loading and saving program files and loading binary files into RAM.</p> <p>Your binary commands are LOAD, SAVE, BLOAD, VLOAD, BVLOAD, VERIFY, and BVERIFY.</p> <p>This is a brief summary of the LOAD and SAVE commands. For full documentation, refer to Chapter 4: BASIC Programming.</p>"},{"location":"X16%20Reference%20-%2013%20-%20Working%20with%20CMDR-DOS/#load","title":"LOAD","text":"<p><code>LOAD &lt;filename&gt; [,device][,secondary_address]</code> <code>LOAD &lt;filename&gt; [,device][,ram_bank,start_address]</code></p> <p>This reads a program file from disk. The first two bytes of the file are the memory location to which the file will be loaded, with the low byte first. BASIC programs will start with $01 $08, which translates to $0801, the start of BASIC memory. The device number should be 8 for reading from the SD card.</p> <p>If using the first form, secondary_address has multiple meanings:</p> <ul> <li> <p>0 or not present: load the data to address $0801, regardless of the address header.</p> </li> <li> <p>1: load to the address specified in the file's header</p> </li> <li> <p>2: load the file headerless to the location $0801.</p> </li> </ul> <p>If using the second form, ram_bank sets the bank for the load, and start_address is the location to read your data into.</p> <p>The value of the ram_bank argument only affects the load when the start_address is set in the range of \\$A000-\\$BFFF.</p> <p>Examples:</p> <p><code>LOAD \"ROBOTS.PRG\",8,1</code> loads the program \"ROBOTS.PRG\" into memory at the address encoded in the file.</p> <p><code>LOAD \"HELLO\",8</code> loads a program to the start of BASIC at $0801.</p> <p><code>LOAD \"*\",8,1</code> loads the first program in the current directory. See the section below on wildcards for more information about using * and ? to access files of a certain type or with unprintable characters.</p> <p><code>LOAD \"DATA.BIN\",8,1,$A000</code> loads a file into banked RAM, RAM bank 1, starting at $A000. The first two bytes of the file are skipped. To avoid skipping the first two bytes, use the <code>BLOAD</code> command instead.</p>"},{"location":"X16%20Reference%20-%2013%20-%20Working%20with%20CMDR-DOS/#save","title":"SAVE","text":"<p><code>SAVE &lt;filename&gt;[,device]</code></p> <p>Saves a file from the computer to the SD card. SAVE always reads from the beginning of BASIC memory at $0801, up to the end of the BASIC program. Device is optional and defaults to 8 (the SD card, or an IEC disk drive, if one is plugged in.)</p> <p>One word of caution: CMDR-DOS will not let you overwrite a file by default. To overwrite a file, you need to prefix the filename with @:, like this:</p> <p><code>SAVE \"@:DEMO.PRG\"</code></p>"},{"location":"X16%20Reference%20-%2013%20-%20Working%20with%20CMDR-DOS/#bsave","title":"BSAVE","text":"<p><code>BSAVE &lt;filename&gt;,&lt;device&gt;,&lt;ram_bank&gt;,&lt;start_address&gt;,&lt;end_address&gt;</code></p> <p>Saves an arbitrary region of memory to a file without a two-byte header. To allow concatenating multiple regions of RAM into a single file with multiple successive calls to BSAVE, BSAVE allows the use of append mode in the filename string. To make use of this option, the first call to BSAVE can be called normally, which creates the file anew, while subsequent calls should be in append mode to the same file.</p> <p>Another way to save arbitrary binary data from arbitrary locations is to use the S command in the MONITOR: Chapter 7: Machine Language Monitor.</p> <p><code>S \"filename\",8,&lt;start_address&gt;,&lt;end_address&gt;</code></p> <p>Where  and  are a 16-bit hexadecimal address. <p>After a SAVE or BSAVE, the DOS command is implicitly run to show the drive status. The Commodore file I/O model does not report certain failures back to BASIC, so you should double-check the result after a write operation.</p> <pre><code>00, OK,00,00\n\nREADY.\n</code></pre> <p>An OK reply means the file saved correctly. Any other result is an error that should be addressed:</p> <pre><code>63,FILE EXISTS,00,00\n</code></pre> <p>CMDR-DOS does not allow files to be overwritten without special handling. If you get FILE EXISTS, either change your file's name or save it with the @: prefix, like this:</p> <p><code>SAVE \"@:HELLO\"</code></p>"},{"location":"X16%20Reference%20-%2013%20-%20Working%20with%20CMDR-DOS/#bload","title":"BLOAD","text":"<p>BLOAD loads a file without an address header to an arbitrary location in memory. Usage is similar to LOAD. However, BLOAD does not require or use the 2-byte header. The first byte in the file is the first byte loaded into memory.</p> <p><code>BLOAD \"filename\",8,&lt;ram_bank&gt;,&lt;start_address&gt;</code></p>"},{"location":"X16%20Reference%20-%2013%20-%20Working%20with%20CMDR-DOS/#vload","title":"VLOAD","text":"<p>Read binary data into VERA. VLOAD skips the 2-byte address header and starts reading at the third byte of the file.</p> <p><code>VLOAD \"filename\",8,&lt;vram_bank&gt;,&lt;start_address&gt;</code></p>"},{"location":"X16%20Reference%20-%2013%20-%20Working%20with%20CMDR-DOS/#bvload","title":"BVLOAD","text":"<p>Read binary data into VERA without a header. This works like BLOAD, but into VERA RAM.</p> <p><code>BVLOAD \"filename\",8,&lt;vram_bank&gt;,&lt;start_address&gt;</code></p>"},{"location":"X16%20Reference%20-%2013%20-%20Working%20with%20CMDR-DOS/#dos-wedge","title":"DOS WEDGE","text":"<p>The DOS wedge allows you to issue quick commands from BASIC with the &gt; or @ symbol.</p> Command Action <code>/&lt;filename&gt;</code> Load a BASIC program into RAM <code>%&lt;filename&gt;</code> Load a machine language program into RAM (like <code>,8,1</code>) <code>\u2191&lt;filename&gt;</code> Load a BASIC program into RAM and then unconditionally run it <code>\u2190&lt;filename&gt;</code> Save a BASIC program to disk <code>@</code> Display (and clear) the disk drive status <code>@$</code> Display the disk directory without overwriting the BASIC program in memory <code>@#&lt;device number&gt;</code> Change default DOS device <code>@&lt;command&gt;</code> Execute a disk drive command (e.g. <code>@S0:&lt;filename&gt;</code>) <code>&gt;&lt;command&gt;</code> Execute a disk drive command (e.g. <code>&gt;CD:&lt;dir&gt;</code>)"},{"location":"X16%20Reference%20-%2013%20-%20Working%20with%20CMDR-DOS/#sequential-files","title":"Sequential Files","text":"<p>Sequential files have two basic modes: read and write. The OPEN command opens a file for reading or writing. The PRINT# command writes to a file, and the GET# and INPUT# commands read from the file.</p> <p>todo: examples</p>"},{"location":"X16%20Reference%20-%2013%20-%20Working%20with%20CMDR-DOS/#command-channel","title":"Command Channel","text":"<p>The command channel allows you to send commands to the CMDR-DOS interface. You can open and write to the command channel using the OPEN command, or you can use the DOS command to issue commands and read the status. While DOS can be used in immediate mode or in a program, only the combination of OPEN/INPUT# can read the command response back into a variable for later processing.</p> <p>In either case, the ST psuedo-variable will allow you to quickly check the status. A status of 64 is \"okay\", and any other value should be checked by reading the error channel (shown below.)</p> <p>To open the command channel, you can use the OPEN command with secondary address 15.</p> <p><code>10 OPEN 15,8,15</code></p> <p>If you want to issue a command immediately, add your command string at the end of the OPEN statement:</p> <p><code>10 OPEN 15,8,15, \"CD:/\"</code></p> <p>This example changes to the root directory of your SD card.</p> <p>To know whether the OPEN command succeeded, you must open the command channel and read the result. To read the command channel (and clear the error status if an error occurred), you need to read four values:</p> <p><code>20 INPUT#15,A,B$,C,D</code></p> <p>A is the error number. B$ is the error message. C and D are unused in CMDR-DOS for most responses, but will return the track and sector when used with a disk drive on the IEC connector.</p> <pre><code>30 PRINT A;B$;C;D\n40 CLOSE 15\n</code></pre> <p>So the entire program looks like:</p> <pre><code>10 OPEN 15,8,15, \"CD:/\"\n20 INPUT#15,A,B$,C,D\n30 PRINT A;B$;C;D\n40 CLOSE 15\n</code></pre> <p>If the error number (<code>A</code>) is less than 20, no error occurred. Usually this result is 0 (or 00) for OK.</p> <p>You can also use the DOS command to send a command to CMDR-DOS. Entering DOS by itself will print the drive's status on the screen. Entering a command in quotes or a string variable will execute the command. We will talk more about the status variable and DOS status message in the next section.</p> <pre><code>DOS\n00, 0K, 00, 00\nREADY.\nDOS \"CD:/\"\n</code></pre> <p>The special case of <code>DOS \"$\"</code> will print a directory listing.</p> <p><code>DOS \"$\"</code></p> <p>You can also read the name of the current directory with DOS\"$=C\"</p> <p><code>DOS \"$=C\"</code></p>"},{"location":"X16%20Reference%20-%2013%20-%20Working%20with%20CMDR-DOS/#dos-features","title":"DOS Features","text":"<p>This is the base features set compared to other Commodore DOS devices:</p> Feature 1541 1571/1581 CMD HD/FD SD2IEC CMDR-DOS Sequential files yes yes yes yes yes Relative files yes yes yes yes not yet Block access yes yes yes yes not yet Code execution yes yes yes no yes Burst commands no yes yes no no Timestamps no no yes yes yes Time API no no yes yes not yet Partitions no no yes yes yes Subdirectories no no yes yes yes <p>It consists of the following components:</p> <ul> <li>Commodore DOS interface</li> <li><code>dos/main.s</code>: TALK/LISTEN dispatching</li> <li><code>dos/parser.s</code>: filename/path parsing</li> <li><code>dos/cmdch.s</code>: command channel parsing, status messages</li> <li><code>dos/file.s</code>: file read/write</li> <li>FAT32 interface</li> <li><code>dos/match.s</code>: FAT32 character set conversion, wildcard matching</li> <li><code>dos/dir.s</code>: FAT32 directory listing</li> <li><code>dos/function.s</code>: command implementations for FAT32</li> <li>FAT32 implementation</li> <li><code>fat32/*</code>: FAT32 for 65c02 library</li> </ul> <p>All currently unsupported commands are decoded in <code>cmdch.s</code> anyway, but hooked into <code>31,SYNTAX ERROR,00,00</code>, so adding features should be as easy as adding the implementation.</p> <p>CMDR-DOS implements the TALK/LISTEN layer (Commodore Peripheral Bus layer 3), it can therefore be directly hooked up to the Commodore IEEE KERNAL API (<code>talk</code>, <code>tksa</code>, <code>untlk</code>, <code>listn</code>, <code>secnd</code>, <code>unlsn</code>, <code>acptr</code>, <code>ciout</code>) and be used as a computer-based DOS, like on the C65 and the X16.</p> <p>CMDR-DOS does not contain a layer 2 implementation, i.e. IEEE-488 (PET) or Commodore Serial (C64, C128, ...). By adding a Commodore Serial (aka \"IEC\") implementation, CMDR-DOS could be adapted for use as the system software of a standalone 65c02-based Serial device for Commodore computers, similar to an sd2iec device.</p> <p>The Commodore DOS side and the FAT32 side are well separated, so a lot of code could be reused for a DOS that uses a different filesystem.</p> <p>Or the core feature set, these are the supported functions:</p> Feature Syntax Supported Comment Reading <code>,?,R</code> yes Writing <code>,?,W</code> yes Appending <code>,?,A</code> yes Modifying <code>,?,M</code> yes Types <code>,S</code>/<code>,P</code>/<code>,U</code>/<code>,L</code> yes ignored on FAT32 Overwriting <code>@:</code> yes Magic channels 0/1 yes Channel 15 command command<code>:</code>args... yes Channel 15 status code<code>,</code>string<code>,</code>a<code>,</code>b yes CMD partition syntax <code>0:</code>/<code>1:</code>/... yes CMD subdirectory syntax <code>//DIR/:</code>/<code>/DIR/:</code> yes Directory listing <code>$</code> yes Dir with name filtering <code>$:FIL*</code> yes Dir with name and type filtering <code>$:*=P</code>/<code>$:*=D</code>/<code>$:*=A</code> yes Dir with timestamps <code>$=T</code> yes with ISO-8601 times Dir with time filtering <code>$=T&lt;</code>/<code>$=T&gt;</code> not yet Dir long listing <code>$=L</code> yes shows human readable file size instead of blocks, time in ISO-8601 syntax, attribute byte, and exact file size in hexadecimal Partition listing <code>$=P</code> yes Partition filtering <code>$:NAME*=P</code> no Current Working Directory <code>$=C</code> yes <p>And this table shows which of the standard commands are supported:</p> Name Syntax Description Supported BLOCK-ALLOCATE <code>B-A</code> medium medium track sector Allocate a block in the BAM no<sup>1</sup> BLOCK-EXECUTE <code>B-E</code> channel medium track sector Load and execute a block not yet BLOCK-FREE <code>B-F</code> medium medium track sector Free a block in the BAM no<sup>1</sup> BLOCK-READ <code>B-R</code> channel medium track sector Read block no<sup>1</sup> BLOCK-STATUS <code>B-S</code> channel medium track sector Check if block is allocated no<sup>1</sup> BLOCK-WRITE <code>B-W</code> channel medium track sector Write block no<sup>1</sup> BUFFER-POINTER <code>B-P</code> channel index Set r/w pointer within buffer not yet CHANGE DIRECTORY <code>CD</code>[path]<code>:</code>name Change the current sub-directory yes CHANGE DIRECTORY <code>CD</code>[medium]<code>:\u2190</code> Change sub-directory up yes CHANGE PARTITION <code>CP</code> num Make a partition the default yes COPY <code>C</code>[path_a]<code>:</code>target_name<code>=</code>[path_b]<code>:</code>source_name[<code>,</code>...] Copy/concatenate files yes COPY <code>C</code>dst_medium<code>=</code>src_medium Copy all files between disk no<sup>1</sup> DUPLICATE <code>D:</code>dst_medium<code>=</code>src_medium Duplicate disk no<sup>1</sup> FILE LOCK <code>F-L</code>[path]<code>:</code>name[<code>,</code>...] Enable file write-protect yes FILE RESTORE <code>F-R</code>[path]<code>:</code>name[<code>,</code>...] Restore a deleted file not yet FILE UNLOCK <code>F-U</code>[path]<code>:</code>name[<code>,</code>...] Disable file write-protect yes GET DISKCHANGE <code>G-D</code> Query disk change yes GET PARTITION <code>G-P</code>[num] Get information about partition yes INITIALIZE <code>I</code>[medium] Re-mount filesystem yes LOCK <code>L</code>[path]<code>:</code>name Toggle file write protect yes MAKE DIRECTORY <code>MD</code>[path]<code>:</code>name Create a sub-directory yes MEMORY-EXECUTE <code>M-E</code> addr_lo addr_hi Execute code yes MEMORY-READ <code>M-R</code> addr_lo addr_hi [count] Read RAM yes MEMORY-WRITE <code>M-W</code> addr_lo addr_hi count data Write RAM yes NEW <code>N</code>[medium]<code>:</code>name<code>,</code>id<code>,FAT32</code> File system creation yes<sup>3</sup> PARTITION <code>/</code>[medium][<code>:</code>name] Select 1581 partition no PARTITION <code>/</code>[medium]<code>:</code>name<code>,</code>track sector count_lo count_hi <code>,C</code> Create 1581 partition no POSITION <code>P</code> channel record_lo record_hi offset Set record index in REL file not yet REMOVE DIRECTORY <code>RD</code>[path]<code>:</code>name Delete a sub-directory yes RENAME <code>R</code>[path]<code>:</code>new_name<code>=</code>old_name Rename file yes RENAME-HEADER <code>R-H</code>[medium]<code>:</code>new_name Rename a filesystem yes RENAME-PARTITION <code>R-P:</code>new_name<code>=</code>old_name Rename a partition no<sup>1</sup> SCRATCH <code>S</code>[path]<code>:</code>pattern[<code>,</code>...] Delete files yes SWAP <code>S-</code>{<code>8</code>|<code>9</code>|<code>D</code>} Change primary address yes TIME READ ASCII <code>T-RA</code> Read Time/Date (ASCII) no<sup>4</sup> TIME READ BCD <code>T-RB</code> Read Time/Date (BCD) no<sup>4</sup> TIME READ DECIMAL <code>T-RD</code> Read Time/Date (Decimal) no<sup>4</sup> TIME READ ISO <code>T-RI</code> Read Time/Date (ISO) no<sup>4</sup> TIME WRITE ASCII <code>T-WA</code> dow mo<code>/</code>da<code>/</code>yr hr<code>:</code>mi<code>:</code>se ampm Write Time/Date (ASCII) no<sup>4</sup> TIME WRITE BCD <code>T-WB</code> b0 b1 b2 b3 b4 b5 b6 b7 b8 Write Time/Date (BCD) no<sup>4</sup> TIME WRITE DECIMAL <code>T-WD</code> b0 b1 b2 b3 b4 b5 b6 b7 Write Time/Date (Decimal) no<sup>4</sup> TIME WRITE ISO <code>T-WI</code> yyyy<code>-</code>mm<code>-</code>dd<code>T</code>hh<code>:</code>mm<code>:</code>ss dow Write Time/Date (ISO) no<sup>4</sup> U1/UA <code>U1</code> channel medium track sector Raw read of a block not yet U2/UB <code>U2</code> channel medium track sector Raw write of a block not yet U3-U8/UC-UH <code>U3</code> - <code>U8</code> Execute in user buffer not yet U9/UI <code>UI</code> Soft RESET yes U:/UJ <code>UJ</code> Hard RESET yes USER <code>U0&gt;</code> pa Set unit primary address yes USER <code>U0&gt;B</code> flag Enable/disable Fast Serial yes<sup>6</sup> USER <code>U0&gt;D</code>val Set directory sector interleave no<sup>1</sup> USER <code>U0&gt;H</code> number Select head 0/1 no<sup>1</sup> USER <code>U0&gt;L</code>flag Large REL file support on/off no USER <code>U0&gt;M</code> flag Enable/disable 1541 emulation mode no<sup>1</sup> USER <code>U0&gt;R</code> num Set number fo retries no<sup>1</sup> USER <code>U0&gt;S</code> val Set sector interleave no<sup>1</sup> USER <code>U0&gt;T</code> Test ROM checksum no<sup>5</sup> USER <code>U0&gt;V</code> flag Enable/disable verify no<sup>1</sup> USER <code>U0&gt;</code> pa Set unit primary address yes USER <code>UI</code>{<code>+</code>|<code>-</code>} Use C64/VIC-20 Serial protocol no<sup>1</sup> UTILITY LOADER <code>&amp;</code>[[path]<code>:</code>]name Load and execute program no<sup>1</sup> VALIDATE <code>V</code>[medium] Filesystem check no<sup>2</sup> WRITE PROTECT <code>W-</code>{<code>0</code>|<code>1</code>} Set/unset device write protect yes <ul> <li><sup>1</sup>: outdated API, not useful, or can't be supported on FAT32</li> <li><sup>2</sup>: is a no-op, returns <code>00, OK,00,00</code></li> <li><sup>3</sup>: third argument <code>FAT32</code> has to be passed</li> <li><sup>4</sup>: CMDR-DOS was architected to run on the main computer, so it shouldn't be DOS that keeps track of the time</li> <li><sup>5</sup>: Instead of testing the ROM, this command currently verifies that no buffers are allocated, otherwise it halts. This is used by unit tests to detect leaks.</li> <li><sup>6</sup>: Repurposed for SD card read and write mode. flag selects whether fast read (auto_tx) and fast writes are enabled. 0=none, 1=auto_tx, 2=fast writes, 3=both</li> </ul> <p>The following special file syntax and <code>OPEN</code> options are specific to CMDR-DOS:</p> Feature Syntax Description Open for Read &amp; Write <code>,?,M</code> Allows arbitrarily reading, writing and setting the position (<code>P</code>)<sup>7</sup> Get current working directory <code>$=C</code> Produces a directory listing containing the name of the current working directory followed by all parent directory names all the way up to <code>/</code> <ul> <li><sup>7</sup>: once the EOF has been reached while reading, no further reads or writes are possible.</li> </ul> <p>The following added command channel features are specific to CMDR-DOS:</p> Feature Syntax Description POSITION <code>P</code> channel p0 p1 p2 p3 Set position within file (like sd2iec); all args binary TELL<sup>8</sup> <code>T</code> channel Return the current position within a file and the file's size; channel arg is binary <ul> <li><sup>8</sup>: available in ROM version R48 and later</li> </ul> <p>To use the POSITION and TELL commands, you need to open two channels: a data channel and the command channel. The channel argument should be the same as the secondary address of the data channel.</p> <p>If POSITION succeeds, <code>00, OK,00,00</code> is returned on the command channel.</p> <p>If TELL succeeds, <code>07,pppppppp ssssssss,00,00</code> is returned on the command channel, where <code>pppppppp</code> is a hexadecimal representation of the position, and <code>ssssssss</code> is a hexadecimal represenation of the file's size.</p>"},{"location":"X16%20Reference%20-%2013%20-%20Working%20with%20CMDR-DOS/#examples","title":"Examples","text":"<pre><code>OPEN 1,8,2,\"LEVEL.DAT,S,R\"\nOPEN 15,8,15,\"P\"+CHR$(2)+CHR$(0)+CHR$(1)+CHR$(0)+CHR$(0)\n</code></pre> <p>The above opens LEVEL.DAT for reading and positions the read/write pointer at byte 256.</p> <pre><code>10 OPEN 2,8,5,\"LEVEL.DAT,S,R\"\n20 OPEN 15,8,15,\"T\"+CHR$(5)\n30 INPUT#15,A,A$,T,S\n40 CLOSE 15\n50 IF A&gt;=20 THEN 90\n60 SZ=VAL(\"$\"+MID$(A$,9))\n70 PRINT \"SIZE=\";SZ\n80 GOTO 100\n90 PRINT\"ERROR\"\n100 CLOSE 2\n</code></pre> <p>This time, the secondary address is 5, and we're fetching only the file's size.</p>"},{"location":"X16%20Reference%20-%2013%20-%20Working%20with%20CMDR-DOS/#current-working-directory","title":"Current Working Directory","text":"<p>The $=C command will list the current working directory and its parent path. The current directory will be at the top of the listing, with each parent directory beneath, with / at the bottom.</p> <pre><code>DOS\"$=C\"\n\n0 \"/TEST            \"\n0    \"TEST\"             DIR\n0    \"/\"                DIR\n65535 BLOCKS FREE.\n</code></pre>"},{"location":"X16%20Reference%20-%2013%20-%20Working%20with%20CMDR-DOS/#license","title":"License","text":"<p>Copyright 2020-2024 Michael Steil &lt;mist64@mac.com&gt;, et al.</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ol> <li> <p>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</p> </li> </ol> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"X16%20Reference%20-%2014%20-%20Hardware/","title":"14: Hardware Pinouts","text":"<p>This chapter covers pinout for the I/O ports and headers.</p>"},{"location":"X16%20Reference%20-%2014%20-%20Hardware/#port-and-socket-listing","title":"Port and Socket Listing","text":"<ul> <li>VERA Connectors</li> <li>SNES Controller Ports (x2)</li> <li>IEC Port</li> <li>PS/2 Keyboard and mouse</li> <li>Expansion Slots (x4 in Gen1)</li> <li>User Port Header</li> <li>ATX Power Supply</li> <li>Front Panel</li> </ul> <p>Chip sockets are not listed; pinouts are available on their respective data sheets.</p>"},{"location":"X16%20Reference%20-%2014%20-%20Hardware/#disclaimer","title":"Disclaimer","text":"<p>The instructions and information in this document are the best available information at the time of writing. This information is subject to change, and no warranty is implied. We are not liable for damage or injury caused by use or misuse of this information, including damage caused by inaccurate information. Interfacing and modifying your Commander X16 is done solely at your own risk.</p> <p>If you attempt to upgrade your firmware and the process fails, one of our community members may be able to help. Please visit the forums or the Discord community, both of which can be reached through https://commanderx16.com.</p>"},{"location":"X16%20Reference%20-%2014%20-%20Hardware/#snes-ports","title":"SNES Ports","text":"<p>The computer contains two SNES style ports and will work with Super Nintendo compatible game pads. An on-board pin header is accessible to connect two additional SNES ports.</p> <p></p> Pin # Description Wire Color 1 +5v White 2 Data Clock Yellow/Red 3 Data Latch Orange 4 Serial Data Red/Yellow 5 N/C - 6 N/C - 7 Ground Brown <p>The Data Clock and Data Latch are generated by the computer and are shared across all SNES ports. The Serial Data line is unique per controller.</p> <p>Thanks to Console Mods Wiki</p>"},{"location":"X16%20Reference%20-%2014%20-%20Hardware/#iec-port","title":"IEC Port","text":"<p>The IEC port is a female 6 pin DIN 45322 connector. The pinout and specifications are the same as the Commodore 128 computer, with the required lines for Fast IEC, as used by the 1571 and 1581 diskette drives. 1541 drives are also compatible, using standard IEC mode at 400-600 bytes/sec.</p> <p></p> Pin Description Signal Direction Remark 1 SERIAL SRQ IN Serial Service Request In, at the C128 \"Fast Serial Clock\" 2 GND - Ground, signal ground (0V) 3 SERIAL ATN OUT Attention, for the selection of a device at beginning/end of a transmission 4 SERIAL CLK IN/OUT Clock (for data transmission) 5 SERIAL DATA IN/OUT Data 6 SERIAL RESET OUT(/IN) Reset <p>The IEC protocol is beyond the scope of this document. Please see Wikipedia for more information.</p>"},{"location":"X16%20Reference%20-%2014%20-%20Hardware/#ps2-keyboard-and-mouse","title":"PS/2 Keyboard and Mouse","text":"Pin Name Description 1 +DATA Data 2 NC Not connected 3 GND Ground 4 Vcc +5 VDC 5 +CLK Clock 6 NC Not Connected"},{"location":"X16%20Reference%20-%2014%20-%20Hardware/#expansion-cards-cartridges","title":"Expansion Cards / Cartridges","text":"<p>The expansion slots can be used for I/O modules and RAM/ROM cartridges and expose the full CPU address and data bus, plus the ROM bank select lines, stereo audio, and 5 IO select lines.</p> <p>The expansion/cartridge port is a 60-pin edge connector with 2.54mm pitch. Pin 1 is in the rear-left corner.</p> Desc Pin Pin Desc -12V 1 [ ] 2 +12V GND 3 [ ] 4 +5V AUDIO_L 5 [ ] 6 GND AUDIO_R 7 [ ] 8 ROMB7 IO3 9 [ ] 10 ROMB0 IO4 11 [ ] 12 ROMB1 IO7 13 [ ] 14 ROMB6 IO5 15 [ ] 16 ROMB2 IO6 17 [ ] 18 ROMB5 RESB 19 [ ] 20 ROMB3 RDY 21 [ ] 22 ROMB4 IRQB 23 [ ] 24 PHI2 BE 25 [ ] 26 RWB NMIB 27 [ ] 28 MLB SYNC 29 [ ] 30 D0 A0 31 [ ] 32 D1 A1 33 [ ] 34 D2 A2 35 [ ] 36 D3 A3 37 [ ] 38 D4 A4 39 [ ] 40 D5 A5 41 [ ] 42 D6 A6 43 [ ] 44 D7 A7 45 [ ] 46 A15 A8 47 [ ] 48 A14 A9 49 [ ] 50 A13 A10 51 [ ] 52 A12 A11 53 [ ] 54 SDA GND 55 [ ] 56 SCL +5V 57 [ ] 58 GND +12V 59 [ ] 60 -12V <p>To simplify address decoding, pins IO3-IO7 are active for specific, 32-byte memory mapped IO (MMIO) address ranges.</p> Address Usage Speed $9F60-$9F7F Expansion Card Memory Mapped IO3 8 MHz $9F80-$9F9F Expansion Card Memory Mapped IO4 8 MHz $9FA0-$9FBF Expansion Card Memory Mapped IO5 2 MHz $9FC0-$9FDF Expansion Card Memory Mapped IO6 2 MHz $9FE0-$9FFF Cartidge/Expansion Memory Mapped IO7 2 MHz <p>Expansion cards can use the IO3-IO6 lines as enable lines to provide their IO address range (s), or decode the address from the address bus directly. To prevent conflicts with other devices, expansion boards should allow the user to select their desired I/O bank with jumpers or DIP switches. IO7 is given priority to external cartridges that use MMIO and should be only used by an expansion card if there are no other MMIO ranges available. Doing so may cause a bus conflict with cartridges that make us of MMIO (such as those with expansion hardware). See below for more information on cartridges.</p> <p>ROMB0-ROMB7 are connected to the ROM bank latch at address <code>$01</code>. Values 0-31 (<code>$00</code>-<code>$1F</code>) address the on-board ROM chips, and 32-255 are intended for expansion ROM or RAM chips (typically used by cartridges, see below). This allows for a total of 3.5MB of address space in the <code>$C000-$FFFF</code> address range.</p> <p>SCL and SDA pins are shared with the i2c connector on J9 and can be used to access i2c peripherals on cartridges or expansion cards.</p> <p>AUDIO_L and AUDIO_R are routed to J10, the audio option header.</p> <p>The other pins are connected to the system bus and directly to the 65C02 processor.</p>"},{"location":"X16%20Reference%20-%2014%20-%20Hardware/#cartridges","title":"Cartridges","text":"<p>Cartridges are essentially an expansion card housed in an external enclosure. Typically they are used for applications (e.g. games) with the X16 being able to boot directly from a cartridge at power on. They contain banked ROM and/or RAM and an optional I2C EEPROM (for storing game save states).</p> <p>They can also function as an expansion card which means they can also use MMIO. Similarly an internal expansion card could contain RAM/ROM as well.</p> <p>Because of this, while develoeprs are free to use the hardware as they please, to avoid conflcits, the banked ROM/RAM space is suggested to be used only by cartridges and cartridges should avoid using MMIO IO3-IO6. Instead, IO7 should be the default option for cartridges and the last option for expansion cards (only used if there are no other IO ranges available).</p> <p>This helps avoid bus conflicts and an otherwise bad user experience given a cartridge should be simple to use from the standpoint of the user (\"insert game -&gt; play game\").</p> <p>These are soft guidelines. There is nothing physically preventing an expansion card from using banked ROM/RAM or a cartridge using any of the MMIO addresses. Doing so risks conflicts and compatibility issues.</p> <p>Cartridges with additional hardware would be similar to expansion chips found on some NES and SNES cartridges (think VRC6, Super FX, etc.) and could be used for really anything, such as having a MIDI input for a cartridge that is meant as a music maker; some sort of hardware accelerator FPGA; network support, etc.</p> <p>For more information about the memory map visit Chapter 8: Memory Map.</p>"},{"location":"X16%20Reference%20-%2014%20-%20Hardware/#booting-from-cartridges","title":"Booting from Cartridges","text":"<p>After the X16 finishes it's hardware initialization, the kernel checks bank 32 for the signature \"CX16\" at <code>$C000</code>. If found, it then jumps to <code>$C004</code> and leaves interrupts disabled.</p>"},{"location":"X16%20Reference%20-%2014%20-%20Hardware/#atx-power-supply","title":"ATX Power Supply","text":"<p>The Commander X16 has a socket for an industry standard 24-pin ATX power supply connector. Either a 24-pin or 20-pin PSU connector can be plugged in, though only the pins for the older 20-pin standard are used by the computer. You don't need an expensive power supply, but it must supply the -12v rail. Not all do, so check your unit to make sure. If you can't tell from the label, you can check Pin 12 and COM. If the clip side is facing away from you, pin 14 will be the second pin on the left on the clip side. For a 20-pin cable, -12v is on pin 12, but at the same relative position \u2014 the second pin on the left on the clip side.</p> 24-pin ATX power connector, cable end <p>By CalvinTheMan - Own work, CC BY-SA 4.0, https://commons.wikimedia.org/w/index.php?curid=50881708</p> <p>The Commander X16 does not use the 4-pin CPU power, GPU power, 4-pin drive power, or SATA power connectors.</p> <p>To save space, when running a bare motherboard, we recommend a \"Pico PSU\" power supply, which derives all of the necessary power lines from a single 12V source.</p>"},{"location":"X16%20Reference%20-%2014%20-%20Hardware/#j1-rom-write-protect","title":"J1 ROM Write Protect","text":"<p>Remove J1 to write protect system ROM. With J1 installed, users can program the system ROM using an appropriate ROM flash program.</p>"},{"location":"X16%20Reference%20-%2014%20-%20Hardware/#j2-nmi","title":"J2 NMI","text":"<p>Connect a button here to generate an Non Maskable Interrupt (NMI) on the CPU. This will execute a BASIC warm start, which will stop any existing program, clear the screen, and print the READY prompt.</p>"},{"location":"X16%20Reference%20-%2014%20-%20Hardware/#j3-unknown","title":"J3 (Unknown)","text":"<p>Connect J8 for LPT Compat. (TODO: Is this the Centronics parallel port mode Lorin hinted at early on?)</p>"},{"location":"X16%20Reference%20-%2014%20-%20Hardware/#j4-extra-65c22-pins","title":"J4 Extra 65C22 Pins","text":"Desc Pin Pin Desc CA1 1 . . 2 CA2 PB0 3 . . 4 PB1 PB2 5 . . 6 CB2 <p>These pins are connected to VIA 1 at $9F00-$9F0F.</p>"},{"location":"X16%20Reference%20-%2014%20-%20Hardware/#j5-program-microcontroller","title":"J5 Program Microcontroller","text":"<p>Remove jumpers from J5 to program microcontroller.</p>"},{"location":"X16%20Reference%20-%2014%20-%20Hardware/#j6-system-speed","title":"J6 System Speed","text":"Pin Desc 1 - 2 8 MHz 3 - 4 4 MHz 5 - 6 2 MHz"},{"location":"X16%20Reference%20-%2014%20-%20Hardware/#j7-snes-34","title":"J7 SNES 3/4","text":"Desc Pin Pin Desc CLC 1 . . 2 VCC LATCH 3 . . 4 DAT4 DAT3 5 . . 6 GND <p>These pins will allow for two additional SNES controllers, for a total of four controllers on the system.</p>"},{"location":"X16%20Reference%20-%2014%20-%20Hardware/#j8-front-panel","title":"J8 Front Panel","text":"Desc Pin Pin Desc HDD LED+ 1 . . 2 POW LED + HDD LED- 3 . . 4 POW LED - RESET BUT 5 . . 6 POW BUT RESET BUT 7 . . 7 POW BUT +5VDC 9 . . 10 NC <p>This pinout is compatible with newer ATX style motherboards. AT motherboards and older ATX cases may still have a 3-pin power LED connector (with a blank pin in the middle.) You will need to move the + (red) wire on the power LED connector to the center pin, if this is the case. Or you can use two Male-Female breadboard cables to jumper the header to your power LED connector.</p> <p>There is no on-board speaker header. Instead, all audio is routed to the rear panel headphone jack via the Audio Option header.</p>"},{"location":"X16%20Reference%20-%2014%20-%20Hardware/#j9-i2csmc-header","title":"J9 I2C/SMC Header","text":"<p>There are two different layouts for the SMC header. The first layout appears to be the curretnt (PRxxxxx) boards:</p> Desc Pin Pin Desc SMC MOSI/I2C SDA 1 . . 2 +5V RTC MFP 3 . . 4 SMC TX SMC Reset 5 . . 6 SMC RX SMC SCK/I2C SCL 7 . . 8 GND 5VSB 9 . . 10 GND <p>This is the layout on the DEVxxxxx boards:</p> Desc Pin Pin Desc SMC MOSI/I2C SDA 1 . . 2 +5VSB RTC MFP 3 . . 4 SMC TX SMC Reset 5 . . 6 SMC RX SMC SCK/I2C SCL 7 . . 8 GND MISO 9 . . 10 GND"},{"location":"X16%20Reference%20-%2014%20-%20Hardware/#j10-audio-option","title":"J10 Audio Option","text":"Desc Pin Pin Desc SDA 1 . . 2 RESB SCL 3 . . 4 VCC 5 . . 6 +12V 7 . . 8 -12V 9 . . 10 VERA_L 11 . . 12 BUS_L 13 . . 14 VERA_R 15 . . 16 BUS_R 17 . . 18 YM_L 19 . . 20 OUT_L 21 . . 22 YM_R 23 . . 24 OUT_R <p>5,6,9,10,13,14,17,18,21,22 - GND</p> <p>Next to the audio header is a set of jumper pads, JP1-JP6. Cutting these traces allows you to extract isolated audio from each of the system devices or build a mixer to adjust the relative balance of the audio devices.</p> <p>In order to avoid ground loop and power supply noise, we recommend installing a ground loop isolator when using an external mixer. 2 or 3 isolators will be required (one for each stereo pair.)  (TODO: measure noise and test with pro audio gear.)</p>"},{"location":"X16%20Reference%20-%2014%20-%20Hardware/#j12-user-port","title":"J12 User Port","text":"Desc Pin Pin Desc PB0 1 . . 2 PB4 PA0 3 . . 4 PB5 PA1 5 . . 6 PB6/CB1 PA2 7 . . 8 PB7/CB2 PA3 9 . . 10 GND PA4 11 . . 12 GND PA5 13 . . 14 GND PA6 15 . . 16 GND PA7 17 . . 18 GND CA1 19 . . 20 GND PB1 21 . . 22 GND PB2 23 . . 24 GND PB3/CA2 25 . . 16 VCC <p>User port is connected to VIA 2 at address $9F10-$9F1F. This can be used for serial or parallel port I/O. Commander X16 does not have support for a serial port device in the KERNAL.</p>"},{"location":"X16%20Reference%20-%2014%20-%20Hardware/#vera-video-header","title":"VERA Video Header","text":"Desc Pin Pin Desc VCC 1 . . 2 GND D7 3 . . 4 D6 D5 5 . . 6 D4 D3 7 . . 8 D2 D1 9 . . 10 D0 /IO1 11 . . 12 RESB /MEMWE 13 . . 14 IRQB A4 15 . . 16 /MEMOE A2 17 . . 18 A3 A0 19 . . 20 A1 GND 21 . . 22 GND VERA_L 23 . . 24 VERA_R <p>VERA is connected to I/O ports at $9F20-$9F3F. See Chapter 9: VERA Programmer's Reference for details.</p>"},{"location":"X16%20Reference%20-%2014%20-%20Hardware/#vga-connector","title":"VGA Connector","text":"Pin Desc 1 RED 2 GREEN 3 BLUE 4 5 GND 6 RED_RTN 7 GREEN_RTN 8 BLUE_RTN 9 10 GND 11 12 13 HSync 14 VSync 15 <p>The VGA connector is a female DE-15 jack.</p> <p>The video resolution is 640x480 59.5FPS progressive scan, RGB color, and separated H/V sync.</p> <p>In interlace mode, both horizontal and vertical sync pulses will appear on the HSync pin. (TODO: Test with OSSC).</p> <p>VERA does not use the ID/DDC lines.</p>"},{"location":"X16%20Reference%20-%2014%20-%20Hardware/#composite-connector","title":"Composite Connector","text":"<p>The Composite video is a standard RCA connector. Center pin carries signal. Shield is signal ground.</p> <p>The signal is NTSC Composite baseband video.</p> <p>The video is 480 lines 59.97Hz interlaced. Composite is not available when VGA is running at 59.5Hz progressive scan.</p>"},{"location":"X16%20Reference%20-%2014%20-%20Hardware/#s-video-connector","title":"S-Video Connector","text":"Pin Desc 1 GND (Y) 2 GND (C) 3 Y Intensity (Luminance) 4 C Color (Chrominance) <p>The connector is a 4-pin Mini-DIN connector. While the same size as a PS/2 connector, the PS/2 connector has a plastic key at the bottom. Do not attempt to plug a keyboard or mouse into the S-Video port, or bent pins will occur.</p> <p>The signal is NTSC baseband Y/C separated video. S-Video provides better resolution than composite, since the color and intensity are provided on separate pins. you can use a splitter cable to separate the Y and C signals to drive a Commodore 1702 or compatible monitor.</p> <p>The video is 480 lines 59.97Hz interlaced. Composite is not available when VGA is running at 59.5Hz progressive scan.</p>"},{"location":"X16%20Reference%20-%2014%20-%20Hardware/#j2-vera-programming-interface","title":"J2 VERA Programming Interface","text":"Pin Desc 1 +5V 2 FPGA_CDONE 3 FPGA_CRESET_B 4 SPI_MISO 5 SPI_MOSI 6 SPI_SCK 7 SPI_SSEL_N 8 GND"},{"location":"X16%20Reference%20-%2014%20-%20Hardware/#vera-j7-remote-sd-card-option","title":"VERA J7 Remote SD Card Option","text":"Pin Desc 1 CS 2 SCK 3 MOSI 4 MISO 5 +5V 6 GND <p>This requires an EEPROM programmer and an interface board to program. See Chapter 15 for the programming adapter and instructions.</p>"},{"location":"X16%20Reference%20-%2015%20-%20Upgrade%20Guide/","title":"15: Upgrade Guide","text":"<p>This chapter provides tips for running upgrades on the various programmable chips.</p> <p>WARNING: flashing any of these components has a risk of leading to an unbootable system. At the current time, doing hardware flash updates requires skill and knowledge beyond that of an ordinary end user and is not recommended without guidance from the community on the Commander X16 Discord.</p> <p>Under the headings of each component is a matrix which indicates which software tools can be used to perform the flash of that component, depending on which flashing hardware you have access to and the operating system of the computer you have the device connected to. Some components of the Commander X16 can be self-flashed, but the risk of a failed flash rendering your X16 unbootable is high, in which case an external programmer must be used to flash the component and thus \"unbrick\" the system.</p>"},{"location":"X16%20Reference%20-%2015%20-%20Upgrade%20Guide/#flashable-components","title":"Flashable components","text":"<ul> <li>System ROM</li> <li>SMC (PS/2 and Power controller)</li> <li>VERA</li> </ul>"},{"location":"X16%20Reference%20-%2015%20-%20Upgrade%20Guide/#system-rom","title":"System ROM","text":"<p>Official community system ROMs will be posted as releases at X16Community/x16-emulator inside the distribution for the Emulator.</p> <p>TODO: link to instructions for each solution in the matrix</p> \u2193 Hardware / OS \u2192 Windows Linux Mac OS Commander X16 Commander X16 - - - x16-flash XGecu TL866II+ Xgpro minipro minipro - XGecu TL866-3G / T48 Xgpro - - -"},{"location":"X16%20Reference%20-%2015%20-%20Upgrade%20Guide/#smc","title":"SMC","text":"<p>Official community SMC ROMs will be posted as releases at X16Community/x16-smc.</p> <p>TODO: link to instructions for each solution in the matrix</p> \u2193 Hardware / OS \u2192 Windows Linux Mac OS Commander X16 Commander X16 - - - - USBtinyISP arduino arduino arduino - XGecu TL866II+ Xgpro - - - XGecu TL866-3G / T48 Xgpro - - -"},{"location":"X16%20Reference%20-%2015%20-%20Upgrade%20Guide/#vera","title":"VERA","text":"<p>TODO: link to instructions for each solution in the matrix</p> <p>Official community VERA bitstreams will be posted as releases at X16Community/vera-module</p> \u2193 Hardware / OS \u2192 Windows Linux Mac OS Commander X16 Commander X16 - - - flashvera XGecu TL866II+ Xgpro minipro minipro - XGecu TL866-3G / T48 Xgpro - - -"},{"location":"X16%20Reference%20-%20Appendix%20A%20-%20Sound/","title":"Appendix A: Sound","text":""},{"location":"X16%20Reference%20-%20Appendix%20A%20-%20Sound/#fm-instrument-patch-presets","title":"FM instrument patch presets","text":"# Instrument Name # Instrument Name 0 Acoustic Grand Piano 64 Soprano Sax \u2020 1 Bright Acoustic Piano 65 Alto Sax \u2020 2 Electric Grand Piano 66 Tenor Sax \u2020 3 Honky-tonk Piano 67 Baritone Sax 4 Electric Piano 1 68 Oboe \u2020 5 Electric Piano 2 69 English Horn \u2020 6 Harpsichord 70 Bassoon 7 Clavinet 71 Clarinet \u2020 8 Celesta 72 Piccolo 9 Glockenspiel 73 Flute \u2020 10 Music Box 74 Recorder 11 Vibraphone \u2020 75 Pan Flute 12 Marimba 76 Blown Bottle 13 Xylophone 77 Shakuhachi 14 Tubular Bells 78 Whistle \u2020 15 Dulcimer 79 Ocarina 16 Drawbar Organ \u2020 80 Lead 1 (Square) \u2020 17 Percussive Organ \u2020 81 Lead 2 (Sawtooth) \u2020 18 Rock Organ \u2020 82 Lead 3 (Triangle) \u2020 19 Church Organ 83 Lead 4 (Chiff+Sine) \u2020 20 Reed Organ 84 Lead 5 (Charang) \u2020 21 Accordion 85 Lead 6 (Voice) \u2020 22 Harmonica 86 Lead 7 (Fifths) \u2020 23 Bandoneon 87 Lead 8 (Solo) \u2020 24 Acoustic Guitar (Nylon) 88 Pad 1 (Fantasia) \u2020 25 Acoustic Guitar (Steel) 89 Pad 2 (Warm) \u2020 26 Electric Guitar (Jazz) 90 Pad 3 (Polysynth) \u2020 27 Electric Guitar (Clean) 91 Pad 4 (Choir) \u2020 28 Electric Guitar (Muted) 92 Pad 5 (Bowed) 29 Electric Guitar (Overdriven) 93 Pad 6 (Metallic) 30 Electric Guitar (Distortion) 94 Pad 7 (Halo) \u2020 31 Electric Guitar (Harmonics) 95 Pad 8 (Sweep) \u2020 32 Acoustic Bass 96 FX 1 (Raindrop) 33 Electric Bass (finger) 97 FX 2 (Soundtrack) \u2020 34 Electric Bass (picked) 98 FX 3 (Crystal) 35 Fretless Bass 99 FX 4 (Atmosphere) \u2020 36 Slap Bass 1 100 FX 5 (Brightness) \u2020 37 Slap Bass 2 101 FX 6 (Goblin) 38 Synth Bass 1 102 FX 7 (Echo) 39 Synth Bass 2 103 FX 8 (Sci-Fi) \u2020 40 Violin \u2020 104 Sitar 41 Viola \u2020 105 Banjo 42 Cello \u2020 106 Shamisen 43 Contrabass \u2020 107 Koto 44 Tremolo Strings \u2020 108 Kalimba 45 Pizzicato Strings 109 Bagpipe 46 Orchestral Harp 110 Fiddle \u2020 47 Timpani 111 Shanai \u2020 48 String Ensemble 1 \u2020 112 Tinkle Bell 49 String Ensemble 2 \u2020 113 Agogo 50 Synth Strings 1 \u2020 114 Steel Drum 51 Synth Strings 2 \u2020 115 Woodblock 52 Choir Aahs \u2020 116 Taiko Drum 53 Voice Doos 117 Melodic Tom 54 Synth Voice \u2020 118 Synth Drum 55 Orchestra Hit 119 Reverse Cymbal 56 Trumpet \u2020 120 Fret Noise 57 Trombone 121 Breath Noise 58 Tuba 122 Seashore \u2020 59 Muted Trumpet \u2020 123 Bird Tweet 60 French Horn 124 Telephone Ring 61 Brass Section 125 Helicopter 62 Synth Brass 1 126 Applause \u2020 63 Synth Brass 2 127 Gunshot <p>\u2020 Instrument is affected by the LFO, giving it a vibrato or tremolo effect.</p>"},{"location":"X16%20Reference%20-%20Appendix%20A%20-%20Sound/#fm-extended-instrument-patch-presets","title":"FM extended instrument patch presets","text":"<p>These presets exist mainly to support playback of drum sounds, and many of them only work correctly or sound musical at certain pitches or within a small range of pitches.</p> # Instrument Name # Instrument Name 128 Silent 146 Vibraslap 129 Snare Roll 147 Bongo 130 Snap 148 Maracas 131 High Q 149 Short Whistle 132 Scratch 150 Long Whistle 133 Square Click 151 Short Guiro 134 Kick 152 Long Guiro 135 Rim 153 Mute Cuica 136 Snare 154 Open Cuica 137 Clap 155 Mute Triangle 138 Tom 156 Open Triangle 139 Closed Hi-Hat 157 Jingle Bell 140 Pedal Hi-Hat 158 Bell Tree 141 Open Hi-Hat 159 Mute Surdo 142 Crash 160 Pure Sine 143 Ride Cymbal 161 Timbale 144 Splash Cymbal 162 Open Surdo 145 Tambourine"},{"location":"X16%20Reference%20-%20Appendix%20A%20-%20Sound/#drum-presets","title":"Drum presets","text":"<p>These are the percussion instrument mappings for the drum number argument of the <code>ym_playdrum</code> and <code>ym_setdrum</code> API calls, and the <code>FMDRUM</code> BASIC command.</p> # Instrument Name # Instrument Name 56 Cowbell 25 Snare Roll 57 Crash Cymbal 2 26 Finger Snap 58 Vibraslap 27 High Q 59 Ride Cymbal 2 28 Slap 60 High Bongo 29 Scratch Pull 61 Low Bongo 30 Scratch Push 62 Mute High Conga 31 Sticks 63 Open High Conga 32 Square Click 64 Low Conga 33 Metronome Bell 65 High Timbale 34 Metronome Click 66 Low Timbale 35 Acoustic Bass Drum 67 High Agogo 36 Electric Bass Drum 68 Low Agogo 37 Side Stick 69 Cabasa 38 Acoustic Snare 70 Maracas 39 Hand Clap 71 Short Whistle 40 Electric Snare 72 Long Whistle 41 Low Floor Tom 73 Short Guiro 42 Closed Hi-Hat 74 Long Guiro 43 High Floor Tom 75 Claves 44 Pedal Hi-Hat 76 High Woodblock 45 Low Tom 77 Low Woodblock 46 Open Hi-Hat 78 Mute Cuica 47 Low-Mid Tom 79 Open Cuica 48 High-Mid Tom 80 Mute Triangle 49 Crash Cymbal 1 81 Open Triangle 50 High Tom 82 Shaker 51 Ride Cymbal 1 83 Jingle Bell 52 Chinese Cymbal 84 Belltree 53 Ride Bell 85 Castanets 54 Tambourine 86 Mute Surdo 55 Splash Cymbal 87 Open Surdo"},{"location":"X16%20Reference%20-%20Appendix%20A%20-%20Sound/#basic-fmplay-and-psgplay-string-macros","title":"BASIC FMPLAY and PSGPLAY string macros","text":""},{"location":"X16%20Reference%20-%20Appendix%20A%20-%20Sound/#overview","title":"Overview","text":"<p>The play commands use a string of tokens to define sequences of notes to be played on a single voice of the corresponding sound chip. Tokens cause various effects to happen, such as triggering notes, changing the playback speed, etc. In order to minimize the amount of text required to specify a sequence of sound, the player maintains an internal state for most note parameters.</p>"},{"location":"X16%20Reference%20-%20Appendix%20A%20-%20Sound/#stateful-player-behavior","title":"Stateful Player Behavior:","text":"<p>Playback parameters such as tempo, octave, volume, note duration, etc do not need to be specified for each note. These states are global between all voices of both the FM and PSG sound chips. The player maintains parameter state during and after playback. For instance, setting the octave to 5 in an <code>FMPLAY</code> command will result in subsequent <code>FMPLAY</code> and <code>PSGPLAY</code> statements beginning with the octave set to 5.</p> <p>The player state is reset to default values whenever <code>FMINIT</code> or <code>PSGINIT</code> are used.</p> Parameter Default Equivalent Token Tempo 120 T120 Octave 4 O4 Length 4 L4 Note Spacing 1 S1"},{"location":"X16%20Reference%20-%20Appendix%20A%20-%20Sound/#using-tokens","title":"Using Tokens:","text":"<p>The valid tokens are: <code>A-G,I,K,L,O,P,R,S,T,V,&lt;,&gt;</code>.</p> <p>Each token may be followed by optional modifiers such as numbers or symbols. Options to a token must be given in the order they are expected, and must have no spacing between them. Tokens may have spaces between them as desired. Any unknown characters are ignored.</p> <p>Example: <pre><code>FMPLAY 0,\"L4\"      : REM DEFAULT LENGTH = QUARTER NOTE\nFMPLAY 0,\"A2. C+.\" : REM VALID\nFMPLAY 0,\"A.2 C.+\" : REM INVALID\n</code></pre> The valid command plays A as a dotted half, followed by C\u266f as a dotted quarter.</p> <p>The invalid example would play A as a dotted quarter (not half) because length must come before dots. Next, it would ignore the 2 as garbage. Then it would play natural C (not sharp) as a dotted quarter. Finally, it would ignore the + as garbage, because sharp/flat must precede length and dot.</p>"},{"location":"X16%20Reference%20-%20Appendix%20A%20-%20Sound/#token-definitions","title":"Token definitions:","text":""},{"location":"X16%20Reference%20-%20Appendix%20A%20-%20Sound/#musical-notes","title":"Musical notes","text":"<ul> <li>Synopsis: Play a musical note, optionally setting the length.</li> <li>Syntax: <code>&lt;A-G&gt;[&lt;+/-&gt;][&lt;length&gt;][.]</code></li> </ul> <p>Example: <pre><code>FMPLAY 0,\"A+2A4C.G-8.\"\n</code></pre> On the YM2151 using channel 0, plays in the current octave an A\u266f half note<sup>?</sup> followed by an A quarter note<sup>?</sup>, followed by C dotted quarter note, followed by G\u266d dotted eighth note<sup>?</sup>.</p> <p>Lengths and dots after the note name or rest set the length just for the current note or rest.  To set the default length for subsequent notes and rests, use the <code>L</code> macro.</p>"},{"location":"X16%20Reference%20-%20Appendix%20A%20-%20Sound/#rests","title":"Rests","text":"<ul> <li>Synopsis: Wait for a period of silence equal to the length of a note, optionally setting the length.</li> <li>Syntax: <code>R[&lt;length&gt;][.]</code></li> </ul> <p>Example: <pre><code>PSGPLAY 0,\"CR2DRE\"\n</code></pre> On the VERA PSG using voice 0, plays in the current octave a C quarter note, followed by a half rest (silence), followed by a quarter D, followed by a quarter rest (silence), and finally a quarter E.</p> <p>The numeral <code>2</code> in <code>R2</code> sets the length for the <code>R</code> itself but does not alter the default note length (assumed as 4 - quarter notes in this example).</p>"},{"location":"X16%20Reference%20-%20Appendix%20A%20-%20Sound/#note-length","title":"Note Length","text":"<ul> <li>Synopsis: Set the default length for notes and rests that follow</li> <li>Syntax: <code>L[&lt;length&gt;][.]</code></li> </ul> <p>Example values: * L4 = quarter note (crotchet) * L16 = sixteenth note (semiquaver) * L12 = 8th note triplets (quaver triplet) * L4. = dotted quarter note (1.5x the length) * L4.. = double-dotted quarter note (1.75x the length)</p> <p>Example program: <pre><code>10 FMPLAY 0,\"L4\"\n20 FOR I=1 TO 2\n30 FMPLAY 0,\"CDECL8\"\n40 NEXT\n</code></pre> On the YM2151 using channel 0, this program, when RUN, plays in the current octave the sequence C D E C first as quarter notes, then as eighth notes the second time around.</p>"},{"location":"X16%20Reference%20-%20Appendix%20A%20-%20Sound/#articulation","title":"Articulation","text":"<ul> <li>Synopsis: Set the spacing between notes, from legato to extreme staccato</li> <li>Syntax: <code>S&lt;0-7&gt;</code></li> </ul> <p><code>S0</code> indicates legato. For FMPLAY, this also means that notes after the first in a phrase don't implicitly retrigger.</p> <p><code>S1</code> is the default value, which plays a note for 7/8 of the duration of the note, and releases the note for the remaining 1/8 of the note's duration.</p> <p>You can think of <code>S</code> is, out of 8, how much space is put between the notes.</p> <p>Example: <pre><code>FMPLAY 0,\"L4S1CDES0CDES4CDE\"\n</code></pre> On the YM2151 using channel 0, plays in the current octave the sequence C D E three times, first with normal articulation, next with legato (notes all run together and without retriggering), and finally with a moderate staccato.</p>"},{"location":"X16%20Reference%20-%20Appendix%20A%20-%20Sound/#explicit-retrigger","title":"Explicit retrigger","text":"<ul> <li>Synopsis: on the YM2151, when using <code>S0</code> legato, retrigger on the next note.</li> <li>Syntax: <code>K</code></li> </ul> <p>Example: <pre><code>FMPLAY 0,\"S0CDEKFGA\"\n</code></pre> On the YM2151 using channel 0, plays in the current octave the sequence C D E using legato, only triggering on the first note, then the sequence F G A the same way. The note F is triggered without needing to release the previous note early.</p>"},{"location":"X16%20Reference%20-%20Appendix%20A%20-%20Sound/#octave","title":"Octave","text":"<ul> <li>Synopsis: Explictly set the octave number for notes that follow</li> <li>Syntax: <code>O&lt;0-7&gt;</code></li> </ul> <p>Example: <pre><code>PSGPLAY 0,\"O4AO2AO6CDE\"\n</code></pre> On the VERA PSG using voice 0, changes to octave 4 and plays A (440Hz), then switches to octave 2, and plays A (110Hz), then switches to octave 6 and plays the sequence C D E</p>"},{"location":"X16%20Reference%20-%20Appendix%20A%20-%20Sound/#octave-up","title":"Octave Up","text":"<ul> <li>Synopsis: Increases the octave by 1</li> <li>Syntax: <code>&gt;</code></li> </ul> <p>If the octave would go above 7, this macro has no effect.</p> <p>Example: <pre><code>PSGPLAY 0,\"O4AB&gt;C+DE\"\n</code></pre> On the VERA PSG using voice 0, changes to octave 4 and plays the first five notes of the A major scale by switching to octave 5 starting at the C\u266f</p>"},{"location":"X16%20Reference%20-%20Appendix%20A%20-%20Sound/#octave-down","title":"Octave Down","text":"<ul> <li>Synopsis: Decreases the octave by 1</li> <li>Syntax: <code>&lt;</code></li> </ul> <p>If the octave would go below 0, this macro has no effect. Example: <pre><code>PSGPLAY 0,\"O5GF+EDC&lt;BAG\"\n</code></pre> On the VERA PSG using voice 0, changes to octave 5 and plays the G major scale from the top down by switching to octave 4 starting at the B</p>"},{"location":"X16%20Reference%20-%20Appendix%20A%20-%20Sound/#tempo","title":"Tempo","text":"<ul> <li>Synopsis: Sets the BPM, the number of quarter notes per minute</li> <li>Syntax: <code>T&lt;1-255&gt;</code></li> </ul> <p>High tempo values and short notes tend to have inaccurate lengths due to quantization error. Delays within a string do keep track of fractional frames so the overall playback length should be relatively consistent.</p> <p>Low tempo values that cause delays (lengths) to exceed 255 frames will also end up being inaccurate. For very long notes, it may be better to use legato to string several together.</p> <p>Example: <pre><code>10 FMPLAY 0,\"T120C4CGGAAGR\"\n20 FMPLAY 0,\"T180C4CGGAAGR\"\n</code></pre> On the YM2151 using channel 0, plays in the current octave the first 7 notes of Twinkle Twinkle Little Star, first at 120 beats per minute, then again 1.5 times as fast at 180 beats per minute.</p>"},{"location":"X16%20Reference%20-%20Appendix%20A%20-%20Sound/#volume","title":"Volume","text":"<ul> <li>Synopsis: Set the channel or voice volume</li> <li>Syntax: <code>V&lt;0-63&gt;</code></li> </ul> <p>This macro mirrors the <code>PSGVOL</code> and <code>FMVOL</code> BASIC commands for setting a channel or voice's volume. 0 is silent, 63 is maximum volume.</p> <p>Example: <pre><code>FMPLAY 0,\"V40ECV45ECV50ECV55ECV60ECV63EC\"\n</code></pre> On the YM2151 using channel 0, starting at a moderate volume, plays the sequence E C, repeatedly, increasing the volume steadily each time.</p>"},{"location":"X16%20Reference%20-%20Appendix%20A%20-%20Sound/#panning","title":"Panning","text":"<ul> <li>Synopsis: Sets the stereo output of a channel or voice to left, right, or both.</li> <li>Syntax: <code>P&lt;1-3&gt;</code></li> </ul> <p>1 = Left 2 = Right 3 = Both  </p> <p>Example: <pre><code>10 FOR I=1 TO 4\n20 PSGPLAY 0,\"P1CP2B+\"\n30 NEXT I\n40 PSGPLAY 0,\"P3C\"\n</code></pre> On the VERA PSG using voice 0, in the current octave, repeatedly plays a C out of the left speaker, then a B\u266f (effectively a C one octave higher) out of the right speaker.  After 4 such loops, it plays a C out of both speakers.</p>"},{"location":"X16%20Reference%20-%20Appendix%20A%20-%20Sound/#instrument-change","title":"Instrument change","text":"<ul> <li>Synopsis: Sets the FM instrument (like FMINST) or PSG waveform (like PSGWAV)</li> <li>Syntax: <code>I&lt;0-255&gt;</code> (0-162 for FM)</li> </ul> <p>Note: This macro is available starting in ROM version R43.</p> <p>Example: <pre><code>10 FMINIT\n20 FMVIB 200,15\n30 FMCHORD 0,\"I11CI11EI11G\"\n</code></pre> This program sets up appropriate vibrato/tremolo and plays a C major chord with the vibraphone patch across FM channels 0, 1, and 2.</p>"},{"location":"X16%20Reference%20-%20Appendix%20B%20-%20VERA%20Recovery/","title":"Appendix B: VERA Firmware Recovery","text":"<p>WARNING: This is a draft that may contain errors or omissions that could damage your hardware.</p>"},{"location":"X16%20Reference%20-%20Appendix%20B%20-%20VERA%20Recovery/#using-a-windows-pc-to-upgrade-or-recover-a-vera","title":"Using a Windows PC to upgrade or recover a VERA","text":"<p>Target Component: VERA Programmer: TL866-3G/T48 Software: Xgpro Host OS: Windows  </p>"},{"location":"X16%20Reference%20-%20Appendix%20B%20-%20VERA%20Recovery/#before-you-start","title":"Before You Start","text":"<p>Before starting, it is recommended to disconnect the Commander X16's PSU's power from the wall socket.  You will need to reconnect power later, but while connecting the programmer to the system, it is safer to disconnect mains power from the power supply. Power is supplied to parts of the main board even when the computer is turned off.use_directory_urls To perform the upgrade, you will need the following: - A TL866-3G/T48 programmer - The Xgpro software - Female-to-female jumper wires</p>"},{"location":"X16%20Reference%20-%20Appendix%20B%20-%20VERA%20Recovery/#programmer-wiring-setup","title":"Programmer Wiring Setup","text":"<p>The VERA 8-pin header should be connected as follows:</p> VERA J2 Pin Connect to 1 (+5V) Not connected 2 (CDONE) Not connected 3 (CRESET_B) VERA, J7 GND pin 4 (SPI_MISO) TL866-3G/T48, ICSP pin 5 (MISO) 5 (SPI_MOSI) TL866-3G/T48, ICSP pin 15 (MOSI) 6 (SPI_SCK) TL866-3G/T48, ICSP pin 7 (SCK) 7 (SPI_SEL_N) TL866-3G/T48, ICSP pin 1 (/CS) 8 (GND) TL866-3G/T48, ICSP pin 16 (GND) <p>Image 1: Vera J2 programming header and J7 header. </p> <p>Image 2: TL866-3G/T48 ICSP header. </p> <p>Image 3: Schematics for connection between the VERA board and the TL866-3G/T48. </p>"},{"location":"X16%20Reference%20-%20Appendix%20B%20-%20VERA%20Recovery/#powering-the-target-component","title":"Powering the Target Component","text":"<p>The VERA board is programmed while it is still mounted in the Commander X16 and  will be powered by the computer's PSU, not by the programmer.</p> <p>Before proceeding with the firmware upgrade, ensure that the wiring is correct.  Then, connect the Commander X16 to the wall socket and press the computer's power  button to ensure that 5V is supplied to the VERA board.</p> <p>Please note that the VERA's FPGA is held in reset because  VERA pin 3 (CRESET_B) is connected to ground. As a result,  you will not see any screen output during the upgrade process.</p>"},{"location":"X16%20Reference%20-%20Appendix%20B%20-%20VERA%20Recovery/#programmer-software-setup","title":"Programmer Software Setup","text":"<p>Open the Xgpro software and configure the following settings:</p> <ul> <li>Select target chip: W25Q16JV</li> <li>Setup interface: Choose ICSP port and uncheck ICSP_VCC_Enable</li> <li>Click on \"ID Check\" to verify the connection<ul> <li>The response value should be EF 40 15</li> <li>If it is not, double-check the wiring before proceeding</li> </ul> </li> </ul> <p></p>"},{"location":"X16%20Reference%20-%20Appendix%20B%20-%20VERA%20Recovery/#updateflash-procedure","title":"Update/Flash Procedure","text":"<p>In the Xgpro software, follow these steps:</p> <ul> <li>Click on \"Load\" to load the firmware into the software buffer</li> <li>After loading the firmware into the software buffer, click on \"Prog.\" to upload the firmware to the VERA board.</li> </ul> <p>Once the update is complete, press the power button to turn off the Commander X16. Then, disconnect the computer from the wall socket. Finally, remove all wires from the VERA pin header.</p> <p>Congratulations! The firmware update for VERA is now complete.</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/","title":"Appendix C: The 65C02 Processor","text":"<p>This is not meant to be a complete manual on the 65C02 processor, though is meant to serve as a convenient quick reference. Much of this information comes from 6502.org and pagetable.com. It is been placed here for convenience though further information can be found at those (and other) sources.</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#overview","title":"Overview","text":"<p>The WDC65C02 CPU is a modern version of the MOS6502 with a few additional instructions and addressing modes and is capable of running at up to 14 MHz. On the Commander X16, it is clocked at 8 MHz.</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#a-note-about-65c816-compatibilty","title":"A note about 65C816 Compatibilty","text":"<p>The Commander X16 may be upgraded at some point to use the WDC 65C816 CPU. The 65C816 is mostly compatible with the 65C02, except for 4 instructions (<code>BBRx</code>, <code>BBSx</code>, <code>RMBx</code>, and <code>SMBx</code>).</p> <p>These instructions may be deprecated in a future release of the emulator, and so we suggest not using these instructions. Some people are already using the 65C816 in their X16 systems, and so using these instructions will cause your programs to malfunction on these computers.</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#instruction-tables","title":"Instruction Tables","text":""},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#instructions-by-number","title":"Instructions By Number","text":"x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 xA xB xC xD xE xF 0x BRK ORA TSB ORA ASL RMB0 PHP ORA ASL TSB ORA ASL BBR0 1x BPL ORA ORA TRB ORA ASL RMB1 CLC ORA INC TRB ORA ASL BBR1 2x JSR AND BIT AND ROL RMB2 PLP AND ROL BIT AND ROL BBR2 3x BMI AND AND BIT AND ROL RMB3 SEC AND DEC BIT AND ROL BBR3 4x RTI EOR EOR LSR RMB4 PHA EOR LSR JMP EOR LSR BBR4 5x BVC EOR EOR EOR LSR RMB5 CLI EOR PHY EOR LSR BBR5 6x RTS ADC STZ ADC ROR RMB6 PLA ADC ROR JMP ADC ROR BBR6 7x BVS ADC ADC STZ ADC ROR RMB7 SEI ADC PLY JMP ADC ROR BBR7 8x BRA STA STY STA STX SMB0 DEY BIT TXA STY STA STX BBS0 9x BCC STA STA STY STA STX SMB1 TYA STA TXS STZ STA STZ BBS1 Ax LDY LDA LDX LDY LDA LDX SMB2 TAY LDA TAX LDY LDA LDX BBS2 Bx BCS LDA LDA LDY LDA LDX SMB3 CLV LDA TSX LDY LDA LDX BBS3 Cx CPY CMP CPY CMP DEC SMB4 INY CMP DEX WAI CPY CMP DEC BBS4 Dx BNE CMP CMP CMP DEC SMB5 CLD CMP PHX STP CMP DEC BBS5 Ex CPX SBC CPX SBC INC SMB6 INX SBC NOP CPX SBC INC BBS6 Fx BEQ SBC SBC SBC INC SMB7 SED SBC PLX SBC INC BBS7"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#instructions-by-name","title":"Instructions By Name","text":"ADC AND ASL BBRx BBSx BCC BCS BEQ BIT BMI BNE BPL BRA BRK BVC BVS CLC CLD CLI CLV CMP CPX CPY DEC DEX DEY EOR INC INX INY JMP JSR LDA LDX LDY LSR NOP ORA PHA PHP PHX PHY PLA PLP PLX PLY RMBx ROL ROR RTI RTS SBC SEC SED SEI SMBx STA STP STX STY STZ TAX TAY TRB TSB TSX TXA TXS TYA WAI"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#instructions-by-category","title":"Instructions By Category","text":"Arithmetic ADC SBC Boolean AND EOR ORA Bit Shift ASL LSR ROL ROR Branch BBRx BBSx Test Bit BIT TRB TSB Branching BCC BCS BEQ BMI BNE BPL BVC BVS BRA Misc BRK NOP STP WAI Flags CLC CLD CLI CLV SEC SED SEI Compare CMP CPX CPY Increment/Decrement DEC DEX DEY INX INY INC Flow JMP JSR RTI RTS Load Data LDA LDX LDY Stack PHA PHP PHX PHY PLA PLP PLX PLY Bit Operations RMBx SMBx Store Data STA STX STY STZ Transfer TAX TXA TAY TYA TSX TXS"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#adc","title":"ADC","text":"<p>Add with Carry</p> <pre><code>SYNTAX       MODE           HEX  LEN  CYCLES  FLAGS    \nADC #$20     Immediate      $69   2     2     NV----ZC \nADC $20      Zero Page      $65   2     3     NV----ZC \nADC $20,X    Zero Page,X    $75   2     4     NV----ZC \nADC $8080    Absolute       $6D   3     4     NV----ZC \nADC $8080,X  Absolute,X     $7D   3     4+    NV----ZC +p\nADC $8080,Y  Absolute,Y     $79   3     4+    NV----ZC +p\nADC ($20,X)  Indirect,X     $61   2     6     NV----ZC \nADC ($20),Y  Indirect,Y     $71   2     5+    NV----ZC +p\nADC ($20)    ZP Indirect    $72   2     5     NV----ZC +c\n</code></pre> <p>Add a number to the Accumulator and stores the result in A.</p> <p>Use the Carry (C) or Overflow (V) flags to determine whether the result was too large for an 8 bit number.</p> <p>If C is set before operation, then 1 will be added to the result.</p> <p>C is set when result is more than 255 ($FF) Z is set when result is zero V is set when signed result is too large. (Goes below -128 or above 127). N is set when result is negative (bit 7=1)  </p> <p>+p: Add 1 cycle if a page boundary is crossed when forming address. +c: New for the 65C02</p> <p>[Opcodes] | [By Name] | [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#and","title":"AND","text":"<p>Logical And</p> <pre><code>SYNTAX       MODE           HEX  LEN  CYCLES  FLAGS    \nAND #$20     Immediate      $29   2     2     N-----Z- \nAND $20      Zero Page      $25   2     3     N-----Z- \nAND $20,X    Zero Page,X    $35   2     4     N-----Z- \nAND $8080    Absolute       $2D   3     4     N-----Z- \nAND $8080,X  Absolute,X     $3D   3     4+    N-----Z- +p\nAND $8080,Y  Absolute,Y     $39   3     4+    N-----Z- +p\nAND ($20,X)  Indirect,X     $21   2     6     N-----Z- \nAND ($20),Y  Indirect,Y     $31   2     5+    N-----Z- +p\nAND ($20)    ZP Indirect    $32   2     5     N-----Z- +c\n</code></pre> <p>Bitwise AND the provided value with the Accumulator.</p> <ul> <li>Sets N (Negative) flag if the bit 7 of the result is 1, and otherewise clears it.</li> <li>Sets Z (Zero) is the result is zero, and otherwise clears it  </li> </ul> <p><code>AND #$FF</code> will leave A unaffected (but still set the flags). <code>AND #$00</code> will clear A. <code>AND #$0F</code> will clear the high nibble of A, leaving a value of $00 to $0F in A.  </p> M A Result 0 0 0 0 1 0 1 0 0 1 1 1 <p>Other Boolean Instructions: EOR exclusive-OR ORA bitwise OR  </p> <p>+p: Add 1 cycle if a page boundary is crossed when forming address. +c: New for the 65C02</p> <p>[Opcodes] | [By Name] | [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#asl","title":"ASL","text":"<p>Arithmetic Shift Left</p> <pre><code>SYNTAX       MODE           HEX  LEN  CYCLES  FLAGS    \nASL A        Accumulator    $0A   1     2     N-----ZC \nASL $20      Zero Page      $06   2     5     N-----ZC\nASL $20,X    Zero Page,X    $16   2     6     N-----ZC\nASL $8080    Absolute       $0E   3     6     N-----ZC\nASL $8080,X  Absolute,X     $1E   3     6+    N-----ZC +p\n</code></pre> <p>Shifts all bits to the left by one position, moving 0 into the low bit.</p> <p>0 is shifted into bit 0. Bit 7 is shifted to Carry.  </p> <p>Similar instructions: LSR is the opposite instruction and shifts to the right. ROL shifts left through Carry.</p> <p>+p: Add 1 cycle if a page boundary is crossed when forming address.  </p> <p>[Opcodes] | [By Name] | [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#bbrx","title":"BBRx","text":"<p>Branch on Bit Reset</p> <pre><code>SYNTAX       MODE           HEX  LEN  CYCLES  FLAGS    \nBBR0 $20,$8080 ZP Relative    $0F   3     5     -------- +c -816\nBBR1 $20,$8080 ZP Relative    $1F   3     5     -------- +c -816\nBBR2 $20,$8080 ZP Relative    $2F   3     5     -------- +c -816\nBBR3 $20,$8080 ZP Relative    $3F   3     5     -------- +c -816\nBBR4 $20,$8080 ZP Relative    $4F   3     5     -------- +c -816\nBBR5 $20,$8080 ZP Relative    $5F   3     5     -------- +c -816\nBBR6 $20,$8080 ZP Relative    $6F   3     5     -------- +c -816\nBBR7 $20,$8080 ZP Relative    $7F   3     5     -------- +c -816\n</code></pre> <p>Branch to LABEL if bit x of zero page address is 0 where x is the number of the specific bit (0-7).</p> <p>+c: New for the 65C02 -816: Not available on the 65C816  </p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#bbr-example","title":"BBR Example","text":"<pre><code>  check_flag:\n    BBR3 zeropage_flag, flag_not_set\n  flag_set:\n    NOP\n    ...\n  flag_not_set:\n    NOP\n    ...\n</code></pre> <p>The above BBR3 looks at value in zeropage_flag (here it's a label to an actual zero page address) and if bit 3 of the value is zero the branch would be taken to <code>@flag_not_set</code>.</p> <p>[Opcodes] | [By Name] | [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#bbsx","title":"BBSx","text":"<p>Branch on Bit Set</p> <pre><code>SYNTAX       MODE           HEX  LEN  CYCLES  FLAGS    \nBBS0 $20,$8080 ZP Relative    $8F   3     5     -------- +c -816\nBBS1 $20,$8080 ZP Relative    $9F   3     5     -------- +c -816\nBBS2 $20,$8080 ZP Relative    $AF   3     5     -------- +c -816\nBBS3 $20,$8080 ZP Relative    $BF   3     5     -------- +c -816\nBBS4 $20,$8080 ZP Relative    $CF   3     5     -------- +c -816\nBBS5 $20,$8080 ZP Relative    $DF   3     5     -------- +c -816\nBBS6 $20,$8080 ZP Relative    $EF   3     5     -------- +c -816\nBBS7 $20,$8080 ZP Relative    $FF   3     5     -------- +c -816\n</code></pre> <p>Branch to LABEL if bit x of zero page address is 1 where x is the number of the specific bit (0-7).</p> <p>+c: New for the 65C02 -816: Not available on the 65C816  </p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#bbs-example","title":"BBS Example","text":"<pre><code>check_flag:\n    BBS3 zeropage_flag, flag_set\nflag_not_set:\n    NOP\n    ...\nflag_set:\n    NOP\n    ...\n</code></pre> <p>The above BBR3 looks at value in zeropage_flag (here it's a label to an actual zero page address) and if bit 3 of the value is zero the branch would be taken to <code>@flag_set</code>.</p> <p>[Opcodes] | [By Name] | [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#bit","title":"BIT","text":"<p>Test Bit</p> <pre><code>SYNTAX       MODE           HEX  LEN  CYCLES  FLAGS    \nBIT $20      Zero Page      $24   2     3     NV----Z- \nBIT $8080    Absolute       $2C   3     4     NV----Z- \nBIT #$20     Immediate      $89   2     2     ------Z- +c\nBIT $20,X    Zero Page,X    $34   2     4     NV----Z- +c\nBIT $8080,X  Absolute,X     $3C   3     4+    NV----Z- +c +p\n</code></pre> <ul> <li>Sets Z (Zero) flag based on an AND of value provided to the Accumulator.</li> <li>Sets N (Negative) flag to the value of bit 7 at the provided address (NOTE: not with immediate).</li> <li>Sets V (Overflow) flag to the value of bit 6 at the provided addres (NOTE: not with immediate).</li> </ul> <p>+p: Add 1 cycle if a page boundary is crossed when forming address. +c: New for the 65C02  </p> <p>[Opcodes] | [By Name] | [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#bcc","title":"Bcc","text":"<p>Branch Instructions</p> <pre><code>SYNTAX       MODE           HEX  LEN  CYCLES  FLAGS    \nBCC $8080    Relative       $90   2    2/3+   -------- +p Carry Clear\nBCS $8080    Relative       $B0   2    2/3+   -------- +p Carry Set\nBEQ $8080    Relative       $F0   2    2/3+   -------- +p Equal: Zero bit set\nBMI $8080    Relative       $30   2    2/3+   -------- +p Negative bit set\nBNE $8080    Relative       $D0   2    2/3+   -------- +p Not Equal: Zero bit clear\nBPL $8080    Relative       $10   2    2/3+   -------- +p Negative bit clear\nBVC $8080    Relative       $50   2    2/3+   -------- +p oVerflow Clear\nBVS $8080    Relative       $70   2    2/3+   -------- +p oVerflow Set\nBRA $8080    Relative       $80   2    3/4+   -------- +p +c Always\n</code></pre> <p>The branch instructions take the branch when the related flag is Set (1) or Clear (0).</p> <p>When combined with CMP, this is the 6502's \"IF THEN\" construct.</p> <pre><code>LDA $1234  ; Reads the value of address $1234\nCMP #$20   ; Compares it with the literal $20 (32)\nBEQ Match  ; If they are equal, move to the label \"Match\".\n</code></pre> <p>The operand is a relative address, based on the Program Counter at the start of the next opcode. As a result, you can only branch 127 bytes forward or 128 bytes back. However, most assemblers take a label or an address literal. So the assembled value will be computed based on the PC and the entered value.</p> <p>For example, if the PC is <code>$1000</code>, the statement <code>BCS $1023</code> will be <code>$B0 $21</code>.</p> <p><code>BCC</code> also functions as \"branch less-than\" (<code>&lt;</code>) after a comparison (some assemblers support a <code>BLT</code> macro/alias). Similarly, <code>BCS</code> also functions as \"branch greater-than-or-equal\" (<code>&gt;=</code>) after a comparison (some assemblers support a <code>BGE</code> macro/alias).</p> <p>+p: Execution takes one additional cycle when branching crosses a page boundary. +c: New for the 65C02</p> <p>[Opcodes] | [By Name] | [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#brk","title":"BRK","text":"<p>Break: Software Interrupt</p> <pre><code>SYNTAX       MODE           HEX  LEN  CYCLES  FLAGS    \nBRK          Implied        $00   1     7     ---BD--- \n</code></pre> <p>BRK is a software interrupt. With any interrupt several things happen:</p> <ol> <li>The Program Counter is incremented by 2 bytes.</li> <li>The new PC and flags are pushed onto the stack (pushed flags has B set on BRK).</li> <li>The B flag is set (but only valid in stack memory flags interrupt pushed).</li> <li>The D (Decimal) flag is cleared, forcing the CPU into binary mode.</li> <li>The CPU reads the address from the IRQ vector at $FFFE and jumps there.</li> </ol> <p>On the X16, BRK will jump out of the running program to the machine monitor. You can then examine the state of the CPU registers and memory.</p> <p>The B flag (as pushed on the stack) is used to distinguish a BRK from an NMI. An interrupt triggered by asserting the NMI pin does not set the B flag, and so the X16 does a warm boot of BASIC, rather than jumping to MONitor.</p> <p>[Opcodes] | [By Name] | [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#clc","title":"CLC","text":"<p>Clear Carry</p> <pre><code>SYNTAX       MODE           HEX  LEN  CYCLES  FLAGS    \nCLC          Implied        $18   1     2     -------C \n</code></pre> <p>Clears the Carry flag. This is useful before ADC to prevent an extra 1 during addition. C is also often used in KERNAL routines to alter the operation of the routine or return certain information.</p> <p>[Opcodes] | [By Name] | [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#cld","title":"CLD","text":"<p>Clear Decimal Flag</p> <pre><code>SYNTAX       MODE           HEX  LEN  CYCLES  FLAGS    \nCLD          Implied        $D8   1     2     ----D--- \n</code></pre> <p>Clears the Decimal flag. This switches the CPU back to binary operation if it was previously in BCD mode.</p> <p>[Opcodes] | [By Name] | [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#cli","title":"CLI","text":"<p>Clear Interrupt Disable</p> <pre><code>SYNTAX       MODE           HEX  LEN  CYCLES  FLAGS    \nCLI          Implied        $58   1     2     -----I-- \n</code></pre> <p>Clear Interrupt disable. This allows IRQ interrupts to proceed normally. NMI and RST are always enabled.</p> <p>Use SEI to disable interrupts</p> <p>[Opcodes] | [By Name] | [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#clv","title":"CLV","text":"<p>Clear oVerflow</p> <pre><code>SYNTAX       MODE           HEX  LEN  CYCLES  FLAGS    \nCLV          Implied        $B8   1     2     -V------ \n</code></pre> <p>Clear the Overflow (V) flag after an arithmetic operation, such as ADC or SBC.</p> <p>[Opcodes] | [By Name] | [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#cmp","title":"CMP","text":"<p>Compare A to memory</p> <pre><code>SYNTAX       MODE           HEX  LEN  CYCLES  FLAGS    \nCMP #$20     Immediate      $C9   2     2     N-----ZC \nCMP $20      Zero Page      $C5   2     3     N-----ZC \nCMP $20,X    Zero Page,X    $D5   2     4     N-----ZC \nCMP $8080    Absolute       $CD   3     4     N-----ZC \nCMP $8080,X  Absolute,X     $DD   3     4+    N-----ZC +p\nCMP $8080,Y  Absolute,Y     $D9   3     4+    N-----ZC +p\nCMP ($20,X)  Indirect,X     $C1   2     6     N-----ZC \nCMP ($20),Y  Indirect,Y     $D1   2     5+    N-----ZC +p\nCMP ($20)    ZP Indirect    $D2   2     5     N-----ZC +c\n</code></pre> <p>Compares the value in the Accumulator (A) with the given value. It sets flags based on subtracting A - Value.</p> <ul> <li>Sets C (Carry) flag if the value in A is &gt;= given value</li> <li>Clears C (Carry) flag if the value in A is &lt; given value</li> <li>Sets Z (Zero) flag if the values are equal</li> <li>Clears Z (Zero) flag if the values are not equal</li> <li>Sets N (Negative) flag if value in A is &lt; given value</li> </ul> <p>+p: Add 1 cycle if a page boundary is crossed when forming address. +c: New for the 65C02  </p> <p>[Opcodes] | [By Name] | [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#cpx","title":"CPX","text":"<p>Compare X to memory</p> <pre><code>SYNTAX       MODE           HEX  LEN  CYCLES  FLAGS    \nCPX #$20     Immediate      $E0   2     2     N-----ZC \nCPX $20      Zero Page      $E4   2     3     N-----ZC \nCPX $8080    Absolute       $EC   3     4     N-----ZC \n</code></pre> <p>Compares the value in the X register with the given value. It sets flags based on subtracting X - Value.</p> <ul> <li>Sets C (Carry) flag if the value in X is &gt;= given value</li> <li>Clears C (Carry) flag if the value in X is &lt; given value</li> <li>Sets Z (Zero) flag if the values are equal</li> <li>Clears Z (Zero) flag if the values are not equal</li> <li>Sets N (Negative) flag if value in X is &lt; given value</li> </ul> <p>[Opcodes] | [By Name] | [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#cpy","title":"CPY","text":"<p>Compare Y to memory</p> <pre><code>SYNTAX       MODE           HEX  LEN  CYCLES  FLAGS    \nCPY #$20     Immediate      $C0   2     2     N-----ZC \nCPY $20      Zero Page      $C4   2     3     N-----ZC \nCPY $8080    Absolute       $CC   3     4     N-----ZC \n</code></pre> <p>Compares the value in the Y register with the given value. It sets flags based on subtracting Y - Value.</p> <ul> <li>Sets C (Carry) flag if the value in Y is &gt;= given value</li> <li>Clears C (Carry) flag if the value in Y is &lt; given value</li> <li>Sets Z (Zero) flag if the values are equal</li> <li>Clears Z (Zero) flag if the values are not equal</li> <li>Sets N (Negative) flag if value in Y is &lt; given value</li> </ul> <p>[Opcodes] | [By Name] | [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#dec","title":"DEC","text":"<p>Decrement Value</p> <pre><code>SYNTAX       MODE           HEX  LEN  CYCLES  FLAGS    \nDEC A        Accumulator    $3A   1     2     N-----Z- +c\nDEC $20      Zero Page      $C6   2     5     N-----Z- \nDEC $20,X    Zero Page,X    $D6   2     6     N-----Z- \nDEC $8080    Absolute       $CE   3     6     N-----Z- \nDEC $8080,X  Absolute,X     $DE   3     7     N-----Z- \nDEX          Implied        $CA   1     2     N-----Z- \nDEY          Implied        $88   1     2     N-----Z- \n</code></pre> <p>Decrement value by one: this subtracts 1 from memory or the designated register, leaving the new value in its place.</p> <p><code>DEC</code> with an operand operates on memory.</p> <p><code>DEX</code> operates on the X register <code>DEY</code> operates on the Y register <code>DEC A</code> or <code>DEC</code> operates on the Accumulator.</p> <ul> <li>Sets N (Negative) flag if the two's compliment value is negative</li> <li>Sets Z (Zero) flag is the value is zero</li> </ul> <p>+c: New for the 65C02  </p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#16-bit-dec-example","title":"16-bit DEC Example","text":"<p>You can peform a 16-bit DEC by chaining two DECs together, testing the low byte before decrementing the high byte:</p> <pre><code>;16 bit decrement\n      LDA Num_Low\n      BNE skip\n      DEC Num_High\nskip: DEC Num_Low\n</code></pre> <p>[Opcodes] | [By Name] | [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#eor","title":"EOR","text":"<p>Exclusive OR</p> <pre><code>SYNTAX       MODE           HEX  LEN  CYCLES  FLAGS    \nEOR #$20     Immediate      $49   2     2     N-----Z- \nEOR $20      Zero Page      $45   2     3     N-----Z- \nEOR $20,X    Zero Page,X    $55   2     4     N-----Z- \nEOR $8080    Absolute       $4D   3     4     N-----Z- \nEOR $8080,X  Absolute,X     $5D   3     4+    N-----Z- +p\nEOR $8080,Y  Absolute,Y     $59   3     4+    N-----Z- +p\nEOR ($20,X)  Indirect,X     $41   2     6     N-----Z- \nEOR ($20),Y  Indirect,Y     $51   2     5+    N-----Z- +p\nEOR ($20)    ZP Indirect    $52   2     5     N-----Z- +c\n</code></pre> <p>Perform an exclusive OR of the given value in A (the accumulator), storing the result in A.</p> <p>The exclusive OR version of ORA.</p> <ul> <li>Sets N (Negative) flag if the two's compliment value is negative</li> <li>Sets Z (Zero) flag is the value is zero</li> </ul> <p>Exclusive OR returns a 1 bit for each bit that is different in the values tested. It returns a 0 for each bit that is the same.</p> <p><code>EOR #$00</code> has no effect on A, but still sets the Z and N flags. <code>EOR #$FF</code> inverts the bits in A.  </p> M A Result 0 0 0 0 1 1 1 0 1 1 1 0 <p>Other Boolean Instructions: ORA bitwise OR AND bitwise AND  </p> <p>+p: Add 1 cycle if a page boundary is crossed when forming address. +c: New for the 65C02  </p> <p>[Opcodes] | [By Name] | [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#inc","title":"INC","text":"<p>Increment Value</p> <pre><code>SYNTAX       MODE           HEX  LEN  CYCLES  FLAGS    \nINC A        Accumulator    $1A   1     2     N-----Z- +c\nINC $20      Zero Page      $E6   2     5     N-----Z- \nINC $20,X    Zero Page,X    $F6   2     6     N-----Z- \nINC $8080    Absolute       $EE   3     6     N-----Z- \nINC $8080,X  Absolute,X     $FE   3     6/7   N-----Z- \nINX          Implied        $E8   1     2     N-----Z- \nINY          Implied        $C8   1     2     N-----Z- \n</code></pre> <p>Increment by one: this adds 1 to memory or the designated register, leaving the new value in its place.</p> <ul> <li>Sets N (Negative) flag if the two's compliment value is negative</li> <li>Sets Z (Zero) flag is the value is zero</li> </ul> <p><code>INC oper</code> operates on memory. <code>INX</code> operates on the X register. <code>INY</code> operates on the Y register. <code>INC A</code> or <code>INC</code> with no operand operates on the Accumulator.  </p> <p>+c: New for the 65C02  </p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#16-bit-inc-example","title":"16-bit INC Example","text":"<p>You can peform a 16-bit INC by chaining two INCs together, testing the low byte after incrementing it.</p> <pre><code>;16 bit increment\n        INC Addr_Low\n        BNE skip\n        INC Addr_High\nskip:   ...\n</code></pre> <p>[Opcodes] | [By Name] | [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#jmp","title":"JMP","text":"<p>Jump to new address</p> <pre><code>SYNTAX       MODE           HEX  LEN  CYCLES  FLAGS    \nJMP $8080    Absolute       $4C   3     3     -------- \nJMP ($8080)  Indirect       $6C   3     5     -------- \nJMP $8080,X  Absolute,X     $7C   3     6     -------- +c\n</code></pre> <p>Jump to specified memory location and begin execution from this point.</p> <p>Note for indirect jumps: The CPU does not correctly retrieve the second byte of the pointer from the next page, so you should never use a pointer address on the last byte of a page. ie: $12FF. [Issue is fixed on 65C02]</p> <p>+c: New for the 65C02  </p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#absolutex-and-jump-tables","title":"(Absolute,X) and Jump Tables","text":"<p>(Absolute,X) is an additional mode for the 65C02 and is commonly used for implementing jump tables.</p> <p>So we might have something like:</p> <pre><code>important_jump_table:\n  .word routine1\n  .word routine2\n...\n\nLDX #$02     ; table index * 2\nJMP (important_jump_table,x)\n</code></pre> <p>The above would jump to the address of <code>routine2</code>, and is much faster than the old 6502 method of pushing the two bytes onto the stack and performing an RTS.</p> <p>[Opcodes] | [By Name] | [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#jsr","title":"JSR","text":"<p>Jump to Subroutine</p> <pre><code>SYNTAX       MODE           HEX  LEN  CYCLES  FLAGS    \nJSR $8080    Absolute       $20   3     6     -------- \n</code></pre> <p>Stores the address of the Program Counter to the stack. Jump to specified memory location and begin execution from this point.  </p> <p>This is used to run subroutines in user programs, as well as running KERNAL routines. RTS is used at the end of the routine to return to the instruction immediately after the JSR.</p> <p>Be careful to always match JSR and RTS, as imbalanced JSR/RTS operations will either overflow or underflow the stack.</p> <p>[Opcodes] | [By Name] | [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#lda","title":"LDA","text":"<p>Read memory to Accumulator</p> <pre><code>SYNTAX       MODE           HEX  LEN  CYCLES  FLAGS    \nLDA #$20     Immediate      $A9   2     2     N-----Z- \nLDA $20      Zero Page      $A5   2     3     N-----Z- \nLDA $20,X    Zero Page,X    $B5   2     4     N-----Z- \nLDA $8080    Absolute       $AD   3     4     N-----Z- \nLDA $8080,X  Absolute,X     $BD   3     4+    N-----Z- +p\nLDA $8080,Y  Absolute,Y     $B9   3     4+    N-----Z- +p\nLDA ($20,X)  Indirect,X     $A1   2     6     N-----Z- \nLDA ($20),Y  Indirect,Y     $B1   2     5+    N-----Z- +p\nLDA ($20)    ZP Indirect    $B2   2     5     N-----Z- +c\n</code></pre> <p>Place the given value from memory into the accumulator (A).</p> <ul> <li>Sets N (Negative) flag if the two's compliment value is negative</li> <li>Sets Z (Zero) flag is the value is zero</li> </ul> <p>+p: Add 1 cycle if a page boundary is crossed when forming address. +c: New for the 65C02  </p> <p>[Opcodes] | [By Name] | [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#ldx","title":"LDX","text":"<p>Read memory to X Index Register</p> <pre><code>SYNTAX       MODE           HEX  LEN  CYCLES  FLAGS    \nLDX #$20     Immediate      $A2   2     2     N-----Z- \nLDX $20      Zero Page      $A6   2     3     N-----Z- \nLDX $20,Y    Zero Page,Y    $B6   2     4     N-----Z- \nLDX $8080    Absolute       $AE   3     4     N-----Z- \nLDX $8080,Y  Absolute,Y     $BE   3     4+    N-----Z- +p\n</code></pre> <p>Place the given value from memory into the X register.</p> <ul> <li>Sets N (Negative) flag if the two's compliment value is negative</li> <li>Sets Z (Zero) flag is the value is zero</li> </ul> <p>+p: Add 1 cycle if a page boundary is crossed when forming address.  </p> <p>[Opcodes] | [By Name] | [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#ldy","title":"LDY","text":"<p>Read memory to Y Index Register</p> <pre><code>SYNTAX       MODE           HEX  LEN  CYCLES  FLAGS    \nLDY #$20     Immediate      $A0   2     2     N-----Z- \nLDY $20      Zero Page      $A4   2     3     N-----Z- \nLDY $20,X    Zero Page,X    $B4   2     4     N-----Z- \nLDY $8080    Absolute       $AC   3     4     N-----Z- \nLDY $8080,X  Absolute,X     $BC   3     4+    N-----Z- +p\n</code></pre> <p>Place the given value from memory into the Y register.</p> <ul> <li>Sets N (Negative) flag if the two's compliment value is negative</li> <li>Sets Z (Zero) flag is the value is zero</li> </ul> <p>+p: Add 1 cycle if a page boundary is crossed when forming address.  </p> <p>[Opcodes] | [By Name] | [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#lsr","title":"LSR","text":"<p>Logical Shift Right</p> <pre><code>SYNTAX       MODE           HEX  LEN  CYCLES  FLAGS    \nLSR A        Accumulator    $4A   1     2     N-----Z- \nLSR $20      Zero Page      $46   2     5     N-----Z- \nLSR $20,X    Zero Page,X    $56   2     6     N-----Z- \nLSR $8080    Absolute       $4E   3     6     N-----Z- \nLSR $8080,X  Absolute,X     $5E   3    6/7    N-----Z-\n</code></pre> <p>Shifts all bits to the right by one position.</p> <p>Bit 0 is shifted into Carry. 0 shifted into bit 7.  </p> <p>Similar instructions: ASL is the opposite instruction, shifting to the left. ROR rotates bit 0 through Carry to bit 7.  </p> <p>[Opcodes] | [By Name] | [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#nop","title":"NOP","text":"<p>No Operation</p> <pre><code>SYNTAX       MODE           HEX  LEN  CYCLES  FLAGS    \nNOP          Implied        $EA   1     2     -------- \n</code></pre> <p>NOP simply does nothing for 2 clock cycles. No registers are affected, and no memory reads or writes occur. This can be used to delay the clock by 2 ticks.</p> <p>It's also a useful way to blank out unwanted instructions in memory or in a machine language program on disk. By changing the byte values of the opcode and operands to $EA, you can effectively cancel out an instruction.</p> <p>It is also useful for adding small delays to your code. For instance, to add a bit of delay when writing to the YM2151 chip (see Chapter 11 - YM Write Procedure).</p> <p>[Opcodes] | [By Name] | [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#ora","title":"ORA","text":"<p>Logical OR</p> <pre><code>SYNTAX       MODE           HEX  LEN  CYCLES  FLAGS    \nORA #$20     Immediate      $09   2     2     N-----Z- \nORA $20      Zero Page      $05   2     3     N-----Z- \nORA $20,X    Zero Page,X    $15   2     4     N-----Z- \nORA $8080    Absolute       $0D   3     4     N-----Z- \nORA $8080,X  Absolute,X     $1D   3     4+    N-----Z- +p\nORA $8080,Y  Absolute,Y     $19   3     4+    N-----Z- +p\nORA ($20,X)  Indirect,X     $01   2     6     N-----Z- \nORA ($20),Y  Indirect,Y     $11   2     5+    N-----Z- +p\nORA ($20)    ZP Indirect    $12   2     5     N-----Z- +c\n</code></pre> <p>Perform a logical OR of the given value in A (the Accumulator), storing the result in A.</p> <ul> <li>Sets N (Negative) flag if the two's compliment value is negative</li> <li>Sets Z (Zero) flag is the value is zero</li> </ul> <p><code>OR #$00</code> has no effect on A, but still sets the Z and N flags. <code>OR #$FF</code> results in $FF.</p> M A Result 0 0 0 0 1 1 1 0 1 1 1 1 <p>Other Boolean Instructions: EOR exclusive-OR AND bitwise AND  </p> <p>+p: Add 1 cycle if a page boundary is crossed when forming address. +c: New for the 65C02  </p> <p>[Opcodes] | [By Name] | [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#pha","title":"PHA","text":"<p>Push to stack</p> <pre><code>SYNTAX       MODE           HEX  LEN  CYCLES  FLAGS    \nPHA          Implied        $48   1     3     -------- \nPHP          Implied        $08   1     3     -------- \nPHX          Implied        $DA   1     3     -------- +c\nPHY          Implied        $5A   1     3     -------- +c\n</code></pre> <p>Pushes a register to the stack.</p> <p>This instruction copies the value in the affected register to the address of the stack pointer, then moves the stack pointer downward by one byte.</p> <p>Be careful to match Push and Pull operations so that you don't accidentally overflow or underflow the stack.</p> <p>PHP pushes the Flags, also called P for Program Status Register.</p> <p>The corresponding \"Pull\" instructions are PLA, PHP, PHX, and PHY.</p> <p>+c: New for the 65C02  </p> <p>[Opcodes] | [By Name] | [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#pla","title":"PLA","text":"<p>Pull from stack</p> <pre><code>SYNTAX       MODE           HEX  LEN  CYCLES  FLAGS    \nPLA          Implied        $68   1     4     N-----Z- \nPLP          Implied        $28   1     4     NV--DIZC \nPLX          Implied        $FA   1     4     N-----Z- +c\nPLY          Implied        $7A   1     4     N-----Z- +c\n</code></pre> <p>Pulls a value from the stack into a register.</p> <p>This instruction moves the stack pointer up by one byte, then copies the value from the address of the stack pointer to the affected register.</p> <p>Be careful to match Push and Pull operations so that you don't accidentally overflow or underflow the stack.</p> <p>PLP pulls the Flags, also called P for Program Status Register.</p> <p>Use TXS or TSX to directly manage the stack pointer.</p> <p>The corresponding \"Push\" instructions are PHA, PHP, PHX, and PHY.</p> <p>+c: New for the 65C02  </p> <p>[Opcodes] | [By Name] | [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#rmbx","title":"RMBx","text":"<p>Memory Bit Operations</p> <pre><code>SYNTAX       MODE           HEX  LEN  CYCLES  FLAGS    \nRMB0 $20     Zero Page      $07   2     5     -------- +c -816\nRMB1 $20     Zero Page      $17   2     5     -------- +c -816\nRMB2 $20     Zero Page      $27   2     5     -------- +c -816\nRMB3 $20     Zero Page      $37   2     5     -------- +c -816\nRMB4 $20     Zero Page      $47   2     5     -------- +c -816\nRMB5 $20     Zero Page      $57   2     5     -------- +c -816\nRMB6 $20     Zero Page      $67   2     5     -------- +c -816\nRMB7 $20     Zero Page      $77   2     5     -------- +c -816\n</code></pre> <p>Set bit x to 0 at the given zero page address where x is the number of the specified bit (0-7).</p> <p>Often used in conjunction with BBR and BBS.</p> <p>+c: New for the 65C02 -816: Not available on the 65C816  </p> <p>[Opcodes] | [By Name] | [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#rol","title":"ROL","text":"<p>Rotate Left</p> <pre><code>SYNTAX       MODE           HEX  LEN  CYCLES  FLAGS    \nROL A        Accumulator    $2A   1     2     N-----ZC \nROL $20      Zero Page      $26   2     5     N-----ZC \nROL $20,X    Zero Page,X    $36   2     6     N-----ZC \nROL $8080    Absolute       $2E   3     6     N-----ZC \nROL $8080,X  Absolute,X     $3E   3    6/7    N-----ZC +p\n</code></pre> <p>Rotate all bits to the left one position. The value in the carry (C) flag is shifted into bit 0 and the original bit 7 is shifted into the carry (C).</p> <p>ASL shifts left, moving 0 into bit 0 ROR rotates to the right.</p> <p>+p: Add 1 cycle if a page boundary is crossed when forming address.  </p> <p>[Opcodes] | [By Name] | [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#ror","title":"ROR","text":"<p>Rotate Right</p> <pre><code>SYNTAX       MODE           HEX  LEN  CYCLES  FLAGS    \nROR A        Accumulator    $6A   1     2     N-----ZC \nROR $20      Zero Page      $66   2     5     N-----ZC \nROR $20,X    Zero Page,X    $76   2     6     N-----ZC \nROR $8080    Absolute       $7E   3     6     N-----ZC \nROR $8080,X  Absolute,X     $6E   3    6/7    N-----ZC +p\n</code></pre> <p>Rotate all bits to the right one position. The value in the carry (C) flag is shifted into bit 7 and the original bit 0 is shifted into the carry (C).</p> <p>LSR shifts right, placing 0 into bit 7. ROL rotates to the left.  </p> <p>+p: Add 1 cycle if a page boundary is crossed when forming address.  </p> <p>[Opcodes] | [By Name] | [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#rti","title":"RTI","text":"<p>Return from Interrupt</p> <pre><code>SYNTAX       MODE           HEX  LEN  CYCLES  FLAGS    \nRTI          Implied        $40   1     6     -------- \n</code></pre> <p>Return from an interrupt by popping three values off the stack. The first is for the status register (P) followed by the two bytes of the program counter.</p> <p>Note that unlike RTS, the popped address is the actual return address (rather than address-1).</p> <p>[Opcodes] | [By Name] | [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#rts","title":"RTS","text":"<p>Return from Subroutine</p> <pre><code>SYNTAX       MODE           HEX  LEN  CYCLES  FLAGS    \nRTS          Implied        $60   1     6     -------- \n</code></pre> <p>Typically used at the end of a subroutine. It jumps back to the address after the JSR that called it by popping the top 2 bytes off the stack and transferring control to that address +1.</p> <p>[Opcodes] | [By Name] | [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#sbc","title":"SBC","text":"<p>Subtract With Carry</p> <pre><code>SYNTAX       MODE           HEX  LEN  CYCLES  FLAGS    \nSBC #$20     Immediate      $E9   2     2     NV----ZC \nSBC $20      Zero Page      $E5   2     3     NV----ZC \nSBC $20,X    Zero Page,X    $F5   2     4     NV----ZC \nSBC $8080    Absolute       $ED   3     4     NV----ZC \nSBC $8080,X  Absolute,X     $FD   3     4+    NV----ZC +p\nSBC $8080,Y  Absolute,Y     $F9   3     4+    NV----ZC +p\nSBC ($20,X)  Indirect,X     $E1   2     6     NV----ZC \nSBC ($20),Y  Indirect,Y     $F1   2     5+    NV----ZC +p\nSBC ($20)    ZP Indirect    $F2   2     5     NV----ZC +c\n</code></pre> <p>Subtract the operand from A and places the result in A.</p> <p>When Carry is 0, an additional 1 is subtracted.</p> <p>There is no \"Subtract without carry\". To do that, use SEC first to set the Carry flag.</p> <p>If D=1, subtraction is Binary Coded Decimal. If D=0 then subtraction is binary.</p> <p>C is clear when result is less than 0. (ie: Borrow took place) Z is set when result is zero V is set when signed result goes below -128 or above 127. N is set when result is negative (bit 7=1)  </p> <p>+p: Add 1 cycle if a page boundary is crossed when forming address. +c: New for the 65C02</p> <p>[Opcodes] | [By Name] | [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#sec","title":"SEC","text":"<p>Set Carry</p> <pre><code>SYNTAX       MODE           HEX  LEN  CYCLES  FLAGS    \nSEC          Implied        $38   1     2     -------C \n</code></pre> <p>Sets the Carry flag. This is used before SBC to prevent an extra subtract. C is also often used in KERNAL routines to alter the operation of the routine or return certain information.</p> <p>[Opcodes] | [By Name] | [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#sed","title":"SED","text":"<p>Set Decimal</p> <pre><code>SYNTAX       MODE           HEX  LEN  CYCLES  FLAGS    \nSED          Implied        $F8   1     2     ----D--- \n</code></pre> <p>Sets the Decimal flag. This will put the CPU in BCD mode, which affects the behavior of ADC and SBC.</p> <p>In binary mode, adding 1 to $09 will set the Accumulator to $0F. In BCD mode, adding 1 to $09 will set the Accumulator to $10.  </p> <p>Using BCD allows for easier conversion of binary numbers to decimal. BCD also allows for storing decimal numbers without loss of precision due to power-of-2 rounding.</p> <p>[Opcodes] | [By Name] | [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#sei","title":"SEI","text":"<p>Set Interrupt Disable</p> <pre><code>SYNTAX       MODE           HEX  LEN  CYCLES  FLAGS    \nSEI          Implied        $78   1     2     -----I-- \n</code></pre> <p>Sets or clears the Interrupt Disable flag. When I is set, the CPU will not execute IRQ interrupts, even if the line is asserted. Use CLI to re-enable interrupts.</p> <p>[Opcodes] | [By Name] | [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#smbx","title":"SMBx","text":"<p>Set Memory Bit</p> <pre><code>SYNTAX       MODE           HEX  LEN  CYCLES  FLAGS    \nSMB0 $20     Zero Page      $87   2     5     -------- +c -816\nSMB1 $20     Zero Page      $97   2     5     -------- +c -816\nSMB2 $20     Zero Page      $A7   2     5     -------- +c -816\nSMB3 $20     Zero Page      $B7   2     5     -------- +c -816\nSMB4 $20     Zero Page      $C7   2     5     -------- +c -816\nSMB5 $20     Zero Page      $D7   2     5     -------- +c -816\nSMB6 $20     Zero Page      $E7   2     5     -------- +c -816\nSMB7 $20     Zero Page      $F7   2     5     -------- +c -816\n</code></pre> <p>Set bit x to 1 at the given zero page address where x is the number of the specific bit (0-7).</p> <p>Often used in conjunction with BBR and BBS.</p> <p>Specific to the 65C02 (unavailable on the 65C816)</p> <p>+c: New for the 65C02 -816: Not available on the 65C816  </p> <p>[Opcodes] | [By Name] | [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#sta","title":"STA","text":"<p>Store Accumulator contents to memory</p> <pre><code>SYNTAX       MODE           HEX  LEN  CYCLES  FLAGS    \nSTA $20      Zero Page      $85   2     3     -------- \nSTA $20,X    Zero Page,X    $95   2     4     -------- \nSTA $8080    Absolute       $8D   3     4     -------- \nSTA $8080,X  Absolute,X     $9D   3     5+    -------- +p\nSTA $8080,Y  Absolute,Y     $99   3     5+    -------- +p\nSTA ($20,X)  Indirect,X     $81   2     6     -------- \nSTA ($20),Y  Indirect,Y     $91   2     6+    -------- +p\nSTA ($20)    ZP Indirect    $92   2     5     -------- +c\n</code></pre> <p>Place the given value from the accumulator (A) into memory.</p> <p>+p: Add 1 cycle if a page boundary is crossed when forming address. +c: New for the 65C02</p> <p>[Opcodes] | [By Name] | [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#stp","title":"STP","text":"<p>Stop</p> <pre><code>SYNTAX       MODE           HEX  LEN  CYCLES  FLAGS    \nSTP          Implied        $DB   1     3     -------- +c\n</code></pre> <p>Stops (or halts) the processor and places it in a lower power state until a hardware reset occurs. For the X16 emulator, when the debugger is enabled using the <code>-debug</code> command-line parameter, the STP instruction will break into the debugger automatically.</p> <p>If debugging is not enabled, the emulator will prompt the user to close the emulator or reset the emulation.</p> <p>+c: New for the 65C02</p> <p>[Opcodes] | [By Name] | [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#stx","title":"STX","text":"<p>Save X Index Register contents to memory</p> <pre><code>SYNTAX       MODE           HEX  LEN  CYCLES  FLAGS    \nSTX $20      Zero Page      $86   2     3     -------- \nSTX $20,Y    Zero Page,Y    $96   2     4     -------- \nSTX $8080    Absolute       $8E   3     4     -------- \n</code></pre> <p>[Opcodes] | [By Name] | [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#sty","title":"STY","text":"<p>Save Y Index Register contents to memory</p> <pre><code>SYNTAX       MODE           HEX  LEN  CYCLES  FLAGS    \nSTY $20      Zero Page      $84   2     3     -------- \nSTY $20,X    Zero Page,X    $94   2     4     -------- \nSTY $8080    Absolute       $8C   3     4     -------- \n</code></pre> <p>[Opcodes] | [By Name] | [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#stz","title":"STZ","text":"<p>Set memory to zero</p> <pre><code>SYNTAX       MODE           HEX  LEN  CYCLES  FLAGS    \nSTZ $20      Zero Page      $64   2     3     -------- +c\nSTZ $20,X    Zero Page,X    $74   2     4     -------- +c\nSTZ $8080    Absolute       $9C   3     4     -------- +c\nSTZ $8080,X  Absolute,X     $9E   3     5     -------- +c\n</code></pre> <p>+c: New for the 65C02</p> <p>[Opcodes] | [By Name] | [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#trb","title":"TRB","text":"<p>Test and reset bit</p> <pre><code>SYNTAX       MODE           HEX  LEN  CYCLES  FLAGS    \nTRB $20      Zero Page      $14   2     5     ------Z- +c\nTRB $8080    Absolute       $1C   3     5     ------Z- +c\n</code></pre> <p>Effectively an inverted AND between memory and the Accumulator. The bits that are 1 in the Accumulator are set to 0 in memory.</p> <ul> <li>Sets Z (Zero) flag if all bits from the AND are zero.</li> </ul> <p>+c: New for the 65C02</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#trb-example","title":"TRB Example","text":"<pre><code>          ; Assume location $20 has a value of $11.\nLDA #$01  ; Load a bit mask of 0000 0001\nTRB $20   ; Apply the mask and reset bit 0\n          ; Location $20 now has a value of $10.\n</code></pre> <p>This is conceptually similar to</p> <pre><code>LDA #$01 ; We want to clear bit 1 of the data\nEOR #$FF ; Invert the mask, so $01 becomes $FE (1111 1110)\nAND $20  ; AND with memory, saving the result in .A\nSTA $20  ; Store it back to memory.\n</code></pre> <p>[Opcodes] | [By Name] | [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#tsb","title":"TSB","text":"<p>Test and set bit</p> <pre><code>SYNTAX       MODE           HEX  LEN  CYCLES  FLAGS    \nTSB $20      Zero Page      $04   2     5     ------Z- +c\nTSB $8080    Absolute       $0C   3     5     ------Z- +c\n</code></pre> <p>Performs an OR with each bit in the accumulator and memory. Each bit that is 1 in the Accumulator is set to 1 in memory. This is similar to an ORA operation, execpt that the result is stored in memory, not in A.</p> <p>The Z flag is set based on the final result of the operation, ie: the memory data is 0.</p> <p>+c: New for the 65C02</p> <p>[Opcodes] | [By Name] | [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#txx","title":"Txx","text":"<p>Transfer between registers</p> <pre><code>SYNTAX       MODE           HEX  LEN  CYCLES  FLAGS    \nTAX          Implied        $AA   1     2     N-----Z- Copy from .A to .X\nTXA          Implied        $8A   1     2     N-----Z- Copy from .X to .A\nTAY          Implied        $A8   1     2     N-----Z- Copy from .A to .Y\nTYA          Implied        $98   1     2     N-----Z- Copy from .Y to .A\nTSX          Implied        $BA   1     2     N-----Z- Copy from Stack Pointer to .X\nTXS          Implied        $9A   1     2     -------- Copy from .X to Stack Pointer\n</code></pre> <p>Copies data from one register to anohter.</p> <p>TSX and TSX copy between the Stack Pointer and the X register. This is the only way to directly control the Stack Pointer. To initialize the Stack Pointer to a specific address, you can use the following instructions.</p> <pre><code>LDX #$FF\nTXS\n</code></pre> <p>[Opcodes] | [By Name] | [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#wai","title":"WAI","text":"<p>Wait</p> <pre><code>SYNTAX       MODE           HEX  LEN  CYCLES  FLAGS    \nWAI          Implied        $CB   1     3     -------- +c\n</code></pre> <p>Effectively stops the processor until a hardware interrupt occurs. The intterupt is processed immediately, and execution resumes in the Interrupt handler.</p> <p>NMI, IRQ, and RST (Reset) will recover from the WAI condition.</p> <p>Normally, an instruction completes its operation before actually handling an interrupt. But if WAI has executed, the CPU does not need to defer the interrupt, and so the interrupt can be handled immediately.</p> <p>+c: New for the 65C02</p> <p>[Opcodes] | [By Name] | [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#status-flags","title":"Status Flags","text":"<p>Flags are stored in the P register. PHP and PLP can be used to directly manipulate this register. Otherwise the flags are used to indicate certain statuses and changed by various instructions.</p> <p>P-Register:</p> <p><code>NV1B DIZC</code></p> <p>N = Negative   V = oVerflow   1 = Always 1   B = Interrupt Flag   D = Decimal Mode   I = Interupts Disabled   Z = Zero   C = Carry  </p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#replacement-macros-for-bit-instructions","title":"Replacement Macros for Bit Instructions","text":"<p>Since <code>BBRx</code>, <code>BBSx</code>, <code>RMBx</code>, and <code>SMBx</code> should not be used, to maintain compatibility with the 65C816, here are some example macros that can be used to help convert existing software that may have been using these instructions:</p> <pre><code>.macro bbs bit_position, data, destination\n .if (bit_position = 7)\n  bit data\n  bmi destination\n .else\n  .if (bit_position = 6)\n   bit data\n   bvs destination\n  .else\n   lda data\n   and #1 &lt;&lt; bit_position\n   bne destination\n  .endif\n  .endif\n.endmacro\n\n.macro bbr bit_position, data, destination\n .if (bit_position = 7)\n  bit data\n  bpl destination\n .else\n  .if (bit_position = 6)\n   bit data\n   bvc destination\n  .else\n   lda data\n   and #1 &lt;&lt; bit_position\n   beq destination\n  .endif\n .endif\n.endmacro\n\n.macro rmb bit, destination\n lda #$1 &lt;&lt; bit\n trb destination\n.endmacro\n\n.macro smb bit, destination\n lda #$1 &lt;&lt; bit\n tsb destination\n.endmacro\n</code></pre> <p>The above is CA65 specific but the code should work similarly for other languages. The logic can also be used to if using an assembly language tool that does not have macro support with small changes.</p>"},{"location":"X16%20Reference%20-%20Appendix%20C%20-%2065C02%20Processor/#further-reading","title":"Further Reading","text":"<ul> <li>http://www.6502.org/tutorials/6502opcodes.html</li> <li>http://6502.org/tutorials/65c02opcodes.html</li> <li>https://www.pagetable.com/c64ref/6502/?cpu=65c02</li> <li>http://www.oxyron.de/html/opcodesc02.html</li> <li>https://www.nesdev.org/wiki/Status_flags</li> <li>https://skilldrick.github.io/easy6502/</li> <li>https://www.westerndesigncenter.com/wdc/documentation/w65c02s.pdf</li> <li>https://www.westerndesigncenter.com/wdc/documentation/w65c816s.pdf</li> </ul> <p>a different page  </p>"},{"location":"X16%20Reference%20-%20Appendix%20D%20-%20Official%20Expansion%20Cards/","title":"Appendix D: Official Expansion Cards","text":"<p>This is just a stub as a proposal for how to document official expansion cards (namely those made by the core X16 team).</p>"},{"location":"X16%20Reference%20-%20Appendix%20D%20-%20Official%20Expansion%20Cards/#serialmidi-uartwavetable-expansion-card","title":"Serial/MIDI UART/Wavetable Expansion Card","text":"<p>Kevin is desinging an EIA compliant UART expansion card which is capable of supporting  standard serial as well as MIDI and even has a header to install wavetable cards. It uses the Texas Instruments TL16C2550.</p> <p></p> <p>As the card is still in development there are not any demos or code examples available, though the datasheet contains informaiton on how to set things up (see below). Kevin also provied some information on how to setup the card in his original announcement on the community Discord.</p>"},{"location":"X16%20Reference%20-%20Appendix%20E%20-%20Diagnostic%20Bank/","title":"Appendix E: Diagnostic Bank","text":"<p>The Diagnostic ROM bank can run a full diagnostic on the system memory (base + 512K-2048K extended) of the Commander X16.</p>"},{"location":"X16%20Reference%20-%20Appendix%20E%20-%20Diagnostic%20Bank/#index","title":"Index","text":"<ul> <li>Running Diagnostics</li> <li>Progress indicators<ul> <li>Without screen</li> <li>With screen</li> </ul> </li> <li>Error communication</li> <li>Test algorithm<ul> <li>Theory</li> <li>Implementation</li> </ul> </li> </ul>"},{"location":"X16%20Reference%20-%20Appendix%20E%20-%20Diagnostic%20Bank/#running-diagnostics","title":"Running Diagnostics","text":""},{"location":"X16%20Reference%20-%20Appendix%20E%20-%20Diagnostic%20Bank/#functional-system","title":"Functional system","text":"<p>The memory diagnostics can be started in two different ways. If the system is functional enough to actually boot into BASIC, the diagnostics can be started from there with the following: <pre><code>BANK 0,7: SYS $C000\n</code></pre></p> <p>It is also possible to jump directly to the diagnostic ROM bank from assembly. <pre><code>    lda #$07    ; ROM bank 7 is the diagnostic bank\n    sta $01     ; Write ROM bank to ROM bank registers\n    jmp $C000   ; Jump to beginning of diagnostic ROM\n</code></pre></p> <p>NOTE: The Diagnostic ROM is not able to return to BASIC or any program that has called. The only way to exit the Diagnostic ROM is by resetting or powercycling the system.</p>"},{"location":"X16%20Reference%20-%20Appendix%20E%20-%20Diagnostic%20Bank/#non-functional-system","title":"Non functional system","text":"<p>If the Commander X16 is not able to boot into BASIC, the memory diagnostics can be started by keeping the power button pressed for about a second when powering on the system. This will make the Commander X16 boot directly into the diagnostic ROM bank and start the memory diagnostics.</p>"},{"location":"X16%20Reference%20-%20Appendix%20E%20-%20Diagnostic%20Bank/#progress-indicators","title":"Progress indicators","text":""},{"location":"X16%20Reference%20-%20Appendix%20E%20-%20Diagnostic%20Bank/#without-screen","title":"Without screen","text":"<p>When the diagnostic ROM bank starts, it will use the activity LED to indicate the progress. * ON - while zero-page memory is tested (very brief) * OFF - for 1st test of base memory ($0100-$9EFF) * ON - for 2nd test of base memory ($0100-$9EFF) * OFF - for 3rd test of base memory ($0100-$9EFF) * ON - for 4th test of base memory ($0100-$9EFF)</p> <p>After the inital test of base memory, the number of available memory banks is tested, VERA is initialized and both the activity LED and the keyboard LEDs are used to indicate the progress. The keyboard LEDs are used as a binary counter: | Num | Binary | Num Lock | Caps Lock | Scroll Lock | |-----|--------|----------|-----------|-------------| |  0  |  000   |    0     |     0     |      0      | |  1  |  001   |    0     |     0     |      1      | |  2  |  010   |    0     |     1     |      0      | |  3  |  011   |    0     |     1     |      1      | |  4  |  100   |    1     |     0     |      0      | |  5  |  101   |    1     |     0     |      1      | |  6  |  110   |    1     |     1     |      0      | |  7  |  111   |    1     |     1     |      1      |</p>"},{"location":"X16%20Reference%20-%20Appendix%20E%20-%20Diagnostic%20Bank/#main-test-loop","title":"Main test loop","text":"<p>During the first test iteration, the keyboard LEDs will display 0 0 1 When the test is done, the activity light will blink once. During the second test iteration, the keyboard LEDS will display 0 1 0 When the test is done, the activity light will blink once. During the third test iteration, the keyboard LEDs will display 0 1 1 When the test is done, the activity light will blink once. During the fourth test iteration, the keyboard LEDs will display 1 0 0 When the test is done, the activity light will blink once.  </p> <p>As the last part of the test loop, the base memory is tested. Keyboard LEDs will show 1 0 1 When the test loop is done, keyboard LEDs will show 1 1 1 and the activity LED will blink 3 times before starting over.</p>"},{"location":"X16%20Reference%20-%20Appendix%20E%20-%20Diagnostic%20Bank/#with-screen","title":"With screen","text":"<p>When the base memory has been tested the first time, VERA is initialized with output to VGA. On the screen there is detailed information about the progress of each test iteration. Each time through the main test loop, the output of VERA will be switched between VGA and Composite/S-Video.  </p>"},{"location":"X16%20Reference%20-%20Appendix%20E%20-%20Diagnostic%20Bank/#error-communication","title":"Error communication","text":"<p>If an error is detected before VERA is initialized, the error will be reported with the activity LED by blinking every half second 3 times, staying off for 1 second and repeating. - All tests stop.  </p> <p>This means that if an error occurs before VERA is initialized, you have no way of figuring out exactly where the error is, but you do know that the error has happened in base memory.  </p> <p>When the initial test of base memory has succeeded and VERA is initialized, any errors will be reported to the display. Only if more than 32 errors are encountered, will the tests stop and the activity LED will flash the same way as when an error is encountered before VERA initialization.  </p> <p>Even when tests are stopped, VERA output will still be switched between VGA and Composite/S-Video about every minute.</p> <p>The errorcodes on screen are as follows: </p>"},{"location":"X16%20Reference%20-%20Appendix%20E%20-%20Diagnostic%20Bank/#test-algorithm","title":"Test algorithm","text":""},{"location":"X16%20Reference%20-%20Appendix%20E%20-%20Diagnostic%20Bank/#theory","title":"Theory","text":"<p>RAM diagnostics are performed with the March C- algorithm. This algorithm should be fairly godd at finding most common memory errors.  </p> <p>In short, he aslgorithm is described as follows: 1. Write 0 to all memory cells 2. For each cell, check that it contains 0 and write 1 in ascending order 3. For each cell, check that it contains 1 and write 0 in ascending order 4. For each cell, check that it contains 0 and write 1 in descending order 5. For each cell, check that it contains 1 and write 0 in descending order 6. Check that all cells contain 0</p> <p>On the Commander X16 and most other 6502 based computers, above algorithm would take a very long time to complete. For this reason, the algorithm has been modified slightly to write and compare entire bytes instead of single bits. To catch most memory errors, the following bit patterns are tested: * 0000 0000 * 0101 0101 * 0011 0011 * 0000 1111</p> <p>The algorithm is then implemented in the following way: 1. Write pattern to all memory addresses 2. For each addres, check the patterna and write the inverted patterin in ascending order 3. For each address, check the inverted pattern and write the original pattern in ascending order 4. For each address, check the original pattern and write the inverted pattern in descending order 5. For eac address, check the inverted pattern and write the original pattern in descending order 6. Check all addresses contain the original pattern</p>"},{"location":"X16%20Reference%20-%20Appendix%20E%20-%20Diagnostic%20Bank/#implementation","title":"Implementation","text":"<p>When memory test starts, the first thing that happens is that zero-page is tested by it self. If this test passes, the rest of base memory is tested from $0100-$9EFF while ensuring that these tests do not affect zero-page memory.  </p> <p>When basememory has passed the initial test, zero-page is used for variables and stack pointer is initialized to enable pushing and popping of registers and function calls. VERA is initialized and the number of memory banks is tested.  </p> <p>All available memory banks are tested together as opposed to checking and clearing a single memory page at a time. When all memory banks have been tested, the base memory $0200-$9EFF is tested again.  </p> <p>Memory banks and base memory is tested in continous loop.  </p> <p>If an error is detected, this is either communicated through the activity LED, if VERA has not yet been initialized, or by writing information about the error on the display.</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/","title":"Appendix F: The 65C816 Processor","text":""},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#table-of-contents","title":"Table Of Contents","text":"<ol> <li>Overview</li> <li>Compatibility with the 65C02</li> <li>Registers</li> <li>Status Flags</li> <li>16 bit mode</li> <li>Address Modes</li> <li>Vectors</li> <li>Instruction Tables</li> </ol>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#overview","title":"Overview","text":"<p>This document is a brief introduction and quick reference for the 65C816 Microprocessor. For more details, see the 65C816 data sheet or Programming the 65816: Including the 6502, 65C02, and 65802.</p> <p>The WDC65C816 CPU is an 8/16 bit CPU and a follow-up to the 65C02 processor. The familiar 65C02 instructions and address modes are retained, and some new ones are added.</p> <p>The CPU can optionally operate in 16-bit mode, extending the utility of math instruction (16-bit adds!) and the coverage of .X and .Y indexed modes to 64KB.</p> <p>Zero Page has been renamed to Direct Page, and Direct Page can now be relocated anywhere in the first 64K of RAM. As a result, all of the Zero Page instructions are now \"Direct\" instructions and can operate anywhere in the X16's address range.</p> <p>Likewise, the Stack can also be relocated, and the stack pointer is now 16 bits. This allows for a much larger stack, and the combination of stack and DP relocation offer interesting multitasking opportunities.</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#compatibility-with-the-65c02","title":"Compatibility with the 65C02","text":"<p>The 65C916 CPU is generally compatible with the 65C02 instruction set, with the exception  of the <code>BBRx</code>, <code>BBSx</code>, <code>RMBx</code>, and <code>SMBx</code> instructions. We recommend programmers avoid these instructions when writing X16 softwware, using the more conventional Boolean logic instructions, instead.</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#registers","title":"Registers","text":"Notation Name Description A Accumulator The accumulator. It stores the result of moth math and logical operations. X X Index .X is mostly used as a counter and to offset addresses with X indexed modes Y Y Index .Y is mostly used as a counter and to offset addresses with Y indexed modes S Stack Pointer SP points to the next open position on the stack. DB or DBR Data Bank Data bank is the default bank for operations that use a 16 bit address. K or  PBR Program Bank The default address for 16 bit JMP and JSR oprerations. Can only be set with a 24 bit JMP or JSR. P Processor Status The flags. PC Program Counter The address of the current CPU instruction <p>.A, .X, and .Y can be 8 or 16 bits wide, based on the flag settings (see below).</p> <p>The Stack Pointer (.S) is 16 bits wide in Native mode and 8 bits wide (and fixed to the $100-1FF range) in Emulation mode.</p> <p>.DB and .K are the bank registers, allowing programs and data to occupy separate 64K banks on computers with more than 64K of RAM. (The X16 does not use the bank registers, instead using addresses $00 and $01 for banking.)</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#status-flags","title":"Status Flags","text":"<p>The native mode flags are as follows:</p> <p><code>nvmx dizc e</code></p> <p>n = Negative   v = oVerflow   m = Memory width (0=16 bit, 1=8 bit)   x = Index register width (0=16 bit, 1=8 bit)   d = Decimal Mode   i = Interupts Disabled   z = Zero   c = Carry   e = Emulation Mode (0=65C02 mode, 1=65C816 mode)</p> <p>In emulation mode, the m and x flags are always set to 1.</p> <p>Here are the 6502 and 65C02 registers, for comparison:</p> <p><code>nv1b dizc</code></p> <p>n = Negative   v = oVerflow   1 = this bit is always 1   b = brk: set during a BRK instruction interrupt   d = Decimal Mode   i = Interupts Disabled   z = Zero   c = Carry  </p> <p>Note the missing b flag on the 65C816. This is no longer needed in native mode, since the BRK instruction now has its own vector. </p> <p>The e flag can only accessed via the XCE instruction, which swaps Carry and the Emulation flag.</p> <p>The other flags can all be manipulated with SEP and REP, and the various branch instructions (BEQ, BCS, etc) test some of the flags. The rest can only be tested indirectly through the stack.</p> <p>When a BRK or IRQ is triggered in emulation mode, a ghost b flag will be pushed to the stack instead of the x flag. This can be used to test for a BRK vs IRQ in the Interrupt handler.</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#16-bit-mode","title":"16 bit mode","text":"<p>The 65C816 CPU boots up in emulation mode. This locks the register width to 8 bits and locks out certain operations.</p> <p>If you want to use the '816 features, including 16-bit operation, you will need to enable native mode. Clearing e switches the CPU to native mode. However, it's not as simple as just setting a flag. The e flag can only be accessed through the XCE instruction, which swaps the Carry and Emulation flags.</p> <p>To switch to native mode, use the following steps:</p> <pre><code>CLC  ; clear the Carry bit\nXCE  ; swap the Emulation and Carry bit\n</code></pre> <p>To switch back to emulation mode, set the Carry flag and perform an XCE again.</p> <pre><code>SEC  ; Set Carry\nXCE  ; and push the 1 into the Emulation flag.\n</code></pre> <p>Once e is cleared, the m and x flags can be set to 1 or 0 to control the register width.</p> <p>When the m flag is clear, Accumulator operations and memory reads and writes will be 16-bit operations. The CPU reads two bytes at a time with LDA, writes two bytes at a time with STA, and all math involving .A is 16 bits wide.</p> <p>Likewise, whenn x is clear, the .X and .Y index registers are 16 bits wide. INX and INY will now count up to 65535, and indexed instructions like <code>LDA addr,X</code> can now cover 64K.</p> <p>You can use <code>REP #$10</code> to enable 16-bit index registers, and <code>REP #$20</code> to enable 16-bit memory and Accumulator. <code>SEP #$10</code> or <code>SEP #$20</code> will switch back to 8-bit operation. You can also combine the operand and use <code>SEP #$30</code> or  <code>REP #$30</code> to flip both bits at once.</p> <p>And now we reach the 16-bit assembly trap: the actual assembly opcodes are the same, regardless of the x and m flags. This means the assembler needs to track the state of these flags internally, so it can correctly write one or two bytes when assembling immediate mode instructions like LDA #$01.</p> <p>You can help the assembler out by using hints. Different assemblers have different hinting systems, so we will focus on 64TASS and cc65.</p> <p>64TASS accepts <code>.as</code> (.A short) and <code>.al</code> (.A long) to  tell the assembler to store 8 bits or 16 bits in an immediate mode operand. For LDX and LDY, use the <code>.xs</code> and <code>.xl</code> hints.</p> <p>The hints for ca65 are <code>.a8</code>, <code>.a16</code>, <code>.i8</code>, and <code>.i16</code></p> <p>Note that this has no effect on absolute or indirect addressing modes, such as <code>LDA $1234</code> and <code>LDA ($1000)</code>, since the operand for these modes is always 16 bits.</p> <p>To make it easy to remember the modes, just remember that e, m, and x all emulate 65C02 behavior when set.</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#address-modes","title":"Address Modes","text":"<p>The 65C816 now has 24 discinct address modes, although most are veriations on a theme. Make note of the new syntax for Stack relative instructions (,S), the use of brackets for [24 bit indirect] addressing, and the fact that Zero Page has been renamed to Direct Page. This means that $0001 and $01 are now two different addresses (although they would be the same if .DP is set to $00.</p> Mode Syntax Description Immediate #$12 Value is supplied in the program stream Absolute $1234 Data is at this address. Absolute X Indexed $1234,X Address is offset by X. If X=2 this is $1236. Absolute Y Indexed $1234,Y Address is offset by X. If Y=2 this is $1236. Direct $12 Direct Page address. Operand is 1 byte. Direct X Indexed $12,X Address on Direct Page is offset by .X Direct Y Indexed $12,Y Address on Direct Page is offset by .Y Direct Indirect ($12) Value at $12 is a 16-bit address. Direct Indirect Y Indexed ($12),Y Resolve pointer at $12 then offset by Y. Direct X Indexed Indirect ($12,X) Start at $12, offset by X, then read that address. Direct Indirect Long [$12] 24 bit pointer on Direct Page. Direct Indrect Long Y Indexed [$12],Y Resolve address at $12, then offset by Y. Indirect ($1234) Read pointer at $1234 and get data from the resultant address Indirect X Indexed ($1234,X) Read pointer at $1234 offset by X, get data from resultant address Indirect Long [$1234] Pointer is a 24-bit address. Absolute Long $123456 24 bit address. Absolute Indexed Long $123456,X 24 bit address, offset by X. Stack Relative Indexed $12,S Stack relative. Stack Relative Indirect Indexed ($12,S),Y Resolve Pointer at $12, then offset by Y. Accumulator (implied) Operation acts on .A Implied Target is part of the opcode name. Relative Address (8 bit signed) $1234 Branches can only jump by -128 to 127 bytes. 16 bit relative address $1234 BRL can jump by 32K bytes. Block Move #$12,#$34 Operands are the bank numbers for block move/copy."},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#vectors","title":"Vectors","text":"<p>The 65816 has two different sets of interrupt vectors. In emulation mode, the vectors are the same as the 65C02. In native mode (.e = 0), the native vectors are used. This allows you to switch to the desired operation mode, based on the operating mode of your interrupt handlers.</p> <p>The Commander X16 operates mostly in emulation mode, so native mode interrupts on the X16 will switch to emulation mode, then simply call the 8-bit interrupt handlers.</p> <p>The vectors are:</p> Name Emu Native COP FFF4 00FFE4 BRK FFFE 00FFE6 ABORT FFF8 00FFE8 NMI FFFA 00FFEA RESET FFFC IRQ FFFE 00FFEE <p>The 65C02 shares the same interrupt for BRK and IRQ, and the b flag tells the interrupt handler whether to execute a break or interrupt.</p> <p>In emulation mode, the 65C816 pushes a modified version of the flags to the stack. The BRK instruction actually pushes a 1 in bit 4, which can then be tested in the Interrupt Service Routine. In native mode, however, the flags are pushed verbatim, since BRK has its own handler.</p> <p>There is also no native RESET vector, since the CPU always boots to emulation mode. The CPU always starts at the address stored in $FFFC.</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#decimal-mode","title":"Decimal Mode","text":"<p>When the d flag is set, the CPU operates in Decimal mode. In this mode, a byte is treated as two decimal digits, rather than a binary number. As a result, you can easily add, subtract, and display decimal numbers.</p> <p>While in Decimal mode, the lower nibble of a byte contains the 1s digit, and the upper nibble contains the 10s digit. Each nibble can only contain value from 0-9, and addition will wrap from 9 to 0. Subtraction works similarly, wrapping down from 0 to 9.</p> <p>SED enables Decimal mode. At that point, ADC and SBC will perform base-10 addition and subtraction. CLD clears Decimal mode and returns to binary mode.</p> <p>When adding, the Carry bit will be set if the result is 100 or greater. The total result can never exceed 199, so two digits plus Carry is all that is needed to represent values from 0 to 199.</p> <p>If you perform an ADC with the Carry bit set, this will add an extra 1 to the result. </p> <p>Examples</p> Operation .A Result Notes ADC #$01 $09 $10 ADC #$01 $99 $00 Carry is set, indicating 100. <p>When subtracting, the Carry bit operates as a borrow bit, and the sense is inverted: 0 indicates a borrow took place, and 1 means it did not.</p> Operation .A Result Notes SBC #$01 $10 $09 Carry is set, indicating no borrow. SBC #$01 $00 $99 Carry is clear, indicating a borrow. <p>In the second example ($00 - $01), the final result was $99 with a borrow. </p> <p>Note that the n flag tracks the high bit, but two's complement doesn't work as expected in Decimal mode. Instead, we have to use Ten's complement. </p> <p>Simply put, $00 - $01 gives you $99. So when working in signed BCD, any value where the high digit is 5-9 is actually a negative value. To convert negative values to positive values for printing, you would subtract from 99 and add 1.</p> <p>For example: the integer -49 is $51 in BCD. <code>99 - 51 + 1 = 49</code>. You'd print that as <code>-49</code>.</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#instruction-tables","title":"Instruction Tables","text":""},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#instructions-by-opcode","title":"Instructions By Opcode","text":"x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 xA xB xC xD xE xF 0x BRK ORA COP ORA TSB ORA ASL ORA PHP ORA ASL PHD TSB ORA ASL ORA 1x BPL ORA ORA ORA TRB ORA ASL ORA CLC ORA INC TCS TRB ORA ASL ORA 2x JSR AND JSL AND BIT AND ROL AND PLP AND ROL PLD BIT AND ROL AND 3x BMI AND AND AND BIT AND ROL AND SEC AND DEC TSC BIT AND ROL AND 4x RTI EOR WDM EOR MVP EOR LSR EOR PHA EOR LSR PHK JMP EOR LSR EOR 5x BVC EOR EOR EOR MVN EOR LSR EOR CLI EOR PHY TCD JML EOR LSR EOR 6x RTS ADC PER ADC STZ ADC ROR ADC PLA ADC ROR RTL JMP ADC ROR ADC 7x BVS ADC ADC ADC STZ ADC ROR ADC SEI ADC PLY TDC JMP ADC ROR ADC 8x BRA STA BRL STA STY STA STX STA DEY BIT TXA PHB STY STA STX STA 9x BCC STA STA STA STY STA STX STA TYA STA TXS TXY STZ STA STZ STA Ax LDY LDA LDX LDA LDY LDA LDX LDA TAY LDA TAX PLB LDY LDA LDX LDA Bx BCS LDA LDA LDA LDY LDA LDX LDA CLV LDA TSX TYX LDY LDA LDX LDA Cx CPY CMP REP CMP CPY CMP DEC CMP INY CMP DEX WAI CPY CMP DEC CMP Dx BNE CMP CMP CMP PEI CMP DEC CMP CLD CMP PHX STP JML CMP DEC CMP Ex CPX SBC SEP SBC CPX SBC INC SBC INX SBC NOP XBA CPX SBC INC SBC Fx BEQ SBC SBC SBC PEA SBC INC SBC SED SBC PLX XCE JSR SBC INC SBC"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#instructions-by-name","title":"Instructions By Name","text":"ADC AND ASL BCC BCS BEQ BIT BMI BNE BPL BRA BRK BRL BVC BVS CLC CLD CLI CLV CMP COP CPX CPY DEC DEX DEY EOR INC INX INY JMP JML JSL JSR LDA LDX LDY LSR MVN MVP NOP ORA PEA PEI PER PHA PHB PHD PHK PHP PHX PHY PLA PLB PLD PLP PLX PLY REP ROL ROR RTI RTL RTS SBC SEC SED SEI SEP STA STP STX STY STZ TAX TAY TCD TCS TDC TRB TSB TSC TSX TXA TXS TXY TYA TYX WAI WDM XBA XCE"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#instructions-by-category","title":"Instructions By Category","text":"Category Instructions Arithmetic ADC , SBC Boolean AND , EOR , ORA Shift ASL , LSR , ROL , ROR Branch BCC , BCS , BEQ , BMI , BNE , BPL , BRA , BRK , BRL , BVC , BVS Test BIT , TRB , TSB Flags CLC , CLD , CLI , CLV , REP , SEC , SED , SEI , SEP Compare CMP , CPX , CPY Interrupt COP , WAI Inc/Dec DEC , DEX , DEY , INC , INX , INY Flow JMP , JML , JSL , JSR , NOP , RTI , RTL , RTS , WDM Load LDA , LDX , LDY Block Move MVN , MVP Stack PEA , PEI , PER , PHA , PHB , PHD , PHK , PHP , PHX , PHY , PLA , PLB , PLD , PLP , PLX , PLY Store STA , STP , STX , STY , STZ Register Swap TAX , TAY , TCD , TCS , TDC , TSC , TSX , TXA , TXS , TXY , TYA , TYX , XBA , XCE"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#adc","title":"ADC","text":"<p>Add with Carry</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nADC #$20/#$1234  imm        69  3-m 3-m         nv....zc .\nADC $20          dir        65  2   4-m+w       nv....zc .\nADC $20,X        dir,X      75  2   5-m+w       nv....zc .\nADC $20,S        stk,S      63  2   5-m         nv....zc .\nADC $1234        abs        6D  3   5-m         nv....zc .\nADC $1234,X      abs,X      7D  3   6-m-x+x*p   nv....zc .\nADC $1234,Y      abs,Y      79  3   6-m-x+x*p   nv....zc .\nADC $FEDBCA      long       6F  4   6-m         nv....zc .\nADC $FEDCBA,X    long,X     7F  4   6-m         nv....zc .\nADC ($20)        (dir)      72  2   6-m+w       nv....zc .\nADC ($20),Y      (dir),Y    71  2   7-m+w-x+x*p nv....zc .\nADC ($20,X)      (dir,X)    61  2   7-m+w       nv....zc .\nADC ($20,S),Y    (stk,S),Y  73  2   8-m         nv....zc .\nADC [$20]        [dir]      67  2   7-m+w       nv....zc .\nADC [$20],Y      [dir],Y    77  2   7-m+w       nv....zc .\n</code></pre> <p>ADC adds the accumulator (.A), the supplied operand, and the Carry bit (0 or 1). The result is stored in .A.</p> <p>Since Carry is always added in, you should always remember to use CLC (Clear Carry) before performing an addition operation. When adding larger numbers (16, 24, 32, or more bits), you can use the Carry flag to chain additions.</p> <p>Here is an example of a 16-bit add, when in 8 bit mode:</p> <pre><code>CLC\nLDA Addend1\nADC Addend2\nSTA Result1\nLDA Addend1+1  ; Reads the high byte of the addend\nADC Addend2+1  ; (the +1 refers to the *address* of Addend, not the value)\nSTA Result1+1  ;\ndone:\n; the final result is at Result1\n</code></pre> <p>Flags:</p> <ul> <li>n is set when the high bit of .A is set. This indicates a negative number when using Two's Complement signed values.</li> <li>v (overflow) is set when the sum exceeds the maximum signed value for .A. (More on that below). * n is set when the high bit is 1.</li> <li>z is set when the result is zero. This is useful for loop counters and can be tested with BEQ and BNE. (BEQ and BNE test the Zero bit, which is also the \"equal\" bit when performing subtraction or Compare operations.)</li> <li>c is set when the unsigned result exceeds the register's capacity (255 or 65535).</li> </ul>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#overflow-vs-carry","title":"Overflow vs Carry","text":"<p>The CPU detects addition that goes past the 7 or 15 bit boundary of a signed number, as well as the 8 bit boundary of an unsigned number.</p> <p>In 8-bit mode, when you add two positive numbers that result in a sum higher than 127 or add two negative numbers that result in a sum below -128, you will get a signed overflow, and the v flag will be set.</p> <p>When the sum of the two numbers exceeeds 255 or 65535, then the Carry flag will be set. This bit can be added to the next higher byte with ADC #0.</p> <pre><code>CLC\nLDA #$7F\nADC #$10\nBRK\n</code></pre> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#and","title":"AND","text":"<p>Boolean AND</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nAND #$20/#$1234  imm        29  3-m 3-m         n.....z. .\nAND $20          dir        25  2   4-m+w       n.....z. .\nAND $20,X        dir,X      35  2   5-m+w       n.....z. .\nAND $20,S        stk,S      23  2   5-m         n.....z. .\nAND $1234        abs        2D  3   5-m         n.....z. .\nAND $1234,X      abs,X      3D  3   6-m-x+x*p   n.....z. .\nAND $1234,Y      abs,Y      39  3   6-m-x+x*p   n.....z. .\nAND $FEDBCA      long       2F  4   6-m         n.....z. .\nAND $FEDCBA,X    long,X     3F  4   6-m         n.....z. .\nAND ($20)        (dir)      32  2   6-m+w       n.....z. .\nAND ($20),Y      (dir),Y    31  2   7-m+w-x+x*p n.....z. .\nAND ($20,X)      (dir,X)    21  2   7-m+w       n.....z. .\nAND ($20,S),Y    (stk,S),Y  33  2   8-m         n.....z. .\nAND [$20]        [dir]      27  2   7-m+w       n.....z. .\nAND [$20],Y      [dir],Y    37  2   7-m+w       n.....z. .\n</code></pre> <p>Perform a logical AND operation with the operand and .A</p> <p>AND compares each bit of the operands and sets the result bit to 1 only when the matching bit of each operand is 1.</p> <p>AND is useful for reading a group of bits from a byte. For example, <code>AND #$0F</code> will clear the top nibble of .A, returning the bits from the lower nibble.</p> <p>Truth table for AND:</p> <pre><code>Operand 1: 1100\nOperand 2: 1010\nResult:    1000\n</code></pre> <p>Flags:</p> <ul> <li>n is set when the high bit of the result is 1</li> <li>z is set when the result is Zero</li> </ul> <p>See also: ORA, EOR</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#asl","title":"ASL","text":"<p>Arithmetic Shift Left</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nASL              acc        0A  1   2           n.....zc .\nASL $20          dir        06  2   7-2*m+w     n.....zc .\nASL $20,X        dir,X      16  2   8-2*m+w     n.....zc .\nASL $1234        abs        0E  3   8-2*m       n.....zc .\nASL $1234,X      abs,X      1E  3   9-2*m       n.....zc .\n</code></pre> <p>ASL shifts the target left one place. It shifts the high bit of the operand into the Carry flag and a zero into the low bit.</p> <p>See also: LSR, ROL, ROR</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#bcc","title":"BCC","text":"<p>Branch on Carry Clear</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nBCC LABEL        rel8       90  2   2+t+t*e*p   ........ .\n</code></pre> <p>Jumps to the target address when the Carry flag (c) is Zero.</p> <p>BCC can be used after add, subtract, or compare operations. After a compare, c is as follows:</p> <ul> <li>When A &lt; Operand, c is clear.</li> <li>When A &gt;= Operand, c is set.</li> </ul> <p>A branch operation uses an 8 bit signed value internally, starting from the instruction after the branch. So the branch destination can be 126 bytes before or 128 bytes after the branch instruction.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#bcs","title":"BCS","text":"<p>Branch on Carry Set</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nBCS LABEL        rel8       B0  2   2+t+t*e*p   ........ .\n</code></pre> <p>Jumps to the target address when the Carry flag is 1.</p> <p>BCC can be used after add, subtract, or compare operations. After a compare, c is as follows:</p> <ul> <li>When A &lt; Operand, c is clear.</li> <li>When A &gt;= Operand, c is set.</li> </ul> <p>A branch operation uses an 8 bit signed value internally, starting from the instruction after the branch. So the branch destination can be 126 bytes before or 128 bytes after the branch instruction.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#beq","title":"BEQ","text":"<p>Branch on Equal.</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nBEQ LABEL        rel8       F0  2   2+t+t*e*p   ........ .\n</code></pre> <p>Jumps to the target address when the Zero flag is 1. While this is most commonly used after a compare (see CMP ) operation, it's also useful to test if a number is zero after a Load operation, or to test if a loop is complete after a DEC operation.</p> <p>A branch operation uses an 8 bit signed value internally, starting from the instruction after the branch. So the branch destination can be 126 bytes before or 128 bytes after the branch instruction.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#bit","title":"BIT","text":"<p>Bit Test</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nBIT #$20/#$1234  imm        89  3-m 3-m         ......z. .\nBIT $20          dir        24  2   4-m+w       nv....z. .\nBIT $20,X        dir,X      34  2   5-m+w       nv....z. .\nBIT $1234        abs        2C  3   5-m         nv....z. .\nBIT $1234,X      abs,X      3C  3   6-m-x+x*p   nv....z. .\n</code></pre> <p>Tests the operand against the Accumulator. The ALU does an AND operation internally, setting z if the result is 0.</p> <p>When m=1, n and v are set based on the value of bits 7 and 6 in memory.</p> <p>When m=0, n and v are set based on the value of bits 15 and 14 in memory.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#bmi","title":"BMI","text":"<p>Branch on Minus</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nBMI LABEL        rel8       30  2   2+t+t*e*p   ........ .\n</code></pre> <p>Jumps to the specified address when the Negative flag (n) is set.</p> <p>n is set when ALU operations result in a negative number, or when the high bit of an ALU operation is 1.</p> <p>A branch operation uses an 8 bit signed value internally, starting from the instruction after the branch. So the branch destination can be 126 bytes before or 128 bytes after the branch instruction.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#bne","title":"BNE","text":"<p>Branch on Not Equal.</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nBNE LABEL        rel8       D0  2   2+t+t*e*p   ........ .\n</code></pre> <p>Jumps to the target address when the Zero flag is 0. While this is most commonly used after a compare (CMP) operation, it's also useful to test if a number is zero after a Load operation, or to test if a loop is complete after a DEC operation.</p> <p>A branch operation uses an 8 bit signed value internally, starting from the instruction after the branch. So the branch destination can be 126 bytes before or 128 bytes after the branch instruction.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#bpl","title":"BPL","text":"<p>Branch on Plus</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nBPL LABEL        rel8       10  2   2+t+t*e*p   ........ .\n</code></pre> <p>Jumps to the specified address when the Negative flag (n) is clear.</p> <p>n is clear when ALU operations result in a positive number, or when the high bit of an ALU operation is 0.</p> <p>A branch operation uses an 8 bit signed value internally, starting from the instruction after the branch. So the branch destination can be 126 bytes before or 128 bytes after the branch instruction.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#bra","title":"BRA","text":"<p>Branch Always</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nBRA LABEL        rel8       80  2   3+e*p       ........ .\n</code></pre> <p>Jumps to the specified address.</p> <p>A branch operation uses an 8 bit signed value internally, starting from the instruction after the branch. So the branch destination can be 126 bytes before or 128 bytes after the branch instruction.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#brk","title":"BRK","text":"<p>Break</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nBRK #$20         imm        00  1   8-e         ....di.. .\n</code></pre> <p>Perform a break interrupt. The exact behavior changes slightly, based on whether the CPU is in native or emulation mode. (e is 1 in emulation mode.)</p> <p>Since the Program Counter is incremented</p> <p>In emulation mode:</p> <ol> <li>.PC (Program Counter) is incremented by 1 byte.</li> <li>If the CPU is in Native mode, the Program Bank is pushed to the stack.</li> <li>.PC is pushed onto the stack.</li> <li>.P (flags) is pushed to the stack. (the b bit, bit 4, is set to 1.)</li> <li>The d (Decimal) flag is cleared, forcing the CPU into binary mode.</li> <li>The CPU reads the address from the IRQ vector at $FFFE and jumps there.</li> </ol> <p>An IRQ is similar, except that IRQ clears bit 4 (b) during the push to the stack. So an Interrupt Service Routine can read the last byte on the stack to determine whether an emulation-mode interrupt is a BRK or IRQ.</p> <p>On the X16, the IRQ services the keyboard, mouse, game pads, updates the clock, blinks the cursor, and updates the LEDs.</p> <p>In native mode:</p> <ol> <li>.PC is incremented by 1 byte.</li> <li>.X (Program Bank) is pushed the stack</li> <li>.PC is pushed to the stack</li> <li>.P (flags) is pushed to the stack</li> <li>The d (Decimal) flag is cleared, forcing the CPU into binary mode.</li> <li>The CPU reads the address from the BRK vector at $00FFE6 and jumps there.</li> </ol> <p>Since the Native Mode has a distinct BRK vector, you do not need to query the stack to dispatch a BRK vs IRQ interrupt. You can just handle each immediately.</p> <p>The RTI instruction is used to return from an interrupt. It pulls the values back off the stack (this varies, depending on the CPU mode) and returns to the pushed PC address.</p> <p>RTI</p> <p>See the Vectors section for the break vector.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#brl","title":"BRL","text":"<p>Branch Long</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nBRL LABEL        rel16      82  3   4           ........ .\n</code></pre> <p>BRL is a 16 bit branch instruction, meaning assembly creates a relative address. Unlike BRA and the other branch instructions, BRL uses a 16-bit address, which allows for an offset of -32768 to 32767 bytes away from the instruction following The BRL.</p> <p>Of course, due to wrapping of the 64K bank, this means that the entire 64K region is accessible. Values below 0 will simply wrap around and start from $FFFF, and values above $FFFF will wrap around to 0.</p> <p>Since this is a relatve branch, that means code assembled with BRL, instead of JMP, can be moved around in memory without the need for re-assembly.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#bvc","title":"BVC","text":"<p>Branch on Overflow Clear</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nBVC LABEL        rel8       50  2   2+t+t*e*p   ........ .\n</code></pre> <p>Branches to the specified address when the Overflow bit is 0.</p> <p>A branch operation uses an 8 bit signed value internally, starting from the instruction after the branch. So the branch destination can be 126 bytes before or 128 bytes after the branch instruction.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#bvs","title":"BVS","text":"<p>Branch on Overflow Set</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nBVS LABEL        rel8       70  2   2+t+t*e*p   ........ .\n</code></pre> <p>Branches to the specified address when the Overflow bit is 1.</p> <p>A branch operation uses an 8 bit signed value internally, starting from the instruction after the branch. So the branch destination can be 126 bytes before or 128 bytes after the branch instruction.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#clc","title":"CLC","text":"<p>Clear Carry</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nCLC              imp        18  1   2           .......c .\n</code></pre> <p>Clears the Carry bit in the flags. You'll usually use CLC before addition and SEC before subtraction. You'll also want to use CLC or SEC appropriately before calling certain KERNAL routines that use the c bit as an input value.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#cld","title":"CLD","text":"<p>Clear Decimal</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nCLD              imp        D8  1   2           ....d... .\n</code></pre> <p>Clears the Decimal flag, returning the CPU to 8-bit or 16-bit binary operation.</p> <p>When Decimal is set, the CPU will store numbers in Binary Coded Decimal format. Clearing this flag restores the CPU to binary operation. See Decimal Mode for more information.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#cli","title":"CLI","text":"<p>Clear Interrupt Flag</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nCLI              imp        58  1   2           .....i.. .\n</code></pre> <p>Clears the i flag, allowing interrupts to be handled.</p> <p>The i flag operates somewhat non-intuitively: when i is set (1), IRQ is suppressed. When i is clear (0), interrupts are handled. So CLI allows interrupts to be handled.</p> <p>See [BRK}(#brk) for more information on interrupt handling.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#clv","title":"CLV","text":"<p>Clear Overflow</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nCLV              imp        B8  1   2           .v...... .\n</code></pre> <p>Overflow is set when the result of an addition operation goes up through $80 or subtraction goes down through $80.</p> <p>CLV clears the overflow flag. There is no \"SEV\" instruction, but overflow can be set with SEP #$40.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#cmp","title":"CMP","text":"<p>Compare</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nCMP #$20/#$1234  imm        C9  3-m 3-m         n.....zc .\nCMP $20          dir        C5  2   4-m+w       n.....zc .\nCMP $20,X        dir,X      D5  2   5-m+w       n.....zc .\nCMP $20,S        stk,S      C3  2   5-m         n.....zc .\nCMP $1234        abs        CD  3   5-m         n.....zc .\nCMP $1234,X      abs,X      DD  3   6-m-x+x*p   n.....zc .\nCMP $1234,Y      abs,Y      D9  3   6-m-x+x*p   n.....zc .\nCMP $FEDBCA      long       CF  4   6-m         n.....zc .\nCMP $FEDCBA,X    long,X     DF  4   6-m         n.....zc .\nCMP ($20)        (dir)      D2  2   6-m+w       n.....zc .\nCMP ($20),Y      (dir),Y    D1  2   7-m+w-x+x*p n.....zc .\nCMP ($20,X)      (dir,X)    C1  2   7-m+w       n.....zc .\nCMP ($20,S),Y    (stk,S),Y  D3  2   8-m         n.....zc .\nCMP [$20]        [dir]      C7  2   7-m+w       n.....zc .\nCMP [$20],Y      [dir],Y    D7  2   7-m+w       n.....zc .\n</code></pre> <p>Compares the Accumulator with memory. This performs a subtract operation between .A and the operand and sets the n, z, and c flags based on the result. The Accumulator is not altered.</p> <ul> <li>WHen A = Operand, z is set.</li> <li>When A &lt; Operand, c is clear.</li> <li>When A &lt;&gt; Operand, z is clear.</li> <li>When A &gt;= Operand, c is set.</li> </ul> <p>You can use the Branch instructions (BEQ, BNE, BPL, BMI, BCC, BCS) to jump to different parts of your program based on the results of CMP. Here are some BASIC comparisons and the equivalent assembly language steps.</p> <pre><code>; IF A = N THEN 1000\nCMP N\nBEQ $1000\n\n; IF A &lt;&gt; N THEN 1000\nCMP N\nBNE $1000\n\n; IF A &lt; N THEN 1000\nCMP N\nBCC $1000\n\n; IF A &gt;= N THEN 1000\nCMP N\nBCS $1000\n\n; IF A &gt; N THEN 1000\nCMP N\nBEQ skip\nBCS $1000\nskip:\n\n; IF A &lt;= N THEN 1000\nCMP N\nBEQ $1000\nBCC $1000\n</code></pre> <p>As you can see, some comparisons will require two distinct branch instructions.</p> <p>Also, note that the Branch instructions (except BRL) require that the target address be within 128 bytes of the instruciton after the branch. If you need to branch further, the usual method is to invert the branch instruction and use a JMP to take the branch.</p> <p>For example, the following two branches behave the same, but the second one can jump to any address on the computer, whereas the first can only jump -128/+127 bytes away:</p> <pre><code>short_branch:\nCMP N\nBEQ target\n\nlonger_branch:\nCMP N\nBNE skip\nJMP target\nskip:\n</code></pre> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#cop","title":"COP","text":"<p>COP interrupt.</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nCOP #$20         imm        02  2   8-e         ....di.. .\n</code></pre> <p>COP is similar to BRK, but uses the FFE4 or FFF4 vectors. The intent is to COP is to switch to a Co-Processor, but this can be used for any purpose on the X16 (including triggering a DMA controller, if that's what you want to do.)</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#cpx","title":"CPX","text":"<p>Compare X Register</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nCPX #$20/#$1234  imm        E0  3-x 3-x         n.....zc .\nCPX $20          dir        E4  2   4-x+w       n.....zc .\nCPX $1234        abs        EC  3   5-x         n.....zc .\n</code></pre> <p>This compares the X register to an operand and sets the flags accordingly.</p> <p>See CMP for more information.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#cpy","title":"CPY","text":"<p>Compare Y Register</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nCPY #$20/#$1234  imm        C0  3-x 3-x         n.....zc .\nCPY $20          dir        C4  2   4-x+w       n.....zc .\nCPY $1234        abs        CC  3   5-x         n.....zc .\n</code></pre> <p>This compares the Y register to an operand and sets the flags accordingly.</p> <p>See CMP for more information.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#dec","title":"DEC","text":"<p>Decrement</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nDEC              acc        3A  1   2           n.....z. .\nDEC $20          dir        C6  2   7-2*m+w     n.....z. .\nDEC $20,X        dir,X      D6  2   8-2*m+w     n.....z. .\nDEC $1234        abs        CE  3   8-2*m       n.....z. .\nDEC $1234,X      abs,X      DE  3   9-2*m       n.....z. .\n</code></pre> <p>Decrement .A or memory. The z flag is set when the value reaches zero. This makes DEC, DEX, and DEY useful as a loop counter, by setting the number of iterations, the repeated operation, then DEX followed by BNE.</p> <p>z is set when the counter reaches zero. n is set when the high bit gets set.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#dex","title":"DEX","text":"<p>Decrement .X</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nDEX              imp        CA  1   2           n.....z. .\n</code></pre> <p>Decrement .X The z flag is set when the value reaches zero. This makes DEC, DEX, and DEY useful as a loop counter, by setting the number of iterations, the repeated operation, then DEX followed by BNE.</p> <p>z is set when the counter reaches zero. n is set when the high bit gets set.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#dey","title":"DEY","text":"<p>Decrement .Y</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nDEY              imp        88  1   2           n.....z. .\n</code></pre> <p>Decrement .X The z flag is set when the value reaches zero. This makes DEC, DEX, and DEY useful as a loop counter, by setting the number of iterations, the repeated operation, then DEX followed by BNE.</p> <p>z is set when the counter reaches zero. n is set when the high bit gets set.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#eor","title":"EOR","text":"<p>Exclusive OR</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nEOR #$20/#$1234  imm        49  3-m 3-m         n.....z. .\nEOR $20          dir        45  2   4-m+w       n.....z. .\nEOR $20,X        dir,X      55  2   5-m+w       n.....z. .\nEOR $20,S        stk,S      43  2   5-m         n.....z. .\nEOR $1234        abs        4D  3   5-m         n.....z. .\nEOR $1234,X      abs,X      5D  3   6-m-x+x*p   n.....z. .\nEOR $1234,Y      abs,Y      59  3   6-m-x+x*p   n.....z. .\nEOR $FEDBCA      long       4F  4   6-m         n.....z. .\nEOR $FEDCBA,X    long,X     5F  4   6-m         n.....z. .\nEOR ($20)        (dir)      52  2   6-m+w       n.....z. .\nEOR ($20),Y      (dir),Y    51  2   7-m+w-x+x*p n.....z. .\nEOR ($20,X)      (dir,X)    41  2   7-m+w       n.....z. .\nEOR ($20,S),Y    (stk,S),Y  53  2   8-m         n.....z. .\nEOR [$20]        [dir]      47  2   7-m+w       n.....z. .\nEOR [$20],Y      [dir],Y    57  2   7-m+w       n.....z. .\n</code></pre> <p>Perform an Exclusive OR operation with the operand and .A</p> <p>EOR compares each bit of the operands and sets the result bit to 1 if one of the two bits is 1. If both bits are 1, the result is 0. If both bits are 0, the result is 0.</p> <p>EOR is useful for inverting the bits in a byte. <code>EOR #$FF</code> will flip an entire byte. (This will always flip the low byte in .A. To flip both bytes when m is 0, you would use <code>EOR #$FFFF</code>.)</p> <p>Truth table for EOR:</p> <pre><code>Operand 1: 1100\nOperand 2: 1010\nResult:    0110\n</code></pre> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#inc","title":"INC","text":"<p>Increment</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nINC              acc        1A  1   2           n.....z. .\nINC $20          dir        E6  2   7-2*m+w     n.....z. .\nINC $20,X        dir,X      F6  2   8-2*m+w     n.....z. .\nINC $1234        abs        EE  3   8-2*m       n.....z. .\nINC $1234,X      abs,X      FE  3   9-2*m       n.....z. .\n</code></pre> <p>Increment .A or memory</p> <p>Adds 1 to the value in .A or the specified memory address. The n and z flags are set, based on the resultant value.</p> <p>INC is useful for reading strings and operating on large areas of memory, especially with indirect and indexed addressing modes.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#inx","title":"INX","text":"<p>Increment .X</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nINX              imp        E8  1   2           n.....z. .\n</code></pre> <p>Increment the X register.</p> <p>The following routine prints a null-terminated string (a should be 1.)</p> <pre><code>LDX #$0\nloop:\nLDA string_addr, X\nBEQ done\nJSR CHROUT\nINX\nBRA loop\ndone:\n</code></pre> <p>See [INC}(#inc)</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#iny","title":"INY","text":"<p>Increment .Y</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nINY              imp        C8  1   2           n.....z. .\n</code></pre> <p>Increment the Y register.</p> <p>See [INC}(#inc)</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#jmp","title":"JMP","text":"<p>Jump</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nJMP $2034        abs        4C  3   3           ........ .\nJMP ($2034)      (abs)      6C  3   5           ........ .\nJMP ($2034,X)    (abs,X)    7C  3   6           ........ .\n</code></pre> <p>Jump to a differnent address in memory, continuing program execution at the specified address.</p> <p>Instructions like <code>JMP ($1234,X)</code> make it possible to branch to a selectable subroutine by setting X to the indesx into the vector table.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#jml","title":"JML","text":"<p>Jump Long</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nJML $FEDCBA      long       5C  4   4           ........ .\nJMP [$2034]      [abs]      DC  3   6           ........ .\n</code></pre> <p>Jump to a differnent address in memory, continuing program execution at the specified address. JML accepts a 24-bit address, allowing the program to change program banks.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#jsl","title":"JSL","text":"<p>Jmp to Subroutine Long</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nJSL $203456      long       22  4   8           ........ .\n</code></pre> <p>This is a 24-bit instruction, which can jump to a subroutine located in another program bank.</p> <p>Use the RTL instruction to return to the instruction following the JSL.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#jsr","title":"JSR","text":"<p>Jump to Subroutine</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nJSR $2034        abs        20  3   6           ........ .\nJSR ($2034,X)    (abs,X)    FC  3   8           ........ .\n</code></pre> <p>Jumps to a new operating address in memory. Also pushes the return address to the stack, allowing an RTS insruction to pick up at the address following the JSR.</p> <p>The RTS instruction returns to the instruction following JSR.</p> <p>The actual address pushed to the stack is the before the next instruction. This means that the CPU still needs to increment the PC by 1 step during the RTS.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#lda","title":"LDA","text":"<p>Load Accumulator</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nLDA #$20/#$1234  imm        A9  3-m 3-m         n.....z. .\nLDA $20          dir        A5  2   4-m+w       n.....z. .\nLDA $20,X        dir,X      B5  2   5-m+w       n.....z. .\nLDA $20,S        stk,S      A3  2   5-m         n.....z. .\nLDA $1234        abs        AD  3   5-m         n.....z. .\nLDA $1234,X      abs,X      BD  3   6-m-x+x*p   n.....z. .\nLDA $1234,Y      abs,Y      B9  3   6-m-x+x*p   n.....z. .\nLDA $FEDBCA      long       AF  4   6-m         n.....z. .\nLDA $FEDCBA,X    long,X     BF  4   6-m         n.....z. .\nLDA ($20)        (dir)      B2  2   6-m+w       n.....z. .\nLDA ($20),Y      (dir),Y    B1  2   7-m+w-x+x*p n.....z. .\nLDA ($20,X)      (dir,X)    A1  2   7-m+w       n.....z. .\nLDA ($20,S),Y    (stk,S),Y  B3  2   8-m         n.....z. .\nLDA [$20]        [dir]      A7  2   7-m+w       n.....z. .\nLDA [$20],Y      [dir],Y    B7  2   7-m+w       n.....z. .\n</code></pre> <p>Reads a value from memory into .A. This sets n and z appropriately, allowing you to use BMI, BPL, BEQ, and BNE to act based on the value being read.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#ldx","title":"LDX","text":"<p>Load X Register</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nLDX #$20/#$1234  imm        A2  3-x 3-x         n.....z. .\nLDX $20          dir        A6  2   4-x+w       n.....z. .\nLDX $20,Y        dir,Y      B6  2   5-x+w       n.....z. .\nLDX $1234        abs        AE  3   5-x         n.....z. .\nLDX $1234,Y      abs,Y      BE  3   6-2*x+x*p   n.....z. .\n</code></pre> <p>Read a value into .X. This sets n and z appropriately, allowing you to use BMI, BPL, BEQ, and BNE to act based on the value being read.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#ldy","title":"LDY","text":"<p>Load X Register</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nLDY #$20/#$1234  imm        A0  3-x 3-x         n.....z. .\nLDY $20          dir        A4  2   4-x+w       n.....z. .\nLDY $20,X        dir,X      B4  2   5-x+w       n.....z. .\nLDY $1234        abs        AC  3   5-x         n.....z. .\nLDY $1234,X      abs,X      BC  3   6-2*x+x*p   n.....z. .\n</code></pre> <p>Read a value into .Y. This sets n and z appropriately, allowing you to use BMI, BPL, BEQ, and BNE to act based on the value being read.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#lsr","title":"LSR","text":"<p>Logical Shift Right</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nLSR              acc        4A  1   2           n.....zc .\nLSR $20          dir        46  2   7-2*m+w     n.....zc .\nLSR $20,X        dir,X      56  2   8-2*m+w     n.....zc .\nLSR $1234        abs        4E  3   8-2*m       n.....zc .\nLSR $1234,X      abs,X      5E  3   9-2*m       n.....zc .\n</code></pre> <p>Shifts all bits to the right by one position.</p> <p>Bit 0 is shifted into Carry.; 0 shifted into the high bit (7 or 15, depending on the m flag.)</p> <p>Similar instructions:; ASL is the opposite instruction, shifting to the left.; ROR rotates bit 0 through Carry to bit 7.;</p> <p>+p Adds a cycle if ,X crosses a page boundary.; +c New for the 65C02;</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#mvn","title":"MVN","text":"<p>Block Copy/Move Negative</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nMVN #$20,#$34    src,dest   54  3   7           ........ .\n</code></pre> <p>This performs a block copy. Use MVN when the source and destination ranges overlap and dest &lt; source.</p> <p>Copying anything other than page zero requires 16-bit index registers, so it's wise to clear m and x with <code>REP #$30</code>.</p> <ul> <li>Set .X to the source address</li> <li>Set .Y to the destination address</li> <li>Set .A to size-1</li> <li>MVN #source_bank, #dest_bank</li> </ul> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#mvp","title":"MVP","text":"<p>Block Copy/Move Positive</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nMVP #$20,#$34    src,dest   44  3   7           ........ .\n</code></pre> <p>This performs a block copy. Use MVP when the source and destination ranges overlap and dest &gt; source.</p> <p>Copying anything other than page zero requires 16-bit index registers, so it's wise to clear m and x with <code>REP #$30</code>.</p> <ul> <li>Set .X to the source_address + size - 1</li> <li>Set .Y to the destination_address</li> <li>Set .A to size-1</li> <li>MVP #source_bank, #dest_bank</li> </ul> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#nop","title":"NOP","text":"<p>No Operation</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nNOP              imp        EA  1   2           ........ .\n</code></pre> <p>The CPU performs no operation. This is useful when blocking out instructions, or reserving space for later use.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#ora","title":"ORA","text":"<p>Boolean OR</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nORA #$20/#$1234  imm        09  3-m 3-m         n.....z. .\nORA $20          dir        05  2   4-m+w       n.....z. .\nORA $20,X        dir,X      15  2   5-m+w       n.....z. .\nORA $20,S        stk,S      03  2   5-m         n.....z. .\nORA $1234        abs        0D  3   5-m         n.....z. .\nORA $1234,X      abs,X      1D  3   6-m-x+x*p   n.....z. .\nORA $1234,Y      abs,Y      19  3   6-m-x+x*p   n.....z. .\nORA $FEDBCA      long       0F  4   6-m         n.....z. .\nORA $FEDCBA,X    long,X     1F  4   6-m         n.....z. .\nORA ($20)        (dir)      12  2   6-m+w       n.....z. .\nORA ($20),Y      (dir),Y    11  2   7-m+w-x+x*p n.....z. .\nORA ($20,X)      (dir,X)    01  2   7-m+w       n.....z. .\nORA ($20,S),Y    (stk,S),Y  13  2   8-m         n.....z. .\nORA [$20]        [dir]      07  2   7-m+w       n.....z. .\nORA [$20],Y      [dir],Y    17  2   7-m+w       n.....z. .\n</code></pre> <p>Perform a Boolean OR operation with the operand and .A</p> <p>ORA compares each bit of the operands and sets the result bit to 1 if either or both of the two bits is 1. If both bits are 0, the result is 0.</p> <p>ORA is useful for setting a specific bit in a byte.</p> <p>Truth table for ORA:</p> <pre><code>Operand 1: 1100\nOperand 2: 1010\nResult:    1110\n</code></pre> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#pea","title":"PEA","text":"<p>Push Absolute</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nPEA $2034        abs        F4  3   5           ........ .\n</code></pre> <p>PEA, PEI, and PER push values to the stack without affecting registers.</p> <p>PEA pushes the operand value onto the stack. The literal operand is used, rather than an address.</p> <p>This seems inconsistent with the absolute address syntax, as PEA and PEI follow their own syntax rules.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#pei","title":"PEI","text":"<p>Push Effecive Indirect Address</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nPEI ($20)        (dir)      D4  2   6+w         ........ .\n</code></pre> <p>PEI takes a pointer as an operand. The value written to the stack is the two bytes at the supplied address.</p> <p>Example: <pre><code>; data at $20 is $1234\nPEI ($20)\n; pushes $1234 onto the stack.\n</code></pre></p> <p>The written form of PEI is inconsistent with the usual indirect mode syntax, as PEI and PEA follow their own syntax rules.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#per","title":"PER","text":"<p>Push Effective PC Relative Indirect Address</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nPER LABEL        rel16      62  3   6           ........ .\n</code></pre> <p>PER pushes the address relative to the program counter. This allows you to mark the current executing location and push that to the stack.</p> <p>When used in conjunctin with BRL, PER can form a reloatable JSR instruction.</p> <p>Consider the following ca65 macro:</p> <pre><code>.macro bsr addr\nper .loword(:+ - 1)\nbrl addr\n:\n.endmacro\n</code></pre> <p>This gets the address following the BRL instruction and pushes that to the stack. See JSR to understand why the -1 is required.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#pha","title":"PHA","text":"<p>Push Accumulator</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nPHA              imp        48  1   4-m         ........ .\n</code></pre> <p>Pushes the Accumulator to the stack. This will push 1 byte when m is 1 and two bytes when m is 0 (16-bit memory/.A mode.)</p> <p>An 8-bit stack push writes data at the Stack Pointer address, then moves SP down by 1 byte.</p> <p>A 16-bit push writes the high byte first, decrements the PC, then writes the low byte, and decrements the PC again.</p> <p>In Emulation mode, the Stack Pointer will always be an address in the $100-$1FF range, so there is only room for 256 bytes on the stack. In native mode, the stack can be anywhere in the first 64KB of RAM.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#phb","title":"PHB","text":"<p>Push Data Bank register.</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nPHB              imp        8B  1   3           ........ .\n</code></pre> <p>The data bank register sets the top 8 bits used when reading data with LDA, LDX, and LDY.</p> <p>This is always an 8-bit operation.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#phd","title":"PHD","text":"<p>Push Direct Page</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nPHD              imp        0B  1   4           ........ .\n</code></pre> <p>Pushes the 16-bit Direct Page register to the stack. This is useful for preserving the location of .D before relocating Direct Page for another use (such as an operating system routine.)</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#phk","title":"PHK","text":"<p>Push Program Bank</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nPHK              imp        4B  1   3           ........ .\n</code></pre> <p>Pushes the Program Bank register to the stack. The Program Bank is the top 8 bits of the 24-bit Program Counter address.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#php","title":"PHP","text":"<p>Push Program Status (Flags)</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nPHP              imp        08  1   3           ........ .\n</code></pre> <p>The CPU writes the flags in the order <code>nvmx dizc</code>. (e does not get written to the stack.)</p> <p>Note: the 6502 and 65C02 use bit 4 (x on the '816) for the Break flag. While b does get written to the stack in a BRK operation, bit 4 in .P always reflects the state of the 8-bit-index flag. Since the flags differ slightly in behavior, make sure your Interrupt handler code reads from the stack, not the .P bits, when dispatching a IRQ/BRK interrupt.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#phx","title":"PHX","text":"<p>Push X Register</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nPHX              imp        DA  1   4-x         ........ .\n</code></pre> <p>Pushes the X register to the stack. This will push 1 byte when x is 1 and two bytes when x is 0 (16-bit index mode.)</p> <p>An 8-bit stack push writes data at the Stack Pointer address, then moves SP down by 1 byte. A 16-bit stack push moves the stack pointer down 2 bytes.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#phy","title":"PHY","text":"<p>Push Y Register</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nPHY              imp        5A  1   4-x         ........ .\n</code></pre> <p>Pushes the Y register to the stack. This will push 1 byte when y is 1 and two bytes when y is 0 (16-bit index mode.)</p> <p>An 8-bit stack push writes data at the Stack Pointer address, then moves SP down by 1 byte. A 16-bit stack push moves the stack pointer down 2 bytes.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#pla","title":"PLA","text":"<p>Pull Accumulator</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nPLA              imp        68  1   5-m         n.....z. .\n</code></pre> <p>Pulls the Accumulator from the stack.</p> <p>In the opposite of PHA, the PLA instruction reads the current value from the stack and increments the stack pointer by 1 or 2 bytes.</p> <p>The number of bytes read is based on the value of the m flag.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#plb","title":"PLB","text":"<p>Pull Data Bank Register</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nPLB              imp        AB  1   4           n.....z. .\n</code></pre> <p>Pull the Data Bank register from the stack.</p> <p>In the opposite of PHB, the PLB instruction reads the current value from the stack and increments the stack pointer by 1 byte.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#pld","title":"PLD","text":"<p>Pull Direct Page Register</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nPLD              imp        2B  1   5           n.....z. .\n</code></pre> <p>This pulls a word from the stack and loads it into the Direct Page register.</p> <p>That value can be placed on the stack in several ways, such as PHA, PHX, or PEA.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#plp","title":"PLP","text":"<p>Pull Prgram Status Byte (flags)</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nPLP              imp        28  1   4           nvmxdizc .\n</code></pre> <p>This reads the flags back from the stack. Since the flags affect the state of the m and x register-width flags, this should be performed before a PLA, PLX, or PLY operation.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#plx","title":"PLX","text":"<p>Pull X Register</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nPLX              imp        FA  1   5-x         n.....z. .\n</code></pre> <p>Pulls the X Register from the stack.</p> <p>In the opposite of PHX, the PLX instruction reads the current value from the stack and increments the stack pointer by 1 or 2 bytes.</p> <p>The number of bytes read is based on the value of the x flag.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#ply","title":"PLY","text":"<p>Pull Y Register</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nPLY              imp        7A  1   5-x         n.....z. .\n</code></pre> <p>Pulls the Y Register from the stack.</p> <p>In the opposite of PHY, the PLY instruction reads the current value from the stack and increments the stack pointer by 1 or 2 bytes.</p> <p>The number of bytes read is based on the value of the x flag.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#rep","title":"REP","text":"<p>Reset Program Status Bit</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nREP #$20/#$1234  imm        C2  2   3           nvmxdizc .\n</code></pre> <p>This clears (to 0) flags in the Program Status Byte. The 1 bits in the will be cleared in the flags, so REP #$30 will set the a and x bits low.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#rol","title":"ROL","text":"<p>Rotate Left</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nROL              acc        2A  1   2           n.....zc .\nROL $20          dir        26  2   7-2*m+w     n.....zc .\nROL $20,X        dir,X      36  2   8-2*m+w     n.....zc .\nROL $1234        abs        2E  3   8-2*m       n.....zc .\nROL $1234,X      abs,X      3E  3   9-2*m       n.....zc .\n</code></pre> <p>Shifts bits in the accumulator or memory left one bit. The Carry bit (c) is shifted into bit 0. The high bit (7 or 15) is shifted into c.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#ror","title":"ROR","text":"<p>Rotate Right</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nROR              acc        6A  1   2           n.....zc .\nROR $20          dir        66  2   7-2*m+w     n.....zc .\nROR $20,X        dir,X      76  2   8-2*m+w     n.....zc .\nROR $1234        abs        6E  3   8-2*m       n.....zc .\nROR $1234,X      abs,X      7E  3   9-2*m       n.....zc .\n</code></pre> <p>Shifts bits in the accumulator or memory right one bit. The Carry bit (c) is shifted into the high bit (15 or 7). The low bit (0) is shifted into c.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#rti","title":"RTI","text":"<p>Return From Interrupt</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nRTI              imp        40  1   7-e         nvmxdizc .\n</code></pre> <p>This returns control to the executing program. The following steps happen, in order:</p> <ol> <li>The CPU pulls the flags from the stack (including m and x, which switch to 8/16 bit mode, as appropriate.</li> <li>The CPU pulls the Program Counter from the stack.</li> <li>If the CPU is in native mode, the CPU pulls the Program Bank register.</li> </ol> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#rtl","title":"RTL","text":"<p>Return From Subroutine Long</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nRTL              imp        6B  1   6           ........ .\n</code></pre> <p>This returns to the caller at the end of a subroutine. This should be used to return to the instruction following a JSL instruction.</p> <p>This reads 3 bytes from the stack and loads them into the Program Counter and Program Bank register. The next instruction executed will then be the instruction after the JSL that jumped to the subroutine.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#rts","title":"RTS","text":"<p>Return From Subroutine</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nRTS              imp        60  1   6           ........ .\n</code></pre> <p>Return to to a calling routine after a JSR.</p> <p>RTS reads a 2 byte address from the stack and loads that address into the Program Counter. The next instruction executed will then be the instruction after the JSR that jumped to the subroutine.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#sbc","title":"SBC","text":"<p>Subtract With Carry</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nSBC #$20/#$1234  imm        E9  3-m 3-m         nv....zc .\nSBC $20          dir        E5  2   4-m+w       nv....zc .\nSBC $20,X        dir,X      F5  2   5-m+w       nv....zc .\nSBC $20,S        stk,S      E3  2   5-m         nv....zc .\nSBC $1234        abs        ED  3   5-m         nv....zc .\nSBC $1234,X      abs,X      FD  3   6-m-x+x*p   nv....zc .\nSBC $1234,Y      abs,Y      F9  3   6-m-x+x*p   nv....zc .\nSBC $FEDBCA      long       EF  4   6-m         nv....zc .\nSBC $FEDCBA,X    long,X     FF  4   6-m         nv....zc .\nSBC ($20)        (dir)      F2  2   6-m+w       nv....zc .\nSBC ($20),Y      (dir),Y    F1  2   7-m+w-x+x*p nv....zc .\nSBC ($20,X)      (dir,X)    E1  2   7-m+w       nv....zc .\nSBC ($20,S),Y    (stk,S),Y  F3  2   8-m         nv....zc .\nSBC [$20]        [dir]      E7  2   7-m+w       nv....zc .\nSBC [$20],Y      [dir],Y    F7  2   7-m+w       nv....zc .\n</code></pre> <p>Subtract a value from .A. The result is left in .A.</p> <p>When performing subtraction, the Carry bit indicates a Borrow and operates in reverse from addition: when c is 0, SBC subtracts one from the final result, to account for the borrow.</p> <p>After the operation, c will be set to 0 if a borrow took place and 1 if it did not.</p> <p>When m is 0, this will be a 16 bit add, and the CPU will read two bytes from memory.</p> <p>Since there is no \"subtract with no carry\", you should always use SEC before the first SBC in a sequence, to ensure that the Carry bit is set, going into a subtraction.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#sec","title":"SEC","text":"<p>Set Carry</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nSEC              imp        38  1   2           .......c .\n</code></pre> <p>Sets the Carry bit to 1</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#sed","title":"SED","text":"<p>Set Decimal</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nSED              imp        F8  1   2           ....d... .\n</code></pre> <p>Sets the Decimal bit to 1, setting the CPU to BCD mode.</p> <p>When Decimal is set, the CPU will store numbers in Binary Coded Decimal format. Clearing this flag restores the CPU to binary operation. See Decimal Mode for more information.</p> <p>In binary mode, adding 1 to $09 will set the Accumulator to $0A. In BCD mode, adding 1 to $09 will set the Accumulator to $10.</p> <p>Using BCD allows for easier conversion of binary numbers to decimal. BCD also allows for storing decimal numbers without loss of precision due to power-of-2 rounding.</p> <p>An add or subtract (ADC or SBC) is required to actually trigger BCD conversion. So if you have a number like $1A on the accumulator and you SED, you can convert .A to $20 with the instruction <code>ADC #$00</code>.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#sei","title":"SEI","text":"<p>Set IRQ Disable</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nSEI              imp        78  1   2           .....i.. .\n</code></pre> <p>Sets i, which inhibits IRQ handling. When i is set, the CPU will not respond to the IRQ pin. When i is clear, the CPU will perform an interrupt when the IRQ pin is asserted.</p> <p>The i flag operates somewhat non-intuitively: when i is set (1), IRQ is suppressed. When i is clear (0), interrupts are handled. So CLI allows interrupts to be handled and SEI blocks interrupt handling.</p> <p>See BRK for a brief description of interrupts.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#sep","title":"SEP","text":"<p>Set Processor Status Bit</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nSEP #$20/#$1234  imm        E2  2   3           nvmxdizc .\n</code></pre> <p>Reset Program Status Bit</p> <p>This sets (to 1) a flag in the Program Status Byte. The operand value will be loaded into the flags, so SEP #$30 will set the a and x bits high.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#sta","title":"STA","text":"<p>Store Accumulator to Memory</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nSTA $20          dir        85  2   4-m+w       ........ .\nSTA $20,X        dir,X      95  2   5-m+w       ........ .\nSTA $20,S        stk,S      83  2   5-m         ........ .\nSTA $1234        abs        8D  3   5-m         ........ .\nSTA $1234,X      abs,X      9D  3   6-m         ........ .\nSTA $1234,Y      abs,Y      99  3   6-m         ........ .\nSTA $FEDBCA      long       8F  4   6-m         ........ .\nSTA $FEDCBA,X    long,X     9F  4   6-m         ........ .\nSTA ($20)        (dir)      92  2   6-m+w       ........ .\nSTA ($20),Y      (dir),Y    91  2   7-m+w       ........ .\nSTA ($20,X)      (dir,X)    81  2   7-m+w       ........ .\nSTA ($20,S),Y    (stk,S),Y  93  2   8-m         ........ .\nSTA [$20]        [dir]      87  2   7-m+w       ........ .\nSTA [$20],Y      [dir],Y    97  2   7-m+w       ........ .\n</code></pre> <p>Stores the value in .A to a memory address.</p> <p>When m is 0, the value saved will be a 16-bit number, using two bytes of memory. When m is 1, the value will be an 8-bit number, using one byte of RAM.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#stp","title":"STP","text":"<p>Stop the Clock</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nSTP              imp        DB  1   3           ........ .\n</code></pre> <p>Halts the CPU. The CPU will no longer process instructions until the Reset pin is asserted.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#stx","title":"STX","text":"<p>Store Index X to Memory</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nSTX $20          dir        86  2   4-x+w       ........ .\nSTX $20,Y        dir,Y      96  2   5-x+w       ........ .\nSTX $1234        abs        8E  3   5-x         ........ .\n</code></pre> <p>Stores the value in .X to a memory address.</p> <p>When the flag x is 0, the value saved will be a 16-bit number, using two bytes of memory. When x is 1, the value will be an 8-bit number, using one byte of RAM.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#sty","title":"STY","text":"<p>Store Index Y to Memory</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nSTY $20          dir        84  2   4-x+w       ........ .\nSTY $20,X        dir,X      94  2   5-x+w       ........ .\nSTY $1234        abs        8C  3   5-x         ........ .\n</code></pre> <p>Stores the value in .Y to a memory address.</p> <p>When the flag x is 0, the value saved will be a 16-bit number, using two bytes of memory. When x is 1, the value will be an 8-bit number, using one byte of RAM.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#stz","title":"STZ","text":"<p>Store Sero to Memory</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nSTZ $20          dir        64  2   4-m+w       ........ .\nSTZ $20,X        dir,X      74  2   5-m+w       ........ .\nSTZ $1234        abs        9C  3   5-m         ........ .\nSTZ $1234,X      abs,X      9E  3   6-m         ........ .\n</code></pre> <p>Stores a zero to a memory address.</p> <p>When m is 0, the value saved will be a 16-bit number, using two bytes of memory. When m is 1, the value will be an 8-bit number, using one byte of RAM.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#tax","title":"TAX","text":"<p>Transfer Accumulator to Index X</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nTAX              imp        AA  1   2           n.....z. .\n</code></pre> <p>Copies the contents of .A to .X.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#tay","title":"TAY","text":"<p>Transfer Accumulator to Index Y</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nTAY              imp        A8  1   2           n.....z. .\n</code></pre> <p>Copies the contents of .A to .Y.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#tcd","title":"TCD","text":"<p>Transfer C Accumulator to Direct Register</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nTCD              imp        5B  1   2           n.....z. .\n</code></pre> <p>This copies the 16-bit value from the 16-bit Accumulator to the Direct Register, allowing you to relocate Direct Page anywhere in the first 64K of RAM.</p> <p>This is one of the times that the 16-bit Accumulator is called .C, as it always operates on a 16-bit value, regardless of the state of the m flag.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#tcs","title":"TCS","text":"<p>Transfer C Accumulator to Stack Pointer</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nTCS              imp        1B  1   2           ........ .\n</code></pre> <p>This copies the 16-bit value from the 16-bit Accumulator to the Stack Pointer, allowing you to relocate the stack anywhere in the first 64K of RAM.</p> <p>This is one of the times that the 16-bit Accumulator is called .C, as it always operates on a 16-bit value, regardless of the state of the m flag.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#tdc","title":"TDC","text":"<p>Transfer Direct Register to C Accumulator</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nTDC              imp        7B  1   2           n.....z. .\n</code></pre> <p>Copies the value of the Direct Register to the Accumulator.</p> <p>This is one of the times that the 16-bit Accumulator is called .C, as it always operates on a 16-bit value, regardless of the state of the m flag.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#trb","title":"TRB","text":"<p>Test and Reset Bit</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nTRB $20          dir        14  2   7-2*m+w     ......z. .\nTRB $1234        abs        1C  3   8-2*m       ......z. .\n</code></pre> <p>TRB does two things with one operation: it tests specified bits in a memory location, and it clears (resets) those bits after the test.</p> <p>First, TRB performs a logical AND between the memory address specified and the Accmulator. If the result of the AND is zero, the z flag will be set.</p> <p>Second, TRB clears bits in the memory value based on the bit mask in the accmulator. Any bit that is 1 in .A will be changed to 0 in memory.</p> <p>So to clear a bit in a memory value, set that value to 1 in .A, like this:</p> <pre><code>; memory at $2000 contains $84\nLDA #$80\nTRB $2000\n; memory at $2000 now contains $04, and z flag is clear\n\n; memory at $1234 contains $20\nLDA #$01\nTRB $1234\n; memory at $1234 contains $20 and z flag is set\n; because $20 AND $01 == 0.\n</code></pre> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#tsb","title":"TSB","text":"<p>Test and Set Bit</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nTSB $20          dir        04  2   7-2*m+w     ......z. .\nTSB $1234        abs        0C  3   8-2*m       ......z. .\n</code></pre> <p>TSB does two things with one operation: it tests specified bits in a memory location, and it clears (resets) those bits after the test.</p> <p>First, TSB performs a logical AND between the memory address specified and the Accmulator. If the result of the AND is zero, the z flag will be set.</p> <p>TSB also sets the bits that are 1 in the accumulator, similar to an OR operation.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#tsc","title":"TSC","text":"<p>Transfer Stack Pointer to C accumulator</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nTSC              imp        3B  1   2           n.....z. .\n</code></pre> <p>Copies the Stack Pointer to the 16-bit Accumulator.</p> <p>This is one of the times that the 16-bit Accumulator is called .C, as it always operates on a 16-bit value, regardless of the state of the m flag.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#tsx","title":"TSX","text":"<p>Transfer Stack Pointer X Register</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nTSX              imp        BA  1   2           n.....z. .\n</code></pre> <p>Copies the Stack Pointer to the X register.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#txa","title":"TXA","text":"<p>Transfer X Register to Accumulator</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nTXA              imp        8A  1   2           n.....z. .\n</code></pre> <p>Copies the value in .X to .A</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#txs","title":"TXS","text":"<p>Transfer X Register to Stack Pointer</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nTXS              imp        9A  1   2           ........ .\n</code></pre> <p>Copies the X register to the Stack Pointer. This is used to reset the stack to a known location, usually at boot or when context-switching.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#txy","title":"TXY","text":"<p>Transfer X Register to Accumulator</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nTXY              imp        9B  1   2           n.....z. .\n</code></pre> <p>Copies the value in .X to .Y</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#tya","title":"TYA","text":"<p>Transfer Y Register to Accumulator</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nTYA              imp        98  1   2           n.....z. .\n</code></pre> <p>Copies the value in .Y to .A</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#tyx","title":"TYX","text":"<p>Transfer Y Register to X Register</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nTYX              imp        BB  1   2           n.....z. .\n</code></pre> <p>Copies the value in .Y to .X</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#wai","title":"WAI","text":"<p>Wait For Interrupt</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nWAI              imp        CB  1   3           ........ .\n</code></pre> <p>Stops the CPU until the next interrupt is triggered. This allows the CPU to respond to an interrupt immediately, rather than waiting for an instruction to complete.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#wdm","title":"WDM","text":"<p>WDM</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nWDM              imm        42  2   2           ........ .\n</code></pre> <p>WDM is a 2 byte NOP: the WDM opcode and the operand byte following are both read, but not executed.</p> <p>The WDM opcode is reserved for future use and should be avoided in 65C816 programs.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#xba","title":"XBA","text":"<p>Exchange B and A Accumulator</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nXBA              imp        EB  1   3           n.....z. .\n</code></pre> <p>Swaps the values in .A and .B. This exchanges the high and low bytes of the Accumulator. XBA functions the same in both 8 and 16 bit modes.</p> <p>[Opcodes] [By Name] [By Category]</p>"},{"location":"X16%20Reference%20-%20Appendix%20F%20-%2065C816%20Processor/#xce","title":"XCE","text":"<p>Exchange Carry and Emulation Flags</p> <pre><code>SYNTAX           MODE       HEX LEN CYCLES      FLAGS   \nXCE              imp        FB  1   2           .......c e\n</code></pre> <p>This allows the CPU to switch between Native and Emulation modes.</p> <p>To switch into native mode:</p> <pre><code>CLC\nXCE\n</code></pre> <p>To switch to 65C02 emulation mode:</p> <pre><code>SEC\nXCE\n</code></pre> <p>[Opcodes] [By Name] [By Category]</p>"}]}